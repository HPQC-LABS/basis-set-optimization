#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:05 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  2.5                  1
[INPUT] 0    0    [1    /1   ]  2                    1
[INPUT] 0    0    [1    /1   ]  1.5                  1
[INPUT] 1    0    [1    /1   ]  1                    1
[INPUT] 1    0    [1    /1   ]  0.5                  1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [2.5, 1.0]], [0, [2.0, 1.0]], [0, [1.5, 1.0]], [1, [1.0, 1.0]], [1, [0.5, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [2.5]
bas 1, expnt(s) = [2.]
bas 2, expnt(s) = [1.5]
bas 3, expnt(s) = [1.]
bas 4, expnt(s) = [0.5]
CPU time:         1.23
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.         0.         0.         0.         0.         0.
 0.         0.         0.         0.         0.         0.
 0.         0.         0.         0.         0.         0.
 0.         0.         0.         0.         0.         0.
 2.5        5.02307926 2.         4.24900773 1.5        3.42439196
 1.         2.91732217 0.5        1.22658288]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 10.690838515227824
cond(S) = 9501.246575487818
E1 = -212.73811059837934  E_coul = 36.86553627468348
init E= -175.872574323696
    CPU time for initialize scf      0.21 sec, wall time      0.31 sec
  mo_energy =
[-45.28235785 -10.34852347  -9.84916425  -9.84916425  -9.84916425
  -3.4078565   -3.39740894  -3.39740894  -3.39740894]
E1 = -325.61410532439777  E_coul = 108.03929059021532
cycle= 1 E= -217.574814734182  delta_E= -41.7  |g|=    0  |ddm|= 5.3e+03
    CPU time for cycle= 1      0.32 sec, wall time      0.37 sec
diis-norm(errvec)=1.88363e-11
diis-c [-3.54807538e-22  1.00000000e+00]
  mo_energy =
[-37.9843497   -4.93429052  -4.48521205  -4.48521205  -4.48521205
   0.12334744   0.12334744   0.12334744   1.23647196]
E1 = -325.6141053243542  E_coul = 108.03929059133601
cycle= 2 E= -217.574814733018  delta_E= 1.16e-09  |g|=    0  |ddm|= 1.67e-12
    CPU time for cycle= 2      0.10 sec, wall time      0.11 sec
diis-norm(errvec)=2.12019e-11
Linear dependence found in DIIS error vectors.
diis-c [-5.55111512e-16  5.00000000e-01  5.00000000e-01]
  mo_energy =
[-37.9843497   -4.93429052  -4.48521205  -4.48521205  -4.48521205
   0.12334744   0.12334744   0.12334744   1.23647196]
E1 = -325.6141053243323  E_coul = 108.03929059048264
cycle= 3 E= -217.57481473385  delta_E= -8.31e-10  |g|=    0  |ddm|= 1.2e-12
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
E1 = -325.6141053243323  E_coul = 108.03929059048264
  mo_energy =
[-37.9843497   -4.93429052  -4.48521205  -4.48521205  -4.48521205
   0.12334744   0.12334744   0.12334744   1.23647196]
E1 = -325.6141053243757  E_coul = 108.03929059140562
Extra cycle  E= -217.57481473297  delta_E= 8.8e-10  |g|=    0  |ddm|= 2.6e-12
    CPU time for scf_cycle      0.65 sec, wall time      0.81 sec
exp = [2.5 2.  1.5 1.  0.5]
E = -217.57481473297008
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:06 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  2.5                  1
[INPUT] 0    0    [1    /1   ]  2                    1
[INPUT] 0    0    [1    /1   ]  1.5                  1
[INPUT] 1    0    [1    /1   ]  1                    1
[INPUT] 1    0    [1    /1   ]  0.5                  1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [2.5, 1.0]], [0, [2.0, 1.0]], [0, [1.5, 1.0]], [1, [1.0, 1.0]], [1, [0.5, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [2.5]
bas 1, expnt(s) = [2.]
bas 2, expnt(s) = [1.5]
bas 3, expnt(s) = [1.]
bas 4, expnt(s) = [0.5]
CPU time:         2.08
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.         0.         0.         0.         0.         0.
 0.         0.         0.         0.         0.         0.
 0.         0.         0.         0.         0.         0.
 0.         0.         0.         0.         0.         0.
 2.5        5.02307926 2.         4.24900773 1.5        3.42439196
 1.         2.91732217 0.5        1.22658288]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 10.690838515227824
cond(S) = 9501.246575487818
E1 = -212.73811059837934  E_coul = 36.86553627468348
init E= -175.872574323696
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-45.28235785 -10.34852347  -9.84916425  -9.84916425  -9.84916425
  -3.4078565   -3.39740894  -3.39740894  -3.39740894]
E1 = -325.61410532439777  E_coul = 108.03929059021532
cycle= 1 E= -217.574814734182  delta_E= -41.7  |g|=    0  |ddm|= 5.3e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.88363e-11
diis-c [-3.54807538e-22  1.00000000e+00]
  mo_energy =
[-37.9843497   -4.93429052  -4.48521205  -4.48521205  -4.48521205
   0.12334744   0.12334744   0.12334744   1.23647196]
E1 = -325.6141053243542  E_coul = 108.03929059133601
cycle= 2 E= -217.574814733018  delta_E= 1.16e-09  |g|=    0  |ddm|= 1.67e-12
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.12019e-11
Linear dependence found in DIIS error vectors.
diis-c [-5.55111512e-16  5.00000000e-01  5.00000000e-01]
  mo_energy =
[-37.9843497   -4.93429052  -4.48521205  -4.48521205  -4.48521205
   0.12334744   0.12334744   0.12334744   1.23647196]
E1 = -325.6141053243323  E_coul = 108.03929059048264
cycle= 3 E= -217.57481473385  delta_E= -8.31e-10  |g|=    0  |ddm|= 1.2e-12
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
E1 = -325.6141053243323  E_coul = 108.03929059048264
  mo_energy =
[-37.9843497   -4.93429052  -4.48521205  -4.48521205  -4.48521205
   0.12334744   0.12334744   0.12334744   1.23647196]
E1 = -325.6141053243757  E_coul = 108.03929059140562
Extra cycle  E= -217.57481473297  delta_E= 8.8e-10  |g|=    0  |ddm|= 2.6e-12
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 9501.246575487818
E1 = -325.6141053243757  E_coul = 108.03929059140562
init E= -217.57481473297
    CPU time for initialize scf      0.45 sec, wall time      0.48 sec
  mo_energy =
[-37.9843497   -4.93429052  -4.48521205  -4.48521205  -4.48521205
   0.12334744   0.12334744   0.12334744   1.23647196]
E1 = -325.6141053243575  E_coul = 108.03929059098073
cycle= 1 E= -217.574814733377  delta_E= -4.07e-10  |g|=    0  |ddm|= 9.71e-13
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -325.6141053243575  E_coul = 108.03929059098073
  mo_energy =
[-37.9843497   -4.93429052  -4.48521205  -4.48521205  -4.48521205
   0.12334744   0.12334744   0.12334744   1.23647196]
E1 = -325.6141053243575  E_coul = 108.03929059113223
Extra cycle  E= -217.574814733225  delta_E= 1.51e-10  |g|=    0  |ddm|= 2.28e-13
    CPU time for scf_cycle      1.33 sec, wall time      1.40 sec
exp = [2.5 2.  1.5 1.  0.5]
grad_E = [ -9.01187664  -7.93606343  -6.20013039 -21.59904082  -8.04911623]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:13 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  11.5118766394        1
[INPUT] 0    0    [1    /1   ]  9.93606342526        1
[INPUT] 0    0    [1    /1   ]  7.700130386          1
[INPUT] 1    0    [1    /1   ]  22.5990408223        1
[INPUT] 1    0    [1    /1   ]  8.54911622957        1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [11.511876639377107, 1.0]], [0, [9.936063425261182, 1.0]], [0, [7.700130386004588, 1.0]], [1, [22.59904082226464, 1.0]], [1, [8.54911622957411, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [11.51187664]
bas 1, expnt(s) = [9.93606343]
bas 2, expnt(s) = [7.70013039]
bas 3, expnt(s) = [22.59904082]
bas 4, expnt(s) = [8.54911623]
CPU time:         8.49
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [  0.           0.           0.           0.           0.
   0.           0.           0.           0.           0.
   0.           0.           0.           0.           0.
   0.           0.           0.           0.           0.
   0.           0.           0.           0.          11.51187664
  15.78972694   9.93606343  14.13923102   7.70013039  11.67854083
  22.59904082 143.7463748    8.54911623  42.64674796]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.145166209920717
cond(S) = 28184.817181020648
E1 = -404.72464736590405  E_coul = 96.42516399427001
init E= -308.299483371634
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-71.364221   -16.62294482 -16.62294482 -16.62294482 -10.33702394
  14.28815697  18.80629673  18.80629673  18.80629673]
E1 = -517.7104221122718  E_coul = 389.56238676849887
cycle= 1 E= -128.148035343773  delta_E=  180  |g|=    0  |ddm|= 1.49e+04
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.14391e-11
diis-c [-6.63233153e-21  1.00000000e+00]
  mo_energy =
[-43.68366369   5.90003243   5.90003243   5.90003243   6.74262732
  31.2825061   39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123424  E_coul = 389.56238675016186
cycle= 2 E= -128.148035362181  delta_E= -1.84e-08  |g|=    0  |ddm|= 1.46e-11
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.66962e-11
Linear dependence found in DIIS error vectors.
diis-c [-5.55111512e-16  5.00000000e-01  5.00000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221122079  E_coul = 389.562386777088
cycle= 3 E= -128.14803533512  delta_E= 2.71e-08  |g|=    0  |ddm|= 6.27e-12
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.8736e-11
Linear dependence found in DIIS error vectors.
diis-c [-3.88578059e-16  3.33333333e-01  3.33333333e-01  3.33333333e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.2825061   39.55520289  39.55520289  39.55520289]
E1 = -517.7104221124425  E_coul = 389.5623867286758
cycle= 4 E= -128.148035383767  delta_E= -4.86e-08  |g|=    0  |ddm|= 5.81e-12
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.04426e-10
Linear dependence found in DIIS error vectors.
diis-c [-4.4408921e-16  2.5000000e-01  2.5000000e-01  2.5000000e-01
  2.5000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221124425  E_coul = 389.56238674443983
cycle= 5 E= -128.148035368003  delta_E= 1.58e-08  |g|=    0  |ddm|= 2.41e-12
    CPU time for cycle= 5      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.80651e-11
Linear dependence found in DIIS error vectors.
diis-c [-3.05311332e-16  2.00000000e-01  2.00000000e-01  2.00000000e-01
  2.00000000e-01  2.00000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221124282  E_coul = 389.56238672566604
cycle= 6 E= -128.148035386762  delta_E= -1.88e-08  |g|=    0  |ddm|= 7.5e-12
    CPU time for cycle= 6      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.97391e-11
Linear dependence found in DIIS error vectors.
diis-c [-3.60822483e-16  1.66666667e-01  1.66666667e-01  1.66666667e-01
  1.66666667e-01  1.66666667e-01  1.66666667e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123506  E_coul = 389.562386736319
cycle= 7 E= -128.148035376032  delta_E= 1.07e-08  |g|=    0  |ddm|= 2.11e-11
    CPU time for cycle= 7      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.01413e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.42857143e-01  1.42857143e-01  1.42857143e-01
  1.42857143e-01  1.42857143e-01  1.42857143e-01  1.42857143e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221121651  E_coul = 389.5623867822514
cycle= 8 E= -128.148035329914  delta_E= 4.61e-08  |g|=    0  |ddm|= 1.26e-11
    CPU time for cycle= 8      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.95948e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123427  E_coul = 389.56238673330677
cycle= 9 E= -128.148035379036  delta_E= -4.91e-08  |g|=    0  |ddm|= 8.96e-12
    CPU time for cycle= 9      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.04857e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221120896  E_coul = 389.5623867737768
cycle= 10 E= -128.148035338313  delta_E= 4.07e-08  |g|=    0  |ddm|= 1.76e-11
    CPU time for cycle= 10      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.28358e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221121816  E_coul = 389.56238674780155
cycle= 11 E= -128.14803536438  delta_E= -2.61e-08  |g|=    0  |ddm|= 1.13e-11
    CPU time for cycle= 11      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.37881e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123262  E_coul = 389.562386731765
cycle= 12 E= -128.148035380561  delta_E= -1.62e-08  |g|=    0  |ddm|= 2.66e-12
    CPU time for cycle= 12      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.17177e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221120944  E_coul = 389.56238673556993
cycle= 13 E= -128.148035376524  delta_E= 4.04e-09  |g|=    0  |ddm|= 7.45e-12
    CPU time for cycle= 13      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.68126e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123118  E_coul = 389.562386753232
cycle= 14 E= -128.14803535908  delta_E= 1.74e-08  |g|=    0  |ddm|= 6.81e-12
    CPU time for cycle= 14      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.73576e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123262  E_coul = 389.56238673203524
cycle= 15 E= -128.148035380291  delta_E= -2.12e-08  |g|=    0  |ddm|= 2.23e-12
    CPU time for cycle= 15      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.54792e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221122524  E_coul = 389.5623867794869
cycle= 16 E= -128.148035332766  delta_E= 4.75e-08  |g|=    0  |ddm|= 5.46e-12
    CPU time for cycle= 16      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.71033e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.710422112268  E_coul = 389.5623867686027
cycle= 17 E= -128.148035343665  delta_E= -1.09e-08  |g|=    0  |ddm|= 2.05e-12
    CPU time for cycle= 17      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.21568e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123378  E_coul = 389.56238678173656
cycle= 18 E= -128.148035330601  delta_E= 1.31e-08  |g|=    0  |ddm|= 5.5e-12
    CPU time for cycle= 18      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.08792e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123844  E_coul = 389.5623867691376
cycle= 19 E= -128.148035343247  delta_E= -1.26e-08  |g|=    0  |ddm|= 3.7e-12
    CPU time for cycle= 19      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.53755e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123582  E_coul = 389.56238676036105
cycle= 20 E= -128.148035351997  delta_E= -8.75e-09  |g|=    0  |ddm|= 1.11e-11
    CPU time for cycle= 20      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.19235e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123135  E_coul = 389.5623867482081
cycle= 21 E= -128.148035364105  delta_E= -1.21e-08  |g|=    0  |ddm|= 2.33e-12
    CPU time for cycle= 21      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.78443e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221124463  E_coul = 389.56238672655985
cycle= 22 E= -128.148035385886  delta_E= -2.18e-08  |g|=    0  |ddm|= 2.61e-12
    CPU time for cycle= 22      0.02 sec, wall time      0.02 sec
diis-norm(errvec)=9.98663e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221121941  E_coul = 389.56238676871067
cycle= 23 E= -128.148035343483  delta_E= 4.24e-08  |g|=    0  |ddm|= 1.42e-11
    CPU time for cycle= 23      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.55775e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221122397  E_coul = 389.5623867562197
cycle= 24 E= -128.14803535602  delta_E= -1.25e-08  |g|=    0  |ddm|= 8.37e-12
    CPU time for cycle= 24      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.28652e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123535  E_coul = 389.5623867684122
cycle= 25 E= -128.148035343941  delta_E= 1.21e-08  |g|=    0  |ddm|= 1.46e-11
    CPU time for cycle= 25      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.00701e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123825  E_coul = 389.562386742712
cycle= 26 E= -128.14803536967  delta_E= -2.57e-08  |g|=    0  |ddm|= 1.04e-11
    CPU time for cycle= 26      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.76937e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221122872  E_coul = 389.56238676917314
cycle= 27 E= -128.148035343114  delta_E= 2.66e-08  |g|=    0  |ddm|= 1.84e-11
    CPU time for cycle= 27      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.89169e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221125355  E_coul = 389.5623867593016
cycle= 28 E= -128.148035353234  delta_E= -1.01e-08  |g|=    0  |ddm|= 1.31e-12
    CPU time for cycle= 28      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.02996e-10
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123426  E_coul = 389.5623867403376
cycle= 29 E= -128.148035372005  delta_E= -1.88e-08  |g|=    0  |ddm|= 8.65e-12
    CPU time for cycle= 29      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.66252e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221122506  E_coul = 389.56238676526453
cycle= 30 E= -128.148035346986  delta_E= 2.5e-08  |g|=    0  |ddm|= 1.45e-11
    CPU time for cycle= 30      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.73785e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.710422112459  E_coul = 389.5623867422707
cycle= 31 E= -128.148035370188  delta_E= -2.32e-08  |g|=    0  |ddm|= 1.16e-11
    CPU time for cycle= 31      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.03134e-10
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123573  E_coul = 389.56238677923795
cycle= 32 E= -128.148035333119  delta_E= 3.71e-08  |g|=    0  |ddm|= 1.17e-11
    CPU time for cycle= 32      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.05642e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221122814  E_coul = 389.5623867523895
cycle= 33 E= -128.148035359892  delta_E= -2.68e-08  |g|=    0  |ddm|= 1.58e-11
    CPU time for cycle= 33      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.85545e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.710422112174  E_coul = 389.5623867620077
cycle= 34 E= -128.148035350166  delta_E= 9.73e-09  |g|=    0  |ddm|= 1.71e-11
    CPU time for cycle= 34      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.13087e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123369  E_coul = 389.56238675832054
cycle= 35 E= -128.148035354016  delta_E= -3.85e-09  |g|=    0  |ddm|= 7.19e-12
    CPU time for cycle= 35      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.25924e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221124862  E_coul = 389.5623867494233
cycle= 36 E= -128.148035363063  delta_E= -9.05e-09  |g|=    0  |ddm|= 1.4e-11
    CPU time for cycle= 36      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.98887e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221121945  E_coul = 389.56238676865155
cycle= 37 E= -128.148035343543  delta_E= 1.95e-08  |g|=    0  |ddm|= 9.14e-12
    CPU time for cycle= 37      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.89646e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221124134  E_coul = 389.5623867578408
cycle= 38 E= -128.148035354573  delta_E= -1.1e-08  |g|=    0  |ddm|= 3.92e-12
    CPU time for cycle= 38      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.64254e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221121624  E_coul = 389.56238675517835
cycle= 39 E= -128.148035356984  delta_E= -2.41e-09  |g|=    0  |ddm|= 1.09e-11
    CPU time for cycle= 39      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.27671e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221122415  E_coul = 389.56238673890994
cycle= 40 E= -128.148035373332  delta_E= -1.63e-08  |g|=    0  |ddm|= 2.06e-11
    CPU time for cycle= 40      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.57948e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123826  E_coul = 389.5623867739556
cycle= 41 E= -128.148035338427  delta_E= 3.49e-08  |g|=    0  |ddm|= 9.28e-12
    CPU time for cycle= 41      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.67381e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221122718  E_coul = 389.56238673440885
cycle= 42 E= -128.148035377863  delta_E= -3.94e-08  |g|=    0  |ddm|= 9.89e-12
    CPU time for cycle= 42      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.4839e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221124115  E_coul = 389.56238676986936
cycle= 43 E= -128.148035342542  delta_E= 3.53e-08  |g|=    0  |ddm|= 1.45e-11
    CPU time for cycle= 43      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.11094e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221126336  E_coul = 389.56238676213246
cycle= 44 E= -128.148035350501  delta_E= -7.96e-09  |g|=    0  |ddm|= 8.29e-12
    CPU time for cycle= 44      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.15751e-10
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221123116  E_coul = 389.5623867279934
cycle= 45 E= -128.148035384318  delta_E= -3.38e-08  |g|=    0  |ddm|= 9.24e-12
    CPU time for cycle= 45      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.35128e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221124008  E_coul = 389.5623867396669
cycle= 46 E= -128.148035372734  delta_E= 1.16e-08  |g|=    0  |ddm|= 3.18e-12
    CPU time for cycle= 46      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=9.65901e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221124027  E_coul = 389.56238674769054
cycle= 47 E= -128.148035364712  delta_E= 8.02e-09  |g|=    0  |ddm|= 2.18e-12
    CPU time for cycle= 47      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.03335e-10
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221122477  E_coul = 389.5623867781858
cycle= 48 E= -128.148035334062  delta_E= 3.07e-08  |g|=    0  |ddm|= 2.09e-11
    CPU time for cycle= 48      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.86596e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250609  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221121953  E_coul = 389.5623867533375
cycle= 49 E= -128.148035358858  delta_E= -2.48e-08  |g|=    0  |ddm|= 1.46e-11
    CPU time for cycle= 49      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.11508e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.7104221124407  E_coul = 389.5623867429414
cycle= 50 E= -128.148035369499  delta_E= -1.06e-08  |g|=    0  |ddm|= 7.32e-12
    CPU time for cycle= 50      0.01 sec, wall time      0.01 sec
E1 = -517.7104221124407  E_coul = 389.5623867429414

WARN: 	An extra scf cycle is going to be run
	in order to restore the mo_energy derivatives
	missing in implicit differentiation.

  mo_energy =
[-43.6836637    5.90003243   5.90003243   5.90003243   6.74262732
  31.28250608  39.55520289  39.55520289  39.55520289]
E1 = -517.710422112206  E_coul = 389.5623867735279
Extra cycle  E= -128.148035338678  delta_E= 3.08e-08  |g|=    0  |ddm|= 5.81e-12
    CPU time for scf_cycle      0.60 sec, wall time      0.65 sec
exp = [11.51187664  9.93606343  7.70013039 22.59904082  8.54911623]
E = -128.14803533867803
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:14 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  6.50436193061        1
[INPUT] 0    0    [1    /1   ]  5.52633214265        1
[INPUT] 0    0    [1    /1   ]  4.2549829049         1
[INPUT] 1    0    [1    /1   ]  10.5973769135        1
[INPUT] 1    0    [1    /1   ]  4.07656633514        1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [6.504361930614267, 1.0]], [0, [5.526332142652661, 1.0]], [0, [4.254982904901102, 1.0]], [1, [10.59737691354352, 1.0]], [1, [4.076566335136144, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [6.50436193]
bas 1, expnt(s) = [5.52633214]
bas 2, expnt(s) = [4.2549829]
bas 3, expnt(s) = [10.59737691]
bas 4, expnt(s) = [4.07656634]
CPU time:         9.15
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  6.50436193 10.2900752   5.52633214  9.10631694  4.2549829   7.48494113
 10.59737691 55.78049563  4.07656634 16.89867037]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.906200232307128
cond(S) = 21763.236022363813
E1 = -369.43432420652954  E_coul = 91.94545381260471
init E= -277.488870393925
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-57.50319717 -16.23289718 -16.23289718 -16.23289718  -9.52688998
   1.61956686   1.61956686   1.61956686   3.69548455]
E1 = -536.0496305072618  E_coul = 275.04008888426887
cycle= 1 E= -261.009541622993  delta_E= 16.5  |g|=    0  |ddm|= 9.96e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.5421e-11
diis-c [-6.46227861e-22  1.00000000e+00]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072104  E_coul = 275.04008887487157
cycle= 2 E= -261.009541632339  delta_E= -9.35e-09  |g|=    0  |ddm|= 5.25e-12
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.00099e-11
Linear dependence found in DIIS error vectors.
diis-c [-5.55111512e-16  5.00000000e-01  5.00000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305073294  E_coul = 275.0400888802957
cycle= 3 E= -261.009541627034  delta_E= 5.31e-09  |g|=    0  |ddm|= 4.9e-12
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.08146e-11
Linear dependence found in DIIS error vectors.
diis-c [-3.88578059e-16  3.33333333e-01  3.33333333e-01  3.33333333e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072568  E_coul = 275.0400888808773
cycle= 4 E= -261.009541626379  delta_E= 6.54e-10  |g|=    0  |ddm|= 1.93e-12
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
E1 = -536.0496305072568  E_coul = 275.0400888808773
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305073663  E_coul = 275.04008889800207
Extra cycle  E= -261.009541609364  delta_E= 1.7e-08  |g|=    0  |ddm|= 5.9e-12
    CPU time for scf_cycle      0.07 sec, wall time      0.08 sec
exp = [ 6.50436193  5.52633214  4.2549829  10.59737691  4.07656634]
E = -261.0095416093642
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:14 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  6.50436193061        1
[INPUT] 0    0    [1    /1   ]  5.52633214265        1
[INPUT] 0    0    [1    /1   ]  4.2549829049         1
[INPUT] 1    0    [1    /1   ]  10.5973769135        1
[INPUT] 1    0    [1    /1   ]  4.07656633514        1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [6.504361930614267, 1.0]], [0, [5.526332142652661, 1.0]], [0, [4.254982904901102, 1.0]], [1, [10.59737691354352, 1.0]], [1, [4.076566335136144, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [6.50436193]
bas 1, expnt(s) = [5.52633214]
bas 2, expnt(s) = [4.2549829]
bas 3, expnt(s) = [10.59737691]
bas 4, expnt(s) = [4.07656634]
CPU time:         9.27
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  6.50436193 10.2900752   5.52633214  9.10631694  4.2549829   7.48494113
 10.59737691 55.78049563  4.07656634 16.89867037]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.906200232307128
cond(S) = 21763.236022363813
E1 = -369.43432420652954  E_coul = 91.94545381260471
init E= -277.488870393925
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-57.50319717 -16.23289718 -16.23289718 -16.23289718  -9.52688998
   1.61956686   1.61956686   1.61956686   3.69548455]
E1 = -536.0496305072618  E_coul = 275.04008888426887
cycle= 1 E= -261.009541622993  delta_E= 16.5  |g|=    0  |ddm|= 9.96e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.5421e-11
diis-c [-6.46227861e-22  1.00000000e+00]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072104  E_coul = 275.04008887487157
cycle= 2 E= -261.009541632339  delta_E= -9.35e-09  |g|=    0  |ddm|= 5.25e-12
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.00099e-11
Linear dependence found in DIIS error vectors.
diis-c [-5.55111512e-16  5.00000000e-01  5.00000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305073294  E_coul = 275.0400888802957
cycle= 3 E= -261.009541627034  delta_E= 5.31e-09  |g|=    0  |ddm|= 4.9e-12
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.08146e-11
Linear dependence found in DIIS error vectors.
diis-c [-3.88578059e-16  3.33333333e-01  3.33333333e-01  3.33333333e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072568  E_coul = 275.0400888808773
cycle= 4 E= -261.009541626379  delta_E= 6.54e-10  |g|=    0  |ddm|= 1.93e-12
    CPU time for cycle= 4      0.01 sec, wall time      0.02 sec
E1 = -536.0496305072568  E_coul = 275.0400888808773
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305073663  E_coul = 275.04008889800207
Extra cycle  E= -261.009541609364  delta_E= 1.7e-08  |g|=    0  |ddm|= 5.9e-12
    CPU time for scf_cycle      0.07 sec, wall time      0.08 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 21763.236022363813
E1 = -536.0496305073663  E_coul = 275.04008889800207
init E= -261.009541609364
    CPU time for initialize scf      0.04 sec, wall time      0.04 sec
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.11034261]
E1 = -536.0496305072979  E_coul = 275.040088877783
cycle= 1 E= -261.009541629515  delta_E= -2.02e-08  |g|=    0  |ddm|= 1.2e-11
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.15911e-11
diis-c [-9.97995768e-22  1.00000000e+00]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.11034259]
E1 = -536.0496305072523  E_coul = 275.04008888623144
cycle= 2 E= -261.009541621021  delta_E= 8.49e-09  |g|=    0  |ddm|= 1.6e-11
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.26296e-11
Linear dependence found in DIIS error vectors.
diis-c [-5.55111512e-16  5.00000000e-01  5.00000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072252  E_coul = 275.0400888812218
cycle= 3 E= -261.009541626003  delta_E= -4.98e-09  |g|=    0  |ddm|= 1.5e-11
    CPU time for cycle= 3      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.89716e-11
Linear dependence found in DIIS error vectors.
diis-c [-3.88578059e-16  3.33333333e-01  3.33333333e-01  3.33333333e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072277  E_coul = 275.04008887556955
cycle= 4 E= -261.009541631658  delta_E= -5.65e-09  |g|=    0  |ddm|= 7.73e-12
    CPU time for cycle= 4      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.02414e-11
Linear dependence found in DIIS error vectors.
diis-c [-4.4408921e-16  2.5000000e-01  2.5000000e-01  2.5000000e-01
  2.5000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072738  E_coul = 275.04008887700206
cycle= 5 E= -261.009541630272  delta_E= 1.39e-09  |g|=    0  |ddm|= 3.94e-12
    CPU time for cycle= 5      0.02 sec, wall time      0.02 sec
diis-norm(errvec)=3.13795e-11
Linear dependence found in DIIS error vectors.
diis-c [-3.05311332e-16  2.00000000e-01  2.00000000e-01  2.00000000e-01
  2.00000000e-01  2.00000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305071864  E_coul = 275.0400888842154
cycle= 6 E= -261.009541622971  delta_E= 7.3e-09  |g|=    0  |ddm|= 3.86e-12
    CPU time for cycle= 6      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.00679e-11
Linear dependence found in DIIS error vectors.
diis-c [-3.60822483e-16  1.66666667e-01  1.66666667e-01  1.66666667e-01
  1.66666667e-01  1.66666667e-01  1.66666667e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305070528  E_coul = 275.04008888843833
cycle= 7 E= -261.009541618614  delta_E= 4.36e-09  |g|=    0  |ddm|= 4.75e-12
    CPU time for cycle= 7      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.87268e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.42857143e-01  1.42857143e-01  1.42857143e-01
  1.42857143e-01  1.42857143e-01  1.42857143e-01  1.42857143e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305071326  E_coul = 275.0400888870602
cycle= 8 E= -261.009541620072  delta_E= -1.46e-09  |g|=    0  |ddm|= 1.77e-11
    CPU time for cycle= 8      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.11029e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072908  E_coul = 275.0400888832396
cycle= 9 E= -261.009541624051  delta_E= -3.98e-09  |g|=    0  |ddm|= 1.42e-11
    CPU time for cycle= 9      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.64018e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072104  E_coul = 275.04008886805093
cycle= 10 E= -261.009541639159  delta_E= -1.51e-08  |g|=    0  |ddm|= 5.85e-12
    CPU time for cycle= 10      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.73465e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305071983  E_coul = 275.0400888768194
cycle= 11 E= -261.009541630379  delta_E= 8.78e-09  |g|=    0  |ddm|= 5.11e-12
    CPU time for cycle= 11      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.49446e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305071276  E_coul = 275.0400888867731
cycle= 12 E= -261.009541620355  delta_E= 1e-08  |g|=    0  |ddm|= 1.18e-11
    CPU time for cycle= 12      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.23831e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072566  E_coul = 275.0400888808881
cycle= 13 E= -261.009541626368  delta_E= -6.01e-09  |g|=    0  |ddm|= 9.21e-12
    CPU time for cycle= 13      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.34688e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305074047  E_coul = 275.0400888704166
cycle= 14 E= -261.009541636988  delta_E= -1.06e-08  |g|=    0  |ddm|= 3.03e-12
    CPU time for cycle= 14      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.46555e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305073584  E_coul = 275.0400888640103
cycle= 15 E= -261.009541643348  delta_E= -6.36e-09  |g|=    0  |ddm|= 9.37e-13
    CPU time for cycle= 15      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.93775e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.11034259]
E1 = -536.0496305072979  E_coul = 275.04008888307214
cycle= 16 E= -261.009541624226  delta_E= 1.91e-08  |g|=    0  |ddm|= 2.1e-12
    CPU time for cycle= 16      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.64482e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.11034259]
E1 = -536.049630507261  E_coul = 275.04008888980434
cycle= 17 E= -261.009541617457  delta_E= 6.77e-09  |g|=    0  |ddm|= 6.11e-12
    CPU time for cycle= 17      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.08429e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.11034259]
E1 = -536.0496305072251  E_coul = 275.0400888850899
cycle= 18 E= -261.009541622135  delta_E= -4.68e-09  |g|=    0  |ddm|= 7.43e-12
    CPU time for cycle= 18      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.28621e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305071982  E_coul = 275.0400888710071
cycle= 19 E= -261.009541636191  delta_E= -1.41e-08  |g|=    0  |ddm|= 2.58e-12
    CPU time for cycle= 19      0.01 sec, wall time      0.02 sec
diis-norm(errvec)=2.00081e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072129  E_coul = 275.04008888120603
cycle= 20 E= -261.009541626007  delta_E= 1.02e-08  |g|=    0  |ddm|= 5.02e-12
    CPU time for cycle= 20      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.51968e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.11034259]
E1 = -536.0496305071771  E_coul = 275.04008888466063
cycle= 21 E= -261.009541622516  delta_E= 3.49e-09  |g|=    0  |ddm|= 1.5e-11
    CPU time for cycle= 21      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.06305e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305070966  E_coul = 275.04008887028766
cycle= 22 E= -261.009541636809  delta_E= -1.43e-08  |g|=    0  |ddm|= 1.58e-11
    CPU time for cycle= 22      0.02 sec, wall time      0.02 sec
diis-norm(errvec)=1.47363e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072063  E_coul = 275.04008888057706
cycle= 23 E= -261.009541626629  delta_E= 1.02e-08  |g|=    0  |ddm|= 1.46e-11
    CPU time for cycle= 23      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.65168e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305073029  E_coul = 275.04008888320783
cycle= 24 E= -261.009541624095  delta_E= 2.53e-09  |g|=    0  |ddm|= 5.36e-12
    CPU time for cycle= 24      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.78883e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072395  E_coul = 275.0400888867009
cycle= 25 E= -261.009541620539  delta_E= 3.56e-09  |g|=    0  |ddm|= 9.44e-12
    CPU time for cycle= 25      0.01 sec, wall time      0.02 sec
diis-norm(errvec)=2.8388e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072514  E_coul = 275.04008890035766
cycle= 26 E= -261.009541606894  delta_E= 1.36e-08  |g|=    0  |ddm|= 7.02e-12
    CPU time for cycle= 26      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.13389e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072155  E_coul = 275.0400888907942
cycle= 27 E= -261.009541616421  delta_E= -9.53e-09  |g|=    0  |ddm|= 5.52e-12
    CPU time for cycle= 27      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=5.48444e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305071648  E_coul = 275.04008888946584
cycle= 28 E= -261.009541617699  delta_E= -1.28e-09  |g|=    0  |ddm|= 3.26e-12
    CPU time for cycle= 28      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.9141e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072326  E_coul = 275.0400888859229
cycle= 29 E= -261.00954162131  delta_E= -3.61e-09  |g|=    0  |ddm|= 4.73e-12
    CPU time for cycle= 29      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.99158e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305071573  E_coul = 275.0400888804561
cycle= 30 E= -261.009541626701  delta_E= -5.39e-09  |g|=    0  |ddm|= 1.66e-12
    CPU time for cycle= 30      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.63802e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305071645  E_coul = 275.04008887532683
cycle= 31 E= -261.009541631838  delta_E= -5.14e-09  |g|=    0  |ddm|= 1.34e-11
    CPU time for cycle= 31      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.16291e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072714  E_coul = 275.04008888693824
cycle= 32 E= -261.009541620333  delta_E= 1.15e-08  |g|=    0  |ddm|= 3.05e-12
    CPU time for cycle= 32      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.9054e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072566  E_coul = 275.04008888518285
cycle= 33 E= -261.009541622074  delta_E= -1.74e-09  |g|=    0  |ddm|= 7.43e-12
    CPU time for cycle= 33      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.83233e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305073028  E_coul = 275.0400888888088
cycle= 34 E= -261.009541618494  delta_E= 3.58e-09  |g|=    0  |ddm|= 2.5e-12
    CPU time for cycle= 34      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.91869e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072105  E_coul = 275.04008887981684
cycle= 35 E= -261.009541627394  delta_E= -8.9e-09  |g|=    0  |ddm|= 3.89e-12
    CPU time for cycle= 35      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.85141e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.049630507303  E_coul = 275.04008887141396
cycle= 36 E= -261.009541635889  delta_E= -8.5e-09  |g|=    0  |ddm|= 7.1e-12
    CPU time for cycle= 36      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.45176e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072156  E_coul = 275.0400888878665
cycle= 37 E= -261.009541619349  delta_E= 1.65e-08  |g|=    0  |ddm|= 2.49e-12
    CPU time for cycle= 37      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.98655e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072273  E_coul = 275.0400889018088
cycle= 38 E= -261.009541605419  delta_E= 1.39e-08  |g|=    0  |ddm|= 5.85e-12
    CPU time for cycle= 38      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.91252e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305070888  E_coul = 275.04008888057683
cycle= 39 E= -261.009541626512  delta_E= -2.11e-08  |g|=    0  |ddm|= 5.23e-12
    CPU time for cycle= 39      0.02 sec, wall time      0.02 sec
diis-norm(errvec)=1.90908e-11
Linear dependence found in DIIS error vectors.
diis-c [-2.77555756e-16  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01  1.25000000e-01  1.25000000e-01  1.25000000e-01
  1.25000000e-01]
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.0496305072402  E_coul = 275.0400888799903
cycle= 40 E= -261.00954162725  delta_E= -7.38e-10  |g|=    0  |ddm|= 1.84e-11
    CPU time for cycle= 40      0.01 sec, wall time      0.01 sec
E1 = -536.0496305072402  E_coul = 275.0400888799903
  mo_energy =
[-41.58608262  -1.73636327  -1.73636327  -1.73636327   1.41824812
  12.76061845  12.76061845  12.76061845  14.1103426 ]
E1 = -536.049630507232  E_coul = 275.0400888910605
Extra cycle  E= -261.009541616171  delta_E= 1.11e-08  |g|=    0  |ddm|= 2.12e-11
    CPU time for scf_cycle      0.59 sec, wall time      0.63 sec
exp = [ 6.50436193  5.52633214  4.2549829  10.59737691  4.07656634]
grad_E = [-2.0428681  -1.05396981  0.75152459  1.03155475 17.25470236]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:18 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.6446449599         1
[INPUT] 0    0    [1    /1   ]  7.59024315714        1
[INPUT] 0    0    [1    /1   ]  4.3845111157         1
[INPUT] 1    0    [1    /1   ]  12.5423953882        1
[INPUT] 1    0    [1    /1   ]  1.00000008274e-09      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.64464495989629, 1.0]], [0, [7.590243157137207, 1.0]], [0, [4.384511115698264, 1.0]], [1, [12.54239538818903, 1.0]], [1, [1.000000082740371e-09, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.64464496]
bas 1, expnt(s) = [7.59024316]
bas 2, expnt(s) = [4.38451112]
bas 3, expnt(s) = [12.54239539]
bas 4, expnt(s) = [1.00000008e-09]
CPU time:        12.87
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.64464496e+00 1.38270556e+01 7.59024316e+00 1.15533197e+01
 4.38451112e+00 7.65518879e+00 1.25423954e+01 6.88588875e+01
 1.00000008e-09 1.64053099e-11]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.651457179967792
cond(S) = 2434.0415870642573
E1 = -364.0423001209425  E_coul = 86.53282541695805
init E= -277.509474703984
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-6.49289993e+01 -1.56543443e+01 -1.56543443e+01 -1.56543443e+01
 -1.16229882e+01 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  5.16934249e+00]
E1 = -469.8143763834042  E_coul = 155.73763619383845
cycle= 1 E= -314.076740189566  delta_E= -36.6  |g|=    0  |ddm|= 1.17e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.31641e-12
diis-c [-5.36576877e-24  1.00000000e+00]
  mo_energy =
[-5.73330909e+01 -8.31793896e+00 -8.31793896e+00 -8.31793896e+00
 -6.45894701e+00 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  9.57811939e+00]
E1 = -469.8143763834001  E_coul = 155.7376361938555
cycle= 2 E= -314.076740189545  delta_E= 2.11e-11  |g|=    0  |ddm|= 1.45e-12
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -469.8143763834001  E_coul = 155.7376361938555
  mo_energy =
[-5.73330909e+01 -8.31793896e+00 -8.31793896e+00 -8.31793896e+00
 -6.45894701e+00 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  9.57811939e+00]
E1 = -469.8143763833911  E_coul = 155.7376361939055
Extra cycle  E= -314.076740189486  delta_E= 5.9e-11  |g|=    0  |ddm|= 7.29e-13
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.64464496e+00 7.59024316e+00 4.38451112e+00 1.25423954e+01
 1.00000008e-09]
E = -314.0767401894856
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:18 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.6446449599         1
[INPUT] 0    0    [1    /1   ]  7.59024315714        1
[INPUT] 0    0    [1    /1   ]  4.3845111157         1
[INPUT] 1    0    [1    /1   ]  12.5423953882        1
[INPUT] 1    0    [1    /1   ]  1.00000008274e-09      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.64464495989629, 1.0]], [0, [7.590243157137207, 1.0]], [0, [4.384511115698264, 1.0]], [1, [12.54239538818903, 1.0]], [1, [1.000000082740371e-09, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.64464496]
bas 1, expnt(s) = [7.59024316]
bas 2, expnt(s) = [4.38451112]
bas 3, expnt(s) = [12.54239539]
bas 4, expnt(s) = [1.00000008e-09]
CPU time:        12.99
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.64464496e+00 1.38270556e+01 7.59024316e+00 1.15533197e+01
 4.38451112e+00 7.65518879e+00 1.25423954e+01 6.88588875e+01
 1.00000008e-09 1.64053099e-11]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.651457179967792
cond(S) = 2434.0415870642573
E1 = -364.0423001209425  E_coul = 86.53282541695805
init E= -277.509474703984
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-6.49289993e+01 -1.56543443e+01 -1.56543443e+01 -1.56543443e+01
 -1.16229882e+01 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  5.16934249e+00]
E1 = -469.8143763834042  E_coul = 155.73763619383845
cycle= 1 E= -314.076740189566  delta_E= -36.6  |g|=    0  |ddm|= 1.17e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.31641e-12
diis-c [-5.36576877e-24  1.00000000e+00]
  mo_energy =
[-5.73330909e+01 -8.31793896e+00 -8.31793896e+00 -8.31793896e+00
 -6.45894701e+00 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  9.57811939e+00]
E1 = -469.8143763834001  E_coul = 155.7376361938555
cycle= 2 E= -314.076740189545  delta_E= 2.11e-11  |g|=    0  |ddm|= 1.45e-12
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -469.8143763834001  E_coul = 155.7376361938555
  mo_energy =
[-5.73330909e+01 -8.31793896e+00 -8.31793896e+00 -8.31793896e+00
 -6.45894701e+00 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  9.57811939e+00]
E1 = -469.8143763833911  E_coul = 155.7376361939055
Extra cycle  E= -314.076740189486  delta_E= 5.9e-11  |g|=    0  |ddm|= 7.29e-13
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2434.0415870642573
E1 = -469.8143763833911  E_coul = 155.7376361939055
init E= -314.076740189486
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-5.73330909e+01 -8.31793896e+00 -8.31793896e+00 -8.31793896e+00
 -6.45894701e+00 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  9.57811939e+00]
E1 = -469.81437638340554  E_coul = 155.73763619393281
cycle= 1 E= -314.076740189473  delta_E= 1.28e-11  |g|=    0  |ddm|= 4.77e-13
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -469.81437638340554  E_coul = 155.73763619393281
  mo_energy =
[-5.73330909e+01 -8.31793896e+00 -8.31793896e+00 -8.31793896e+00
 -6.45894701e+00 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  9.57811939e+00]
E1 = -469.81437638340026  E_coul = 155.7376361935633
Extra cycle  E= -314.076740189837  delta_E= -3.64e-10  |g|=    0  |ddm|= 1.15e-13
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.64464496e+00 7.59024316e+00 4.38451112e+00 1.25423954e+01
 1.00000008e-09]
grad_E = [-2.11846853e+00 -8.84550002e-01  2.67476356e+00  1.95677783e+00
 -6.66105458e+06]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:20 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.23191288095        1
[INPUT] 0    0    [1    /1   ]  6.97647962172        1
[INPUT] 0    0    [1    /1   ]  3.37587161665        1
[INPUT] 1    0    [1    /1   ]  9.5616740296         1
[INPUT] 1    0    [1    /1   ]  4.0765544097         1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.23191288095309, 1.0]], [0, [6.976479621724667, 1.0]], [0, [3.3758716166547296, 1.0]], [1, [9.561674029599612, 1.0]], [1, [4.076554409697489, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.23191288]
bas 1, expnt(s) = [6.97647962]
bas 2, expnt(s) = [3.37587162]
bas 3, expnt(s) = [9.56167403]
bas 4, expnt(s) = [4.07655441]
CPU time:        15.81
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  9.23191288 13.38085293  6.97647962 10.84531753  3.37587162  6.29222822
  9.56167403 49.05144548  4.07655441 16.89860858]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 10.028627064645889
cond(S) = 1061.4779616899086
E1 = -378.7658839622505  E_coul = 95.10495540859594
init E= -283.660928553655
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-62.31776682 -15.47181846 -15.47181846 -15.47181846 -10.56179804
   1.59756791   1.59756791   1.59756791   4.14505042]
E1 = -547.8830727826215  E_coul = 275.8193471479012
cycle= 1 E= -272.06372563472  delta_E= 11.6  |g|=    0  |ddm|=  492
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=5.51979e-12
diis-c [-3.04680475e-23  1.00000000e+00]
  mo_energy =
[-46.47217149  -1.38104549  -1.38104549  -1.38104549   0.72652388
  12.36629957  12.36629957  12.36629957  14.66769612]
E1 = -547.883072782618  E_coul = 275.8193471479376
cycle= 2 E= -272.06372563468  delta_E= 3.99e-11  |g|=    0  |ddm|= 1.45e-13
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -547.883072782618  E_coul = 275.8193471479376
  mo_energy =
[-46.47217149  -1.38104549  -1.38104549  -1.38104549   0.72652388
  12.36629957  12.36629957  12.36629957  14.66769612]
E1 = -547.8830727826312  E_coul = 275.819347147925
Extra cycle  E= -272.063725634706  delta_E= -2.58e-11  |g|=    0  |ddm|= 5.41e-13
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [9.23191288 6.97647962 3.37587162 9.56167403 4.07655441]
E = -272.0637256347062
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:21 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.43827923971        1
[INPUT] 0    0    [1    /1   ]  7.28336186424        1
[INPUT] 0    0    [1    /1   ]  3.88019214646        1
[INPUT] 1    0    [1    /1   ]  11.0520370148        1
[INPUT] 1    0    [1    /1   ]  2.03827405172        1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.438279239714495, 1.0]], [0, [7.283361864238809, 1.0]], [0, [3.880192146460672, 1.0]], [1, [11.05203701478231, 1.0]], [1, [2.038274051723592, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.43827924]
bas 1, expnt(s) = [7.28336186]
bas 2, expnt(s) = [3.88019215]
bas 3, expnt(s) = [11.05203701]
bas 4, expnt(s) = [2.03827405]
CPU time:        15.95
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  9.43827924 13.6045644   7.28336186 11.20118423  3.88019215  6.98481565
 11.05203701 58.78781326  2.03827405  7.10497595]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.238938551847014
cond(S) = 1608.837260312337
E1 = -409.8912971025461  E_coul = 112.76122503595357
init E= -297.130072066593
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-61.36806072 -14.38710878 -14.38710878 -14.38710878  -8.95603071
  -1.52171707  -1.52171707  -1.52171707   6.77369283]
E1 = -565.3630055456604  E_coul = 258.0180643566121
cycle= 1 E= -307.344941189048  delta_E= -10.2  |g|=    0  |ddm|=  758
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.90978e-12
diis-c [-3.64724475e-24  1.00000000e+00]
  mo_energy =
[-48.97793135  -3.41060993  -3.41060993  -3.41060993   0.2187565
   6.42639378   6.42639378   6.42639378  15.04838487]
E1 = -565.3630055456555  E_coul = 258.01806435644374
cycle= 2 E= -307.344941189212  delta_E= -1.63e-10  |g|=    0  |ddm|= 2.31e-13
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -565.3630055456555  E_coul = 258.01806435644374
  mo_energy =
[-48.97793135  -3.41060993  -3.41060993  -3.41060993   0.2187565
   6.42639378   6.42639378   6.42639378  15.04838487]
E1 = -565.363005545656  E_coul = 258.0180643565752
Extra cycle  E= -307.344941189081  delta_E= 1.31e-10  |g|=    0  |ddm|= 7.6e-13
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [ 9.43827924  7.28336186  3.88019215 11.05203701  2.03827405]
E = -307.3449411890808
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:21 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.54146215097        1
[INPUT] 0    0    [1    /1   ]  7.43680258677        1
[INPUT] 0    0    [1    /1   ]  4.13235175611        1
[INPUT] 1    0    [1    /1   ]  11.797216571         1
[INPUT] 1    0    [1    /1   ]  1.01913652105        1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.54146215096566, 1.0]], [0, [7.43680258676716, 1.0]], [0, [4.13235175610553, 1.0]], [1, [11.797216570961437, 1.0]], [1, [1.0191365210518772, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.54146215]
bas 1, expnt(s) = [7.43680259]
bas 2, expnt(s) = [4.13235176]
bas 3, expnt(s) = [11.79721657]
bas 4, expnt(s) = [1.01913652]
CPU time:        16.09
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  9.54146215 13.71596042  7.43680259 11.37770617  4.13235176  7.3225608
 11.79721657 63.78357139  1.01913652  2.98727255]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 13.061990411162355
cond(S) = 1978.9615122748555
E1 = -432.16883299505884  E_coul = 129.70939326277366
init E= -302.459439732285
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-60.20700464 -12.23494692 -12.23494692 -12.23494692  -7.46891767
  -2.64500992  -2.64500992  -2.64500992   8.68048782]
E1 = -558.6306454239091  E_coul = 236.43372493738025
cycle= 1 E= -322.196920486529  delta_E= -19.7  |g|=    0  |ddm|=  941
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.60798e-12
diis-c [-4.36654469e-23  1.00000000e+00]
  mo_energy =
[-51.09824812  -4.07723896  -4.07723896  -4.07723896  -0.87256331
   2.27594156   2.27594156   2.27594156  14.49310584]
E1 = -558.6306454239334  E_coul = 236.43372493734697
cycle= 2 E= -322.196920486586  delta_E= -5.76e-11  |g|=    0  |ddm|= 3.44e-13
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -558.6306454239334  E_coul = 236.43372493734697
  mo_energy =
[-51.09824812  -4.07723896  -4.07723896  -4.07723896  -0.87256331
   2.27594156   2.27594156   2.27594156  14.49310584]
E1 = -558.6306454239239  E_coul = 236.43372493741342
Extra cycle  E= -322.19692048651  delta_E= 7.61e-11  |g|=    0  |ddm|= 1.21e-13
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [ 9.54146215  7.43680259  4.13235176 11.79721657  1.01913652]
E = -322.1969204865104
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:21 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.59305349372        1
[INPUT] 0    0    [1    /1   ]  7.51352278018        1
[INPUT] 0    0    [1    /1   ]  4.25843128509        1
[INPUT] 1    0    [1    /1   ]  12.1698055339        1
[INPUT] 1    0    [1    /1   ]  0.509568870553       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.593053493719195, 1.0]], [0, [7.513522780182142, 1.0]], [0, [4.258431285089925, 1.0]], [1, [12.169805533897204, 1.0]], [1, [0.5095688705531375, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.59305349]
bas 1, expnt(s) = [7.51352278]
bas 2, expnt(s) = [4.25843129]
bas 3, expnt(s) = [12.16980553]
bas 4, expnt(s) = [0.50956887]
CPU time:        16.23
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  9.59305349 13.77154527  7.51352278 11.46562491  4.25843129  7.4894902
 12.16980553 66.31151355  0.50956887  1.25599527]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 14.418412035613414
cond(S) = 2194.709795301847
E1 = -433.0863013019099  E_coul = 131.32330104842998
init E= -301.76300025348
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-60.41351944 -11.64939512 -11.64939512 -11.64939512  -7.40614324
  -2.59490408  -2.59490408  -2.59490408   9.03549023]
E1 = -540.9066889852336  E_coul = 215.9854794287804
cycle= 1 E= -324.921209556453  delta_E= -23.2  |g|=    0  |ddm|= 1.05e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.40581e-12
diis-c [-5.48460573e-23  1.00000000e+00]
  mo_energy =
[-52.81381138  -4.53884364  -4.53884364  -4.53884364  -2.1755762
   0.19896985   0.19896985   0.19896985  13.54114388]
E1 = -540.9066889852304  E_coul = 215.9854794284555
cycle= 2 E= -324.921209556775  delta_E= -3.22e-10  |g|=    0  |ddm|= 3.64e-13
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -540.9066889852304  E_coul = 215.9854794284555
  mo_energy =
[-52.81381138  -4.53884364  -4.53884364  -4.53884364  -2.1755762
   0.19896985   0.19896985   0.19896985  13.54114388]
E1 = -540.906688985232  E_coul = 215.98547942846704
Extra cycle  E= -324.921209556765  delta_E= 9.95e-12  |g|=    0  |ddm|= 1.23e-12
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [ 9.59305349  7.51352278  4.25843129 12.16980553  0.50956887]
E = -324.92120955676495
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:21 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.61884914439        1
[INPUT] 0    0    [1    /1   ]  7.5518828461         1
[INPUT] 0    0    [1    /1   ]  4.32147099898        1
[INPUT] 1    0    [1    /1   ]  12.3560998658        1
[INPUT] 1    0    [1    /1   ]  0.254785249799       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.618849144391735, 1.0]], [0, [7.551882846100894, 1.0]], [0, [4.321470998984887, 1.0]], [1, [12.356099865840642, 1.0]], [1, [0.25478524979941153, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.61884914]
bas 1, expnt(s) = [7.55188285]
bas 2, expnt(s) = [4.321471]
bas 3, expnt(s) = [12.35609987]
bas 4, expnt(s) = [0.25478525]
CPU time:        16.36
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  9.61884914 13.79930963  7.55188285 11.5095      4.321471    7.57249031
 12.35609987 67.58279592  0.25478525  0.52808307]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 13.830266265231103
cond(S) = 2311.2657336464817
E1 = -410.0612170715541  E_coul = 114.99996499350398
init E= -295.06125207805
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-62.0308933  -12.95929587 -12.95929587 -12.95929587  -8.86326007
  -2.53068812  -2.53068812  -2.53068812   7.76420986]
E1 = -523.0572468609935  E_coul = 199.37025010975978
cycle= 1 E= -323.686996751234  delta_E= -28.6  |g|=    0  |ddm|= 1.11e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=5.577e-12
diis-c [-3.11029826e-23  1.00000000e+00]
  mo_energy =
[-54.11045667  -5.334672    -5.334672    -5.334672    -3.32829142
  -0.4260337   -0.4260337   -0.4260337   12.56249188]
E1 = -523.0572468609997  E_coul = 199.37025011015962
cycle= 2 E= -323.68699675084  delta_E= 3.94e-10  |g|=    0  |ddm|= 4.18e-13
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -523.0572468609997  E_coul = 199.37025011015962
  mo_energy =
[-54.11045667  -5.334672    -5.334672    -5.334672    -3.32829142
  -0.4260337   -0.4260337   -0.4260337   12.56249188]
E1 = -523.0572468610031  E_coul = 199.3702501098735
Extra cycle  E= -323.68699675113  delta_E= -2.9e-10  |g|=    0  |ddm|= 1.01e-12
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [ 9.61884914  7.55188285  4.321471   12.35609987  0.25478525]
E = -323.68699675112964
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:21 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.63174697911        1
[INPUT] 0    0    [1    /1   ]  7.57106289301        1
[INPUT] 0    0    [1    /1   ]  4.35299087885        1
[INPUT] 1    0    [1    /1   ]  12.4492470996        1
[INPUT] 1    0    [1    /1   ]  0.12739334678        1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.631746979107618, 1.0]], [0, [7.571062893008459, 1.0]], [0, [4.35299087885438, 1.0]], [1, [12.44924709955126, 1.0]], [1, [0.1273933467801077, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.63174698]
bas 1, expnt(s) = [7.57106289]
bas 2, expnt(s) = [4.35299088]
bas 3, expnt(s) = [12.4492471]
bas 4, expnt(s) = [0.12739335]
CPU time:        16.50
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  9.63174698 13.81318484  7.57106289 11.53141666  4.35299088  7.61387675
 12.4492471  68.22024134  0.12739335  0.22203315]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.802136221690716
cond(S) = 2371.8546598849957
E1 = -384.39807276763287  E_coul = 98.06408990994646
init E= -286.333982857686
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-63.66677044 -14.48316885 -14.48316885 -14.48316885 -10.42446632
  -2.45605436  -2.45605436  -2.45605436   6.29172995]
E1 = -508.60380097351833  E_coul = 186.92109193860864
cycle= 1 E= -321.68270903491  delta_E= -35.3  |g|=    0  |ddm|= 1.14e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.54142e-11
diis-c [-2.37598044e-22  1.00000000e+00]
  mo_energy =
[-55.04993507  -6.12668081  -6.12668081  -6.12668081  -4.21579047
  -0.49586577  -0.49586577  -0.49586577  11.75255672]
E1 = -508.6038009735103  E_coul = 186.92109193869842
cycle= 2 E= -321.682709034812  delta_E= 9.78e-11  |g|=    0  |ddm|= 1.54e-12
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -508.6038009735103  E_coul = 186.92109193869842
  mo_energy =
[-55.04993507  -6.12668081  -6.12668081  -6.12668081  -4.21579047
  -0.49586577  -0.49586577  -0.49586577  11.75255672]
E1 = -508.6038009735355  E_coul = 186.92109193837635
Extra cycle  E= -321.682709035159  delta_E= -3.47e-10  |g|=    0  |ddm|= 2.33e-13
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [ 9.63174698  7.57106289  4.35299088 12.4492471   0.12739335]
E = -321.6827090351592
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:21 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.6381959117         1
[INPUT] 0    0    [1    /1   ]  7.58065293911        1
[INPUT] 0    0    [1    /1   ]  4.36875085601        1
[INPUT] 1    0    [1    /1   ]  12.4958208264        1
[INPUT] 1    0    [1    /1   ]  0.0636972448233      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.638195911697633, 1.0]], [0, [7.580652939113473, 1.0]], [0, [4.36875085601344, 1.0]], [1, [12.495820826411489, 1.0]], [1, [0.06369724482329979, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.63819591]
bas 1, expnt(s) = [7.58065294]
bas 2, expnt(s) = [4.36875086]
bas 3, expnt(s) = [12.49582083]
bas 4, expnt(s) = [0.06369724]
CPU time:        16.64
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.63819591e+00 1.38201207e+01 7.58065294e+00 1.15423698e+01
 4.36875086e+00 7.63454190e+00 1.24958208e+01 6.85394128e+01
 6.36972448e-02 9.33544882e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.993189507504894
cond(S) = 2402.7454542736045
E1 = -370.2899612865469  E_coul = 89.79870134795978
init E= -280.491259938587
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-64.53639427 -15.30494452 -15.30494452 -15.30494452 -11.26044368
  -2.11917659  -2.11917659  -2.11917659   5.49568125]
E1 = -497.732605426407  E_coul = 177.90721957744876
cycle= 1 E= -319.825385848958  delta_E= -39.3  |g|=    0  |ddm|= 1.15e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.21779e-11
diis-c [-1.48302025e-22  1.00000000e+00]
  mo_energy =
[-55.71870724  -6.74478254  -6.74478254  -6.74478254  -4.86334975
  -0.42768672  -0.42768672  -0.42768672  11.14038162]
E1 = -497.732605426407  E_coul = 177.90721957744967
cycle= 2 E= -319.825385848957  delta_E= 9.09e-13  |g|=    0  |ddm|= 2.05e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -497.732605426407  E_coul = 177.90721957744967
  mo_energy =
[-55.71870724  -6.74478254  -6.74478254  -6.74478254  -4.86334975
  -0.42768672  -0.42768672  -0.42768672  11.14038162]
E1 = -497.73260542641106  E_coul = 177.90721957772092
Extra cycle  E= -319.82538584869  delta_E= 2.67e-10  |g|=    0  |ddm|= 9.43e-14
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [ 9.63819591  7.58065294  4.36875086 12.49582083  0.06369724]
E = -319.82538584869013
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:21 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.64142039211        1
[INPUT] 0    0    [1    /1   ]  7.58544798316        1
[INPUT] 0    0    [1    /1   ]  4.37663087909        1
[INPUT] 1    0    [1    /1   ]  12.5191077918        1
[INPUT] 1    0    [1    /1   ]  0.0318490544291      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.64142039210784, 1.0]], [0, [7.585447983156343, 1.0]], [0, [4.376630879087866, 1.0]], [1, [12.519107791780575, 1.0]], [1, [0.031849054429059866, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.64142039]
bas 1, expnt(s) = [7.58544798]
bas 2, expnt(s) = [4.37663088]
bas 3, expnt(s) = [12.51910779]
bas 4, expnt(s) = [0.03184905]
CPU time:        16.77
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.64142039e+00 1.38235882e+01 7.58544798e+00 1.15478451e+01
 4.37663088e+00 7.64486753e+00 1.25191078e+01 6.86991108e+01
 3.18490544e-02 3.92513927e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.075567060332673
cond(S) = 2418.3423651199782
E1 = -365.46657501137753  E_coul = 87.23717253018451
init E= -278.229402481193
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-64.83289793 -15.57926159 -15.57926159 -15.57926159 -11.5413767
  -1.64353329  -1.64353329  -1.64353329   5.23336099]
E1 = -489.7835665690589  E_coul = 171.46399490270412
cycle= 1 E= -318.319571666355  delta_E= -40.1  |g|=    0  |ddm|= 1.16e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.47958e-11
diis-c [-2.18915692e-22  1.00000000e+00]
  mo_energy =
[-56.19205811  -7.19674633  -7.19674633  -7.19674633  -5.3270778
  -0.33731364  -0.33731364  -0.33731364  10.69352746]
E1 = -489.7835665690845  E_coul = 171.46399490283252
cycle= 2 E= -318.319571666252  delta_E= 1.03e-10  |g|=    0  |ddm|= 5.92e-13
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -489.7835665690845  E_coul = 171.46399490283252
  mo_energy =
[-56.19205811  -7.19674633  -7.19674633  -7.19674633  -5.3270778
  -0.33731364  -0.33731364  -0.33731364  10.69352746]
E1 = -489.7835665690668  E_coul = 171.46399490243925
Extra cycle  E= -318.319571666628  delta_E= -3.76e-10  |g|=    0  |ddm|= 2.71e-13
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [ 9.64142039  7.58544798  4.37663088 12.51910779  0.03184905]
E = -318.31957166662755
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:22 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.64303264376        1
[INPUT] 0    0    [1    /1   ]  7.5878455222         1
[INPUT] 0    0    [1    /1   ]  4.38057091859        1
[INPUT] 1    0    [1    /1   ]  12.5307513571        1
[INPUT] 1    0    [1    /1   ]  0.0159248462013      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.64303264375677, 1.0]], [0, [7.587845522195606, 1.0]], [0, [4.380570918591636, 1.0]], [1, [12.530751357111608, 1.0]], [1, [0.015924846201277734, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.64303264]
bas 1, expnt(s) = [7.58784552]
bas 2, expnt(s) = [4.38057092]
bas 3, expnt(s) = [12.53075136]
bas 4, expnt(s) = [0.01592485]
CPU time:        16.90
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.64303264e+00 1.38253219e+01 7.58784552e+00 1.15505825e+01
 4.38057092e+00 7.65002864e+00 1.25307514e+01 6.87789883e+01
 1.59248462e-02 1.65035910e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.758902968326652
cond(S) = 2426.1790394696277
E1 = -364.3078280686385  E_coul = 86.65630858317563
init E= -277.651519485463
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-64.90695715 -15.64267136 -15.64267136 -15.64267136 -11.60804763
  -1.20592936  -1.20592936  -1.20592936   5.17561781]
E1 = -484.04508160508726  E_coul = 166.88104493808214
cycle= 1 E= -317.164036667005  delta_E= -39.5  |g|=    0  |ddm|= 1.16e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.60429e-12
diis-c [-7.40338849e-23  1.00000000e+00]
  mo_energy =
[-56.52660639  -7.52124791  -7.52124791  -7.52124791  -5.65700236
  -0.25533856  -0.25533856  -0.25533856  10.37187229]
E1 = -484.0450816050985  E_coul = 166.88104493836875
cycle= 2 E= -317.16403666673  delta_E= 2.75e-10  |g|=    0  |ddm|= 1.06e-12
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -484.0450816050985  E_coul = 166.88104493836875
  mo_energy =
[-56.52660639  -7.52124791  -7.52124791  -7.52124791  -5.65700236
  -0.25533856  -0.25533856  -0.25533856  10.37187229]
E1 = -484.04508160509783  E_coul = 166.8810449380223
Extra cycle  E= -317.164036667075  delta_E= -3.46e-10  |g|=    0  |ddm|= 4.27e-14
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [ 9.64303264  7.58784552  4.38057092 12.53075136  0.01592485]
E = -317.1640366670755
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:22 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.64383877836        1
[INPUT] 0    0    [1    /1   ]  7.58904430477        1
[INPUT] 0    0    [1    /1   ]  4.3825409598         1
[INPUT] 1    0    [1    /1   ]  12.5365732032        1
[INPUT] 1    0    [1    /1   ]  0.00796265534964      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.643838778363026, 1.0]], [0, [7.5890443047744185, 1.0]], [0, [4.382540959804565, 1.0]], [1, [12.536573203198587, 1.0]], [1, [0.007962655349642566, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.64383878]
bas 1, expnt(s) = [7.5890443]
bas 2, expnt(s) = [4.38254096]
bas 3, expnt(s) = [12.5365732]
bas 4, expnt(s) = [0.00796266]
CPU time:        17.04
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.64383878e+00 1.38261887e+01 7.58904430e+00 1.15519511e+01
 4.38254096e+00 7.65260879e+00 1.25365732e+01 6.88189344e+01
 7.96265535e-03 6.93915823e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.675127622931768
cond(S) = 2430.106998367821
E1 = -364.0888949799025  E_coul = 86.5514004759802
init E= -277.537494503922
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-64.92297407 -15.65347343 -15.65347343 -15.65347343 -11.62048101
  -0.86609187  -0.86609187  -0.86609187   5.16754698]
E1 = -479.9311262703208  E_coul = 163.62851210749895
cycle= 1 E= -316.302614162822  delta_E= -38.8  |g|=    0  |ddm|= 1.17e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.46171e-12
diis-c [-4.17536464e-23  1.00000000e+00]
  mo_energy =
[-56.76300832  -7.75273238  -7.75273238  -7.75273238  -5.89112689
  -0.18885644  -0.18885644  -0.18885644  10.14185064]
E1 = -479.9311262703269  E_coul = 163.62851210733686
cycle= 2 E= -316.30261416299  delta_E= -1.68e-10  |g|=    0  |ddm|= 5.76e-13
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -479.9311262703269  E_coul = 163.62851210733686
  mo_energy =
[-56.76300832  -7.75273238  -7.75273238  -7.75273238  -5.89112689
  -0.18885644  -0.18885644  -0.18885644  10.14185064]
E1 = -479.9311262703196  E_coul = 163.62851210758174
Extra cycle  E= -316.302614162738  delta_E= 2.52e-10  |g|=    0  |ddm|= 4.97e-13
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.64383878e+00 7.58904430e+00 4.38254096e+00 1.25365732e+01
 7.96265535e-03]
E = -316.3026141627379
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:22 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.64424185221        1
[INPUT] 0    0    [1    /1   ]  7.5896437058         1
[INPUT] 0    0    [1    /1   ]  4.38352599641        1
[INPUT] 1    0    [1    /1   ]  12.5394841735        1
[INPUT] 1    0    [1    /1   ]  0.00398149526299      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.644241852212762, 1.0]], [0, [7.589643705799121, 1.0]], [0, [4.3835259964097055, 1.0]], [1, [12.539484173521204, 1.0]], [1, [0.003981495262988666, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.64424185]
bas 1, expnt(s) = [7.58964371]
bas 2, expnt(s) = [4.383526]
bas 3, expnt(s) = [12.53948417]
bas 4, expnt(s) = [0.0039815]
CPU time:        17.17
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.64424185e+00 1.38266221e+01 7.58964371e+00 1.15526354e+01
 4.38352600e+00 7.65389877e+00 1.25394842e+01 6.88389095e+01
 3.98149526e-03 2.91771015e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.656362598441206
cond(S) = 2432.073409304946
E1 = -364.05188774106693  E_coul = 86.53527431149341
init E= -277.516613429574
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-64.92678258 -15.65469885 -15.65469885 -15.65469885 -11.62252385
  -0.61737135  -0.61737135  -0.61737135   5.16766159]
E1 = -476.9944942914216  E_coul = 161.3229697614793
cycle= 1 E= -315.671524529942  delta_E= -38.2  |g|=    0  |ddm|= 1.17e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.4008e-11
diis-c [-1.96223157e-22  1.00000000e+00]
  mo_energy =
[-56.93007483  -7.91735757  -7.91735757  -7.91735757  -6.0570609
  -0.13767707  -0.13767707  -0.13767707   9.97796226]
E1 = -476.9944942914367  E_coul = 161.32296976121006
cycle= 2 E= -315.671524530227  delta_E= -2.84e-10  |g|=    0  |ddm|= 4.46e-13
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -476.9944942914367  E_coul = 161.32296976121006
  mo_energy =
[-56.93007483  -7.91735757  -7.91735757  -7.91735757  -6.0570609
  -0.13767707  -0.13767707  -0.13767707   9.97796226]
E1 = -476.99449429144283  E_coul = 161.32296976123376
Extra cycle  E= -315.671524530209  delta_E= 1.76e-11  |g|=    0  |ddm|= 9.26e-13
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.64424185e+00 7.58964371e+00 4.38352600e+00 1.25394842e+01
 3.98149526e-03]
E = -315.67152453020907
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:22 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  9.64424185221        1
[INPUT] 0    0    [1    /1   ]  7.5896437058         1
[INPUT] 0    0    [1    /1   ]  4.38352599641        1
[INPUT] 1    0    [1    /1   ]  12.5394841735        1
[INPUT] 1    0    [1    /1   ]  0.00398149526299      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [9.644241852212762, 1.0]], [0, [7.589643705799121, 1.0]], [0, [4.3835259964097055, 1.0]], [1, [12.539484173521204, 1.0]], [1, [0.003981495262988666, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [9.64424185]
bas 1, expnt(s) = [7.58964371]
bas 2, expnt(s) = [4.383526]
bas 3, expnt(s) = [12.53948417]
bas 4, expnt(s) = [0.0039815]
CPU time:        17.31
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.64424185e+00 1.38266221e+01 7.58964371e+00 1.15526354e+01
 4.38352600e+00 7.65389877e+00 1.25394842e+01 6.88389095e+01
 3.98149526e-03 2.91771015e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.656362598441206
cond(S) = 2432.073409304946
E1 = -364.05188774106693  E_coul = 86.53527431149341
init E= -277.516613429574
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-64.92678258 -15.65469885 -15.65469885 -15.65469885 -11.62252385
  -0.61737135  -0.61737135  -0.61737135   5.16766159]
E1 = -476.9944942914216  E_coul = 161.3229697614793
cycle= 1 E= -315.671524529942  delta_E= -38.2  |g|=    0  |ddm|= 1.17e+03
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.4008e-11
diis-c [-1.96223157e-22  1.00000000e+00]
  mo_energy =
[-56.93007483  -7.91735757  -7.91735757  -7.91735757  -6.0570609
  -0.13767707  -0.13767707  -0.13767707   9.97796226]
E1 = -476.9944942914367  E_coul = 161.32296976121006
cycle= 2 E= -315.671524530227  delta_E= -2.84e-10  |g|=    0  |ddm|= 4.46e-13
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -476.9944942914367  E_coul = 161.32296976121006
  mo_energy =
[-56.93007483  -7.91735757  -7.91735757  -7.91735757  -6.0570609
  -0.13767707  -0.13767707  -0.13767707   9.97796226]
E1 = -476.99449429144283  E_coul = 161.32296976123376
Extra cycle  E= -315.671524530209  delta_E= 1.76e-11  |g|=    0  |ddm|= 9.26e-13
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2432.073409304946
E1 = -476.99449429144283  E_coul = 161.32296976123376
init E= -315.671524530209
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-56.93007483  -7.91735757  -7.91735757  -7.91735757  -6.0570609
  -0.13767707  -0.13767707  -0.13767707   9.97796226]
E1 = -476.9944942914299  E_coul = 161.32296976145923
cycle= 1 E= -315.671524529971  delta_E= 2.38e-10  |g|=    0  |ddm|= 5.76e-13
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -476.9944942914299  E_coul = 161.32296976145923
  mo_energy =
[-56.93007483  -7.91735757  -7.91735757  -7.91735757  -6.0570609
  -0.13767707  -0.13767707  -0.13767707   9.97796226]
E1 = -476.9944942914323  E_coul = 161.3229697611062
Extra cycle  E= -315.671524530326  delta_E= -3.55e-10  |g|=    0  |ddm|= 3.02e-13
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.64424185e+00 7.58964371e+00 4.38352600e+00 1.25394842e+01
 3.98149526e-03]
grad_E = [  -2.11950468   -0.88476476    2.67574637    1.95563462 -192.35461719]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:25 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  12.7548189578        1
[INPUT] 0    0    [1    /1   ]  9.11463325498        1
[INPUT] 0    0    [1    /1   ]  1.71639120614        1
[INPUT] 1    0    [1    /1   ]  11.1090232242        1
[INPUT] 1    0    [1    /1   ]  0.00398161196557      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [12.754818957754907, 1.0]], [0, [9.114633254976264, 1.0]], [0, [1.716391206135064, 1.0]], [1, [11.109023224171905, 1.0]], [1, [0.003981611965565248, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [12.75481896]
bas 1, expnt(s) = [9.11463325]
bas 2, expnt(s) = [1.71639121]
bas 3, expnt(s) = [11.10902322]
bas 4, expnt(s) = [0.00398161]
CPU time:        20.09
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.27548190e+01 1.70518203e+01 9.11463325e+00 1.32531595e+01
 1.71639121e+00 3.78858674e+00 1.11090232e+01 5.91669573e+01
 3.98161197e-03 2.91781706e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.40037913228683
cond(S) = 193.88542145777149
E1 = -385.70327993795644  E_coul = 94.50903717846239
init E= -291.194242759494
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-67.30665163 -14.93198117 -14.93198117 -14.93198117 -12.95870096
  -0.56743563  -0.56743563  -0.56743563   0.30519218]
E1 = -494.624814202975  E_coul = 154.59665160415534
cycle= 1 E= -340.02816259882  delta_E= -48.8  |g|=    0  |ddm|= 79.9
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.46711e-13
diis-c [-4.18235119e-25  1.00000000e+00]
  mo_energy =
[-60.983698    -8.90389203  -8.90389203  -8.90389203  -8.68723976
  -0.13767981  -0.13767981  -0.13767981   4.07989776]
E1 = -494.62481420297337  E_coul = 154.59665160415815
cycle= 2 E= -340.028162598815  delta_E= 4.43e-12  |g|=    0  |ddm|= 2.54e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -494.62481420297337  E_coul = 154.59665160415815
  mo_energy =
[-60.983698    -8.90389203  -8.90389203  -8.90389203  -8.68723976
  -0.13767981  -0.13767981  -0.13767981   4.07989776]
E1 = -494.6248142029735  E_coul = 154.5966516041559
Extra cycle  E= -340.028162598818  delta_E= -2.33e-12  |g|=    0  |ddm|= 5.89e-14
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [1.27548190e+01 9.11463325e+00 1.71639121e+00 1.11090232e+01
 3.98161197e-03]
E = -340.0281625988176
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:25 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  12.7548189578        1
[INPUT] 0    0    [1    /1   ]  9.11463325498        1
[INPUT] 0    0    [1    /1   ]  1.71639120614        1
[INPUT] 1    0    [1    /1   ]  11.1090232242        1
[INPUT] 1    0    [1    /1   ]  0.00398161196557      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [12.754818957754907, 1.0]], [0, [9.114633254976264, 1.0]], [0, [1.716391206135064, 1.0]], [1, [11.109023224171905, 1.0]], [1, [0.003981611965565248, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [12.75481896]
bas 1, expnt(s) = [9.11463325]
bas 2, expnt(s) = [1.71639121]
bas 3, expnt(s) = [11.10902322]
bas 4, expnt(s) = [0.00398161]
CPU time:        20.25
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.27548190e+01 1.70518203e+01 9.11463325e+00 1.32531595e+01
 1.71639121e+00 3.78858674e+00 1.11090232e+01 5.91669573e+01
 3.98161197e-03 2.91781706e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.40037913228683
cond(S) = 193.88542145777149
E1 = -385.70327993795644  E_coul = 94.50903717846239
init E= -291.194242759494
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-67.30665163 -14.93198117 -14.93198117 -14.93198117 -12.95870096
  -0.56743563  -0.56743563  -0.56743563   0.30519218]
E1 = -494.624814202975  E_coul = 154.59665160415534
cycle= 1 E= -340.02816259882  delta_E= -48.8  |g|=    0  |ddm|= 79.9
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.46711e-13
diis-c [-4.18235119e-25  1.00000000e+00]
  mo_energy =
[-60.983698    -8.90389203  -8.90389203  -8.90389203  -8.68723976
  -0.13767981  -0.13767981  -0.13767981   4.07989776]
E1 = -494.62481420297337  E_coul = 154.59665160415815
cycle= 2 E= -340.028162598815  delta_E= 4.43e-12  |g|=    0  |ddm|= 2.54e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -494.62481420297337  E_coul = 154.59665160415815
  mo_energy =
[-60.983698    -8.90389203  -8.90389203  -8.90389203  -8.68723976
  -0.13767981  -0.13767981  -0.13767981   4.07989776]
E1 = -494.6248142029735  E_coul = 154.5966516041559
Extra cycle  E= -340.028162598818  delta_E= -2.33e-12  |g|=    0  |ddm|= 5.89e-14
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 193.88542145777149
E1 = -494.6248142029735  E_coul = 154.5966516041559
init E= -340.028162598818
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-60.983698    -8.90389203  -8.90389203  -8.90389203  -8.68723976
  -0.13767981  -0.13767981  -0.13767981   4.07989776]
E1 = -494.62481420297206  E_coul = 154.59665160415662
cycle= 1 E= -340.028162598815  delta_E= 2.1e-12  |g|=    0  |ddm|= 1.81e-13
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -494.62481420297206  E_coul = 154.59665160415662
  mo_energy =
[-60.983698    -8.90389203  -8.90389203  -8.90389203  -8.68723976
  -0.13767981  -0.13767981  -0.13767981   4.07989776]
E1 = -494.6248142029742  E_coul = 154.5966516041574
Extra cycle  E= -340.028162598817  delta_E= -1.36e-12  |g|=    0  |ddm|= 4.57e-14
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [1.27548190e+01 9.11463325e+00 1.71639121e+00 1.11090232e+01
 3.98161197e-03]
grad_E = [  -2.59466445   -1.29968586    6.33871543    1.33377571 -192.35383758]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:28 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  17.528948313         1
[INPUT] 0    0    [1    /1   ]  11.6691791556        1
[INPUT] 0    0    [1    /1   ]  1.00000008274e-09      1
[INPUT] 1    0    [1    /1   ]  9.54967430409        1
[INPUT] 1    0    [1    /1   ]  0.00398176254007      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [17.528948312957805, 1.0]], [0, [11.669179155641274, 1.0]], [0, [1.000000082740371e-09, 1.0]], [1, [9.549674304094108, 1.0]], [1, [0.003981762540073739, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [17.52894831]
bas 1, expnt(s) = [11.66917916]
bas 2, expnt(s) = [1.00000008e-09]
bas 3, expnt(s) = [9.5496743]
bas 4, expnt(s) = [0.00398176]
CPU time:        22.96
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.75289483e+01 2.16437206e+01 1.16691792e+01 1.59512696e+01
 1.00000008e-09 4.49277895e-07 9.54967430e+00 4.89745092e+01
 3.98176254e-03 2.91795499e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.668668490553408
cond(S) = 64.87177509741173
E1 = -387.1418184046691  E_coul = 88.47168863045049
init E= -298.670129774219
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-7.49030368e+01 -1.56401717e+01 -1.56401717e+01 -1.56401717e+01
 -9.81556745e+00 -6.16564158e-01 -6.16564158e-01 -6.16564158e-01
 -4.70882239e-04]
E1 = -477.50947229724966  E_coul = 125.73244202129014
cycle= 1 E= -351.77703027596  delta_E= -53.1  |g|=    0  |ddm|= 18.3
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.81375e-13
diis-c [-7.91716515e-26  1.00000000e+00]
  mo_energy =
[-7.05353447e+01 -1.17759312e+01 -1.17759312e+01 -1.17759312e+01
 -6.34357387e+00 -2.71838919e-01 -2.71838919e-01 -2.71838919e-01
 -6.52414346e-05]
E1 = -477.5094722972499  E_coul = 125.73244202129017
cycle= 2 E= -351.77703027596  delta_E= -1.71e-13  |g|=    0  |ddm|= 1.75e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -477.5094722972499  E_coul = 125.73244202129017
  mo_energy =
[-7.05353447e+01 -1.17759312e+01 -1.17759312e+01 -1.17759312e+01
 -6.34357387e+00 -2.71838919e-01 -2.71838919e-01 -2.71838919e-01
 -6.52414346e-05]
E1 = -477.50947229725006  E_coul = 125.73244202129038
Extra cycle  E= -351.77703027596  delta_E= 5.68e-14  |g|=    0  |ddm|= 4.82e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [1.75289483e+01 1.16691792e+01 1.00000008e-09 9.54967430e+00
 3.98176254e-03]
E = -351.77703027595965
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:28 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  17.528948313         1
[INPUT] 0    0    [1    /1   ]  11.6691791556        1
[INPUT] 0    0    [1    /1   ]  1.00000008274e-09      1
[INPUT] 1    0    [1    /1   ]  9.54967430409        1
[INPUT] 1    0    [1    /1   ]  0.00398176254007      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [17.528948312957805, 1.0]], [0, [11.669179155641274, 1.0]], [0, [1.000000082740371e-09, 1.0]], [1, [9.549674304094108, 1.0]], [1, [0.003981762540073739, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [17.52894831]
bas 1, expnt(s) = [11.66917916]
bas 2, expnt(s) = [1.00000008e-09]
bas 3, expnt(s) = [9.5496743]
bas 4, expnt(s) = [0.00398176]
CPU time:        23.12
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.75289483e+01 2.16437206e+01 1.16691792e+01 1.59512696e+01
 1.00000008e-09 4.49277895e-07 9.54967430e+00 4.89745092e+01
 3.98176254e-03 2.91795499e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.668668490553408
cond(S) = 64.87177509741173
E1 = -387.1418184046691  E_coul = 88.47168863045049
init E= -298.670129774219
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-7.49030368e+01 -1.56401717e+01 -1.56401717e+01 -1.56401717e+01
 -9.81556745e+00 -6.16564158e-01 -6.16564158e-01 -6.16564158e-01
 -4.70882239e-04]
E1 = -477.50947229724966  E_coul = 125.73244202129014
cycle= 1 E= -351.77703027596  delta_E= -53.1  |g|=    0  |ddm|= 18.3
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.81375e-13
diis-c [-7.91716515e-26  1.00000000e+00]
  mo_energy =
[-7.05353447e+01 -1.17759312e+01 -1.17759312e+01 -1.17759312e+01
 -6.34357387e+00 -2.71838919e-01 -2.71838919e-01 -2.71838919e-01
 -6.52414346e-05]
E1 = -477.5094722972499  E_coul = 125.73244202129017
cycle= 2 E= -351.77703027596  delta_E= -1.71e-13  |g|=    0  |ddm|= 1.75e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -477.5094722972499  E_coul = 125.73244202129017
  mo_energy =
[-7.05353447e+01 -1.17759312e+01 -1.17759312e+01 -1.17759312e+01
 -6.34357387e+00 -2.71838919e-01 -2.71838919e-01 -2.71838919e-01
 -6.52414346e-05]
E1 = -477.50947229725006  E_coul = 125.73244202129038
Extra cycle  E= -351.77703027596  delta_E= 5.68e-14  |g|=    0  |ddm|= 4.82e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 64.87177509741173
E1 = -477.50947229725006  E_coul = 125.73244202129038
init E= -351.77703027596
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-7.05353447e+01 -1.17759312e+01 -1.17759312e+01 -1.17759312e+01
 -6.34357387e+00 -2.71838919e-01 -2.71838919e-01 -2.71838919e-01
 -6.52414346e-05]
E1 = -477.50947229725  E_coul = 125.7324420212902
cycle= 1 E= -351.77703027596  delta_E= -1.71e-13  |g|=    0  |ddm|= 5.38e-14
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -477.50947229725  E_coul = 125.7324420212902
  mo_energy =
[-7.05353447e+01 -1.17759312e+01 -1.17759312e+01 -1.17759312e+01
 -6.34357387e+00 -2.71838919e-01 -2.71838919e-01 -2.71838919e-01
 -6.52414346e-05]
E1 = -477.5094722972496  E_coul = 125.73244202129023
Extra cycle  E= -351.777030275959  delta_E= 4.55e-13  |g|=    0  |ddm|= 2.58e-14
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [1.75289483e+01 1.16691792e+01 1.00000008e-09 9.54967430e+00
 3.98176254e-03]
grad_E = [-1.92718457e+00 -2.94343572e-01 -8.30813972e+04  5.94706305e-01
 -2.93495611e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:31 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  55.5994631236        1
[INPUT] 0    0    [1    /1   ]  31.8760312529        1
[INPUT] 0    0    [1    /1   ]  1.71687513717        1
[INPUT] 1    0    [1    /1   ]  1.00000008274e-09      1
[INPUT] 1    0    [1    /1   ]  0.00398297410977      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [55.59946312359557, 1.0]], [0, [31.876031252944202, 1.0]], [0, [1.716875137170689, 1.0]], [1, [1.000000082740371e-09, 1.0]], [1, [0.00398297410976778, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [55.59946312]
bas 1, expnt(s) = [31.87603125]
bas 2, expnt(s) = [1.71687514]
bas 3, expnt(s) = [1.00000008e-09]
bas 4, expnt(s) = [0.00398297]
CPU time:        25.84
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 5.55994631e+01 5.14420151e+01 3.18760313e+01 3.38932494e+01
 1.71687514e+00 3.78938785e+00 1.00000008e-09 1.64053099e-11
 3.98297411e-03 2.91906487e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 4.03501039947832
cond(S) = 40.541701932873735
E1 = -298.7394865145259  E_coul = 21.747177725234828
init E= -276.992308789291
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-1.16913483e+02 -2.47352788e+01 -9.27766183e-01 -9.27766183e-01
 -9.27766183e-01 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  1.70874582e+01]
E1 = -323.21058385322584  E_coul = 52.163950608011596
cycle= 1 E= -271.046633245214  delta_E= 5.95  |g|=    0  |ddm|= 29.3
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.72004e-13
diis-c [-2.95854394e-26  1.00000000e+00]
  mo_energy =
[-1.08331571e+02 -2.08618477e+01 -5.40546300e-01 -5.40546300e-01
 -5.40546300e-01 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  2.13755335e+01]
E1 = -323.21058385322664  E_coul = 52.163950608011795
cycle= 2 E= -271.046633245215  delta_E= -5.68e-13  |g|=    0  |ddm|= 2.63e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -323.21058385322664  E_coul = 52.163950608011795
  mo_energy =
[-1.08331571e+02 -2.08618477e+01 -5.40546300e-01 -5.40546300e-01
 -5.40546300e-01 -6.05549330e-04 -6.05549330e-04 -6.05549330e-04
  2.13755335e+01]
E1 = -323.2105838532257  E_coul = 52.163950608011376
Extra cycle  E= -271.046633245214  delta_E= 4.55e-13  |g|=    0  |ddm|= 2.56e-14
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [5.55994631e+01 3.18760313e+01 1.71687514e+00 1.00000008e-09
 3.98297411e-03]
E = -271.04663324521437
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:31 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  36.5534448071        1
[INPUT] 0    0    [1    /1   ]  21.7668935888        1
[INPUT] 0    0    [1    /1   ]  0.857952281692       1
[INPUT] 1    0    [1    /1   ]  4.77753643827        1
[INPUT] 1    0    [1    /1   ]  0.00398236798246      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [36.55344480707561, 1.0]], [0, [21.766893588829852, 1.0]], [0, [0.857952281692317, 1.0]], [1, [4.777536438272134, 1.0]], [1, [0.003982367982461669, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [36.55344481]
bas 1, expnt(s) = [21.76689359]
bas 2, expnt(s) = [0.85795228]
bas 3, expnt(s) = [4.77753644]
bas 4, expnt(s) = [0.00398237]
CPU time:        26.02
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 3.65534448e+01 3.75587610e+01 2.17668936e+01 2.54602325e+01
 8.57952282e-01 2.25222811e+00 4.77753644e+00 2.06057963e+01
 3.98236798e-03 2.91850961e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.63782345900319
cond(S) = 44.35855481250425
E1 = -422.0444154961862  E_coul = 83.36533359052072
init E= -338.679081905665
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-95.87077057 -14.08949666 -14.08949666 -14.08949666 -13.52043479
  -0.55154081  -0.55154081  -0.55154081   6.16121971]
E1 = -508.3443091597135  E_coul = 137.64030997464516
cycle= 1 E= -370.703999185068  delta_E=  -32  |g|=    0  |ddm|= 18.8
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.34699e-14
diis-c [-6.96721951e-27  1.00000000e+00]
  mo_energy =
[-88.522636    -9.85533119  -9.54723124  -9.54723124  -9.54723124
  -0.13768719  -0.13768719  -0.13768719  10.9008779 ]
E1 = -508.3443091597126  E_coul = 137.640309974645
cycle= 2 E= -370.703999185068  delta_E= 6.82e-13  |g|=    0  |ddm|= 7.83e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -508.3443091597126  E_coul = 137.640309974645
  mo_energy =
[-88.522636    -9.85533119  -9.54723124  -9.54723124  -9.54723124
  -0.13768719  -0.13768719  -0.13768719  10.9008779 ]
E1 = -508.3443091597131  E_coul = 137.640309974645
Extra cycle  E= -370.703999185068  delta_E= -4.55e-13  |g|=    0  |ddm|= 4.01e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [3.65534448e+01 2.17668936e+01 8.57952282e-01 4.77753644e+00
 3.98236798e-03]
E = -370.7039991850681
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:31 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  27.0437215164        1
[INPUT] 0    0    [1    /1   ]  16.7193765543        1
[INPUT] 0    0    [1    /1   ]  0.429090009908       1
[INPUT] 1    0    [1    /1   ]  7.16297200673        1
[INPUT] 1    0    [1    /1   ]  0.00398206534162      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [27.04372151637122, 1.0]], [0, [16.719376554259934, 1.0]], [0, [0.429090009908392, 1.0]], [1, [7.1629720067294205, 1.0]], [1, [0.0039820653416228185, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [27.04372152]
bas 1, expnt(s) = [16.71937655]
bas 2, expnt(s) = [0.42909001]
bas 3, expnt(s) = [7.16297201]
bas 4, expnt(s) = [0.00398207]
CPU time:        26.20
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 2.70437215e+01 2.99615906e+01 1.67193766e+01 2.08895981e+01
 4.29090010e-01 1.33944945e+00 7.16297201e+00 3.41862103e+01
 3.98206534e-03 2.91823237e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 10.608324229533117
cond(S) = 49.26422316877705
E1 = -434.42945398790664  E_coul = 102.08561259239099
init E= -332.343841395516
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-85.06967539 -13.68854862 -13.68854862 -13.68854862  -9.83079348
  -0.48638685  -0.48638685  -0.48638685  -0.16194028]
E1 = -515.6127871940017  E_coul = 142.14877845395483
cycle= 1 E= -373.464008740047  delta_E= -41.1  |g|=    0  |ddm|= 13.2
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.20583e-13
diis-c [-1.45402843e-26  1.00000000e+00]
  mo_energy =
[-80.21642769 -10.13824088 -10.13824088 -10.13824088  -7.53432795
  -0.13769898  -0.13769898  -0.13769898   2.92096005]
E1 = -515.6127871940027  E_coul = 142.14877845395466
cycle= 2 E= -373.464008740048  delta_E= -1.19e-12  |g|=    0  |ddm|= 6.08e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -515.6127871940027  E_coul = 142.14877845395466
  mo_energy =
[-80.21642769 -10.13824088 -10.13824088 -10.13824088  -7.53432795
  -0.13769898  -0.13769898  -0.13769898   2.92096005]
E1 = -515.6127871940014  E_coul = 142.14877845395446
Extra cycle  E= -373.464008740047  delta_E= 1.19e-12  |g|=    0  |ddm|= 5.6e-14
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [2.70437215e+01 1.67193766e+01 4.29090010e-01 7.16297201e+00
 3.98206534e-03]
E = -373.4640087400469
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:31 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  22.2892290625        1
[INPUT] 0    0    [1    /1   ]  14.1958139943        1
[INPUT] 0    0    [1    /1   ]  0.214675523533       1
[INPUT] 1    0    [1    /1   ]  8.35559718232        1
[INPUT] 1    0    [1    /1   ]  0.00398191403295      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [22.289229062502955, 1.0]], [0, [14.195813994338527, 1.0]], [0, [0.21467552353331687, 1.0]], [1, [8.355597182322626, 1.0]], [1, [0.003981914032952676, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [22.28922906]
bas 1, expnt(s) = [14.19581399]
bas 2, expnt(s) = [0.21467552]
bas 3, expnt(s) = [8.35559718]
bas 4, expnt(s) = [0.00398191]
CPU time:        26.38
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 2.22892291e+01 2.59170944e+01 1.41958140e+01 1.84771613e+01
 2.14675524e-01 7.96804764e-01 8.35559718e+00 4.14434843e+01
 3.98191403e-03 2.91809376e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 10.547023046835292
cond(S) = 54.29186132833153
E1 = -420.7480751766268  E_coul = 100.59044421083732
init E= -320.15763096579
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-79.90138549 -14.17040632 -14.17040632 -14.17040632  -8.51515824
  -3.16021952  -0.49053454  -0.49053454  -0.49053454]
E1 = -507.80137476663356  E_coul = 139.80417183856622
cycle= 1 E= -367.997202928067  delta_E= -47.8  |g|=    0  |ddm|= 13.1
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.22349e-13
diis-c [-1.03908759e-25  1.00000000e+00]
  mo_energy =
[-75.38876947 -10.51113998 -10.51113998 -10.51113998  -6.06072486
  -0.70037198  -0.1377431   -0.1377431   -0.1377431 ]
E1 = -507.80137476663253  E_coul = 139.80417183856588
cycle= 2 E= -367.997202928067  delta_E= 6.82e-13  |g|=    0  |ddm|= 4.84e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -507.80137476663253  E_coul = 139.80417183856588
  mo_energy =
[-75.38876947 -10.51113998 -10.51113998 -10.51113998  -6.06072486
  -0.70037198  -0.1377431   -0.1377431   -0.1377431 ]
E1 = -507.80137476663407  E_coul = 139.8041718385666
Extra cycle  E= -367.997202928068  delta_E= -8.53e-13  |g|=    0  |ddm|= 2.34e-14
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [2.22892291e+01 1.41958140e+01 2.14675524e-01 8.35559718e+00
 3.98191403e-03]
E = -367.9972029280675
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:31 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  19.9112539371        1
[INPUT] 0    0    [1    /1   ]  12.9336458338        1
[INPUT] 0    0    [1    /1   ]  0.107435409036       1
[INPUT] 1    0    [1    /1   ]  8.95209260828        1
[INPUT] 1    0    [1    /1   ]  0.00398183835542      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [19.911253937090923, 1.0]], [0, [12.93364583377455, 1.0]], [0, [0.10743540903632297, 1.0]], [1, [8.952092608284108, 1.0]], [1, [0.003981838355420878, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [19.91125394]
bas 1, expnt(s) = [12.93364583]
bas 2, expnt(s) = [0.10743541]
bas 3, expnt(s) = [8.95209261]
bas 4, expnt(s) = [0.00398184]
CPU time:        26.56
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.99112539e+01 2.38143637e+01 1.29336458e+01 1.72308121e+01
 1.07435409e-01 4.74106168e-01 8.95209261e+00 4.51741615e+01
 3.98183836e-03 2.91802444e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.966222074281134
cond(S) = 58.40819544935922
E1 = -405.1603168221707  E_coul = 95.0292434108731
init E= -310.131073411298
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-77.48937907 -14.85761523 -14.85761523 -14.85761523  -8.70864755
  -3.60344679  -0.52960764  -0.52960764  -0.52960764]
E1 = -499.2611834106819  E_coul = 136.6584468517994
cycle= 1 E= -362.602736558882  delta_E= -52.5  |g|=    0  |ddm|= 14.8
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.02392e-13
diis-c [-4.09624533e-26  1.00000000e+00]
  mo_energy =
[-72.78336153 -10.823591   -10.823591   -10.823591    -5.36645158
  -1.93782687  -0.13791062  -0.13791062  -0.13791062]
E1 = -499.2611834106818  E_coul = 136.6584468517994
cycle= 2 E= -362.602736558882  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.53e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -499.2611834106818  E_coul = 136.6584468517994
  mo_energy =
[-72.78336153 -10.823591   -10.823591   -10.823591    -5.36645158
  -1.93782687  -0.13791062  -0.13791062  -0.13791062]
E1 = -499.2611834106821  E_coul = 136.65844685179945
Extra cycle  E= -362.602736558883  delta_E= -2.84e-13  |g|=    0  |ddm|= 3.97e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [1.99112539e+01 1.29336458e+01 1.07435409e-01 8.95209261e+00
 3.98183836e-03]
E = -362.60273655888267
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:31 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  18.7215466997        1
[INPUT] 0    0    [1    /1   ]  12.3021797686        1
[INPUT] 0    0    [1    /1   ]  0.0537828964441      1
[INPUT] 1    0    [1    /1   ]  9.25052084573        1
[INPUT] 1    0    [1    /1   ]  0.00398180049375      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [18.721546699658, 1.0]], [0, [12.302179768619567, 1.0]], [0, [0.0537828964440803, 1.0]], [1, [9.25052084572795, 1.0]], [1, [0.0039818004937517935, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [18.7215467]
bas 1, expnt(s) = [12.30217977]
bas 2, expnt(s) = [0.0537829]
bas 3, expnt(s) = [9.25052085]
bas 4, expnt(s) = [0.0039818]
CPU time:        26.73
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.87215467e+01 2.27389977e+01 1.23021798e+01 1.65959293e+01
 5.37828964e-02 2.82161766e-01 9.25052085e+00 4.70643565e+01
 3.98180049e-03 2.91798975e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.36999796634769
cond(S) = 61.21642039282228
E1 = -395.2625949772119  E_coul = 91.23478305809618
init E= -304.027811919116
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-76.29321691 -15.30657592 -15.30657592 -15.30657592  -9.23379765
  -2.99986459  -0.56976283  -0.56976283  -0.56976283]
E1 = -492.6435659291081  E_coul = 133.949340657156
cycle= 1 E= -358.694225271952  delta_E= -54.7  |g|=    0  |ddm|= 16.3
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.38094e-14
diis-c [-7.0240176e-27  1.0000000e+00]
  mo_energy =
[-71.47561928 -11.07598851 -11.07598851 -11.07598851  -5.42012875
  -1.83322316  -0.13850186  -0.13850186  -0.13850186]
E1 = -492.643565929108  E_coul = 133.94934065715628
cycle= 2 E= -358.694225271952  delta_E= 3.41e-13  |g|=    0  |ddm|= 1.29e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -492.643565929108  E_coul = 133.94934065715628
  mo_energy =
[-71.47561928 -11.07598851 -11.07598851 -11.07598851  -5.42012875
  -1.83322316  -0.13850186  -0.13850186  -0.13850186]
E1 = -492.6435659291084  E_coul = 133.94934065715597
Extra cycle  E= -358.694225271952  delta_E= -6.82e-13  |g|=    0  |ddm|= 2.36e-14
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [1.87215467e+01 1.23021798e+01 5.37828964e-02 9.25052085e+00
 3.98180049e-03]
E = -358.6942252719524
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:32 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  18.1261714808        1
[INPUT] 0    0    [1    /1   ]  11.9861698841        1
[INPUT] 0    0    [1    /1   ]  0.0269331174216      1
[INPUT] 1    0    [1    /1   ]  9.39986580354        1
[INPUT] 1    0    [1    /1   ]  0.00398178154632      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [18.12617148080723, 1.0]], [0, [11.98616988407881, 1.0]], [0, [0.02693311742161633, 1.0]], [1, [9.39986580353686, 1.0]], [1, [0.0039817815463176615, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [18.12617148]
bas 1, expnt(s) = [11.98616988]
bas 2, expnt(s) = [0.02693312]
bas 3, expnt(s) = [9.3998658]
bas 4, expnt(s) = [0.00398178]
CPU time:        26.92
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.81261715e+01 2.21944602e+01 1.19861699e+01 1.62751630e+01
 2.69331174e-02 1.67969331e-01 9.39986580e+00 4.80160532e+01
 3.98178155e-03 2.91797240e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.988791932158456
cond(S) = 62.90520310817557
E1 = -390.5435287783038  E_coul = 89.50456433298866
init E= -301.038964445315
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-75.64896777 -15.51307482 -15.51307482 -15.51307482  -9.54633859
  -2.27800932  -0.59548536  -0.59548536  -0.59548536]
E1 = -487.95774164620855  E_coul = 131.85843285280978
cycle= 1 E= -356.099308793399  delta_E= -55.1  |g|=    0  |ddm|= 17.2
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.42682e-13
diis-c [-5.88947356e-26  1.00000000e+00]
  mo_energy =
[-70.86019931 -11.26949896 -11.26949896 -11.26949896  -5.67594905
  -1.35468452  -0.1403694   -0.1403694   -0.1403694 ]
E1 = -487.9577416462092  E_coul = 131.8584328528098
cycle= 2 E= -356.099308793399  delta_E= -5.68e-13  |g|=    0  |ddm|= 1.92e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -487.9577416462092  E_coul = 131.8584328528098
  mo_energy =
[-70.86019931 -11.26949896 -11.26949896 -11.26949896  -5.67594905
  -1.35468452  -0.1403694   -0.1403694   -0.1403694 ]
E1 = -487.957741646209  E_coul = 131.85843285280987
Extra cycle  E= -356.099308793399  delta_E= 2.27e-13  |g|=    0  |ddm|= 9.29e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [1.81261715e+01 1.19861699e+01 2.69331174e-02 9.39986580e+00
 3.98178155e-03]
E = -356.09930879339913
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:32 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  17.8281374734        1
[INPUT] 0    0    [1    /1   ]  11.8279810826        1
[INPUT] 0    0    [1    /1   ]  0.0134926063155      1
[INPUT] 1    0    [1    /1   ]  9.47462517353        1
[INPUT] 1    0    [1    /1   ]  0.00398177206158      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [17.82813747335503, 1.0]], [0, [11.827981082626872, 1.0]], [0, [0.013492606315498798, 1.0]], [1, [9.474625173526235, 1.0]], [1, [0.003981772061576701, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [17.82813747]
bas 1, expnt(s) = [11.82798108]
bas 2, expnt(s) = [0.01349261]
bas 3, expnt(s) = [9.47462517]
bas 4, expnt(s) = [0.00398177]
CPU time:        27.10
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.78281375e+01 2.19201996e+01 1.18279811e+01 1.61138008e+01
 1.34926063e-02 1.00020014e-01 9.47462517e+00 4.84938807e+01
 3.98177206e-03 2.91796371e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.800380040456652
cond(S) = 63.84466749537144
E1 = -388.5771481645807  E_coul = 88.85061336390956
init E= -299.726534800671
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-75.29518369 -15.59248241 -15.59248241 -15.59248241  -9.69192273
  -1.66755005  -0.60819174  -0.60819174  -0.60819174]
E1 = -484.7304195498202  E_coul = 130.30009382369184
cycle= 1 E= -354.430325726128  delta_E= -54.7  |g|=    0  |ddm|= 17.8
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.48227e-14
diis-c [-6.16168877e-28  1.00000000e+00]
  mo_energy =
[-70.5911982  -11.41284582 -11.41284582 -11.41284582  -5.88788761
  -0.91172191  -0.14525692  -0.14525692  -0.14525692]
E1 = -484.73041954981994  E_coul = 130.3000938236922
cycle= 2 E= -354.430325726128  delta_E= 6.25e-13  |g|=    0  |ddm|= 1.76e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -484.73041954981994  E_coul = 130.3000938236922
  mo_energy =
[-70.5911982  -11.41284582 -11.41284582 -11.41284582  -5.88788761
  -0.91172191  -0.14525692  -0.14525692  -0.14525692]
E1 = -484.7304195498195  E_coul = 130.3000938236921
Extra cycle  E= -354.430325726127  delta_E= 3.41e-13  |g|=    0  |ddm|= 6.2e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [1.78281375e+01 1.18279811e+01 1.34926063e-02 9.47462517e+00
 3.98177206e-03]
E = -354.4303257261274
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:32 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  17.6788976017        1
[INPUT] 0    0    [1    /1   ]  11.7487683893        1
[INPUT] 0    0    [1    /1   ]  0.00676230003606      1
[INPUT] 1    0    [1    /1   ]  9.51206076309        1
[INPUT] 1    0    [1    /1   ]  0.00398176731211      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [17.678897601745607, 1.0]], [0, [11.74876838934883, 1.0]], [0, [0.006762300036059351, 1.0]], [1, [9.512060763089298, 1.0]], [1, [0.003981767312113593, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [17.6788976]
bas 1, expnt(s) = [11.74876839]
bas 2, expnt(s) = [0.0067623]
bas 3, expnt(s) = [9.51206076]
bas 4, expnt(s) = [0.00398177]
CPU time:        27.27
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.76788976e+01 2.17824341e+01 1.17487684e+01 1.60327965e+01
 6.76230004e-03 5.95779906e-02 9.51206076e+00 4.87335066e+01
 3.98176731e-03 2.91795936e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.71990733904066
cond(S) = 64.34429139873882
E1 = -387.77615114679423  E_coul = 88.61778034970074
init E= -299.158370797093
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-75.10527249 -15.62135709 -15.62135709 -15.62135709  -9.75719467
  -1.20039357  -0.61353086  -0.61353086  -0.61353086]
E1 = -482.51988353683197  E_coul = 129.14041489427672
cycle= 1 E= -353.379468642555  delta_E= -54.2  |g|=    0  |ddm|=   18
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.01275e-13
diis-c [-1.0256535e-26  1.0000000e+00]
  mo_energy =
[-70.48694076 -11.51694901 -11.51694901 -11.51694901  -6.0349105
  -0.58213077  -0.15489928  -0.15489928  -0.15489928]
E1 = -482.5198835368307  E_coul = 129.14041489427643
cycle= 2 E= -353.379468642554  delta_E= 9.66e-13  |g|=    0  |ddm|= 2.26e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -482.5198835368307  E_coul = 129.14041489427643
  mo_energy =
[-70.48694076 -11.51694901 -11.51694901 -11.51694901  -6.0349105
  -0.58213077  -0.15489928  -0.15489928  -0.15489928]
E1 = -482.5198835368309  E_coul = 129.1404148942762
Extra cycle  E= -353.379468642555  delta_E= -3.98e-13  |g|=    0  |ddm|= 2.85e-14
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [1.76788976e+01 1.17487684e+01 6.76230004e-03 9.51206076e+00
 3.98176731e-03]
E = -353.3794686425547
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:32 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  17.6041372852        1
[INPUT] 0    0    [1    /1   ]  11.7090875322        1
[INPUT] 0    0    [1    /1   ]  0.00339081611254      1
[INPUT] 1    0    [1    /1   ]  9.53081377122        1
[INPUT] 1    0    [1    /1   ]  0.00398176493291      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [17.604137285203112, 1.0]], [0, [11.70908753221738, 1.0]], [0, [0.0033908161125429464, 1.0]], [1, [9.53081377121982, 1.0]], [1, [0.003981764932914513, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [17.60413729]
bas 1, expnt(s) = [11.70908753]
bas 2, expnt(s) = [0.00339082]
bas 3, expnt(s) = [9.53081377]
bas 4, expnt(s) = [0.00398176]
CPU time:        27.46
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.76041373e+01 2.17133126e+01 1.17090875e+01 1.59921669e+01
 3.39081611e-03 3.55012139e-02 9.53081377e+00 4.88536337e+01
 3.98176493e-03 2.91795718e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.688109266340781
cond(S) = 64.60340299434847
E1 = -387.43616377734185  E_coul = 88.5325284606163
init E= -298.903635316726
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-75.00603566 -15.63218212 -15.63218212 -15.63218212  -9.78723742
  -0.85733512  -0.6155272   -0.6155272   -0.6155272 ]
E1 = -481.001593502937  E_coul = 128.27214369134998
cycle= 1 E= -352.729449811587  delta_E= -53.8  |g|=    0  |ddm|= 18.2
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.07492e-14
diis-c [-1.6604985e-27  1.0000000e+00]
  mo_energy =
[-70.45687683 -11.59172603 -11.59172603 -11.59172603  -6.13345844
  -0.35758699  -0.16851758  -0.16851758  -0.16851758]
E1 = -481.00159350293467  E_coul = 128.27214369134995
cycle= 2 E= -352.729449811585  delta_E= 2.33e-12  |g|=    0  |ddm|= 9.08e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -481.00159350293467  E_coul = 128.27214369134995
  mo_energy =
[-70.45687683 -11.59172603 -11.59172603 -11.59172603  -6.13345844
  -0.35758699  -0.16851758  -0.16851758  -0.16851758]
E1 = -481.00159350293626  E_coul = 128.27214369135027
Extra cycle  E= -352.729449811586  delta_E= -1.31e-12  |g|=    0  |ddm|= 2.14e-14
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [1.76041373e+01 1.17090875e+01 3.39081611e-03 9.53081377e+00
 3.98176493e-03]
E = -352.729449811586
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:32 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  17.5666702537        1
[INPUT] 0    0    [1    /1   ]  11.6892009936        1
[INPUT] 0    0    [1    /1   ]  0.00170115640956      1
[INPUT] 1    0    [1    /1   ]  9.54021206671        1
[INPUT] 1    0    [1    /1   ]  0.00398176374055      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [17.566670253738685, 1.0]], [0, [11.689200993590507, 1.0]], [0, [0.0017011564095587347, 1.0]], [1, [9.540212066708303, 1.0]], [1, [0.003981763740550288, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [17.56667025]
bas 1, expnt(s) = [11.68920099]
bas 2, expnt(s) = [0.00170116]
bas 3, expnt(s) = [9.54021207]
bas 4, expnt(s) = [0.00398176]
CPU time:        27.63
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.75666703e+01 2.16786439e+01 1.16892010e+01 1.59717919e+01
 1.70115641e-03 2.11628039e-02 9.54021207e+00 4.89138591e+01
 3.98176374e-03 2.91795609e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.676001134491216
cond(S) = 64.7359319181129
E1 = -387.2833141358402  E_coul = 88.49888500189084
init E= -298.784429133949
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-74.95513293 -15.63655084 -15.63655084 -15.63655084  -9.80156536
  -0.61621631  -0.61621631  -0.61621631  -0.61004479]
E1 = -479.9531496082038  E_coul = 127.62294608959496
cycle= 1 E= -352.330203518609  delta_E= -53.5  |g|=    0  |ddm|= 18.2
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.60949e-13
diis-c [-2.59045865e-26  1.00000000e+00]
  mo_energy =
[-70.45761139 -11.64511554 -11.64511554 -11.64511554  -6.19943428
  -0.21060156  -0.18354495  -0.18354495  -0.18354495]
E1 = -479.9531496082029  E_coul = 127.62294608959456
cycle= 2 E= -352.330203518608  delta_E= 4.55e-13  |g|=    0  |ddm|= 7.27e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -479.9531496082029  E_coul = 127.62294608959456
  mo_energy =
[-70.45761139 -11.64511554 -11.64511554 -11.64511554  -6.19943428
  -0.21060156  -0.18354495  -0.18354495  -0.18354495]
E1 = -479.95314960820383  E_coul = 127.62294608959495
Extra cycle  E= -352.330203518609  delta_E= -5.12e-13  |g|=    0  |ddm|= 7.12e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [1.75666703e+01 1.16892010e+01 1.70115641e-03 9.54021207e+00
 3.98176374e-03]
E = -352.33020351860887
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:33 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  17.5666702537        1
[INPUT] 0    0    [1    /1   ]  11.6892009936        1
[INPUT] 0    0    [1    /1   ]  0.00170115640956      1
[INPUT] 1    0    [1    /1   ]  9.54021206671        1
[INPUT] 1    0    [1    /1   ]  0.00398176374055      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [17.566670253738685, 1.0]], [0, [11.689200993590507, 1.0]], [0, [0.0017011564095587347, 1.0]], [1, [9.540212066708303, 1.0]], [1, [0.003981763740550288, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [17.56667025]
bas 1, expnt(s) = [11.68920099]
bas 2, expnt(s) = [0.00170116]
bas 3, expnt(s) = [9.54021207]
bas 4, expnt(s) = [0.00398176]
CPU time:        27.81
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.75666703e+01 2.16786439e+01 1.16892010e+01 1.59717919e+01
 1.70115641e-03 2.11628039e-02 9.54021207e+00 4.89138591e+01
 3.98176374e-03 2.91795609e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.676001134491216
cond(S) = 64.7359319181129
E1 = -387.2833141358402  E_coul = 88.49888500189084
init E= -298.784429133949
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-74.95513293 -15.63655084 -15.63655084 -15.63655084  -9.80156536
  -0.61621631  -0.61621631  -0.61621631  -0.61004479]
E1 = -479.9531496082038  E_coul = 127.62294608959496
cycle= 1 E= -352.330203518609  delta_E= -53.5  |g|=    0  |ddm|= 18.2
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.60949e-13
diis-c [-2.59045865e-26  1.00000000e+00]
  mo_energy =
[-70.45761139 -11.64511554 -11.64511554 -11.64511554  -6.19943428
  -0.21060156  -0.18354495  -0.18354495  -0.18354495]
E1 = -479.9531496082029  E_coul = 127.62294608959456
cycle= 2 E= -352.330203518608  delta_E= 4.55e-13  |g|=    0  |ddm|= 7.27e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -479.9531496082029  E_coul = 127.62294608959456
  mo_energy =
[-70.45761139 -11.64511554 -11.64511554 -11.64511554  -6.19943428
  -0.21060156  -0.18354495  -0.18354495  -0.18354495]
E1 = -479.95314960820383  E_coul = 127.62294608959495
Extra cycle  E= -352.330203518609  delta_E= -5.12e-13  |g|=    0  |ddm|= 7.12e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 64.7359319181129
E1 = -479.95314960820383  E_coul = 127.62294608959495
init E= -352.330203518609
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-70.45761139 -11.64511554 -11.64511554 -11.64511554  -6.19943428
  -0.21060156  -0.18354495  -0.18354495  -0.18354495]
E1 = -479.95314960820235  E_coul = 127.62294608959438
cycle= 1 E= -352.330203518608  delta_E= 9.09e-13  |g|=    0  |ddm|= 1.01e-14
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -479.95314960820235  E_coul = 127.62294608959438
  mo_energy =
[-70.45761139 -11.64511554 -11.64511554 -11.64511554  -6.19943428
  -0.21060156  -0.18354495  -0.18354495  -0.18354495]
E1 = -479.95314960820235  E_coul = 127.62294608959442
Extra cycle  E= -352.330203518608  delta_E=    0  |g|=    0  |ddm|= 1.62e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [1.75666703e+01 1.16892010e+01 1.70115641e-03 9.54021207e+00
 3.98176374e-03]
grad_E = [  -1.92271426   -0.28805078 -213.1159896     0.59013271 -260.29421671]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:35 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  51.3330872314        1
[INPUT] 0    0    [1    /1   ]  29.0766878831        1
[INPUT] 0    0    [1    /1   ]  0.00170257929685      1
[INPUT] 1    0    [1    /1   ]  1.00001074088e-09      1
[INPUT] 1    0    [1    /1   ]  0.00398289793576      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [51.33308723140281, 1.0]], [0, [29.076687883120925, 1.0]], [0, [0.0017025792968451772, 1.0]], [1, [1.0000107408814074e-09, 1.0]], [1, [0.003982897935761071, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [51.33308723]
bas 1, expnt(s) = [29.07668788]
bas 2, expnt(s) = [0.00170258]
bas 3, expnt(s) = [1.00001074e-09]
bas 4, expnt(s) = [0.0039829]
CPU time:        30.57
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 5.13330872e+01 4.84521510e+01 2.90766879e+01 3.16354288e+01
 1.70257930e-03 2.11760784e-02 1.00001074e-09 1.64055284e-11
 3.98289794e-03 2.91899509e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 2.7403483291076096
cond(S) = 33.46694393637599
E1 = -244.02532068279996  E_coul = 16.312522176762535
init E= -227.712798506037
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-1.16885295e+02 -1.01482379e+00 -1.01482379e+00 -1.01482379e+00
 -1.00732307e+00 -6.05552557e-04 -6.05552557e-04 -6.05552557e-04
  1.00875673e+00]
E1 = -287.87290681907416  E_coul = 35.92222322879011
cycle= 1 E= -251.950683590284  delta_E= -24.2  |g|=    0  |ddm|=   18
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.0102e-13
diis-c [-4.04089722e-26  1.00000000e+00]
  mo_energy =
[-1.10352339e+02 -6.08918363e-01 -5.86398515e-01 -5.86398515e-01
 -5.86398515e-01 -6.05552557e-04 -6.05552557e-04 -6.05552557e-04
  4.70803979e+00]
E1 = -287.8729068190737  E_coul = 35.92222322879021
cycle= 2 E= -251.950683590283  delta_E= 5.68e-13  |g|=    0  |ddm|= 4.81e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -287.8729068190737  E_coul = 35.92222322879021
  mo_energy =
[-1.10352339e+02 -6.08918363e-01 -5.86398515e-01 -5.86398515e-01
 -5.86398515e-01 -6.05552557e-04 -6.05552557e-04 -6.05552557e-04
  4.70803979e+00]
E1 = -287.87290681907365  E_coul = 35.922223228790116
Extra cycle  E= -251.950683590284  delta_E= -2.84e-14  |g|=    0  |ddm|= 7.25e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [5.13330872e+01 2.90766879e+01 1.70257930e-03 1.00001074e-09
 3.98289794e-03]
E = -251.95068359028352
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:36 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  24.8175528964        1
[INPUT] 0    0    [1    /1   ]  15.4229293004        1
[INPUT] 0    0    [1    /1   ]  0.00170146195541      1
[INPUT] 1    0    [1    /1   ]  7.49158019319        1
[INPUT] 1    0    [1    /1   ]  0.00398200729368      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [24.817552896444415, 1.0]], [0, [15.422929300356536, 1.0]], [0, [0.0017014619554132037, 1.0]], [1, [7.4915801931892965, 1.0]], [1, [0.003982007293675061, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [24.8175529]
bas 1, expnt(s) = [15.4229293]
bas 2, expnt(s) = [0.00170146]
bas 3, expnt(s) = [7.49158019]
bas 4, expnt(s) = [0.00398201]
CPU time:        30.77
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 2.48175529e+01 2.80921023e+01 1.54229293e+01 1.96625652e+01
 1.70146196e-03 2.11656547e-02 7.49158019e+00 3.61577322e+01
 3.98200729e-03 2.91817919e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.703921623661756
cond(S) = 47.587677817270354
E1 = -401.63426317131615  E_coul = 86.90972810565097
init E= -314.724535065665
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-84.38764596 -15.45184445 -15.45184445 -15.45184445  -6.86065264
  -0.61435904  -0.61435904  -0.61435904  -0.60798793]
E1 = -486.97133392787737  E_coul = 124.25891612174286
cycle= 1 E= -362.712417806135  delta_E=  -48  |g|=    0  |ddm|= 12.2
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.15355e-15
diis-c [-9.94485412e-30  1.00000000e+00]
  mo_energy =
[-79.70075496 -11.86183954 -11.86183954 -11.86183954  -3.18036653
  -0.20947387  -0.18354562  -0.18354562  -0.18354562]
E1 = -486.9713339278777  E_coul = 124.25891612174271
cycle= 2 E= -362.712417806135  delta_E= -5.12e-13  |g|=    0  |ddm|= 5.71e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -486.9713339278777  E_coul = 124.25891612174271
  mo_energy =
[-79.70075496 -11.86183954 -11.86183954 -11.86183954  -3.18036653
  -0.20947387  -0.18354562  -0.18354562  -0.18354562]
E1 = -486.97133392787725  E_coul = 124.25891612174279
Extra cycle  E= -362.712417806134  delta_E= 5.68e-13  |g|=    0  |ddm|= 3.95e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [2.48175529e+01 1.54229293e+01 1.70146196e-03 7.49158019e+00
 3.98200729e-03]
E = -362.71241780613445
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:36 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  24.8175528964        1
[INPUT] 0    0    [1    /1   ]  15.4229293004        1
[INPUT] 0    0    [1    /1   ]  0.00170146195541      1
[INPUT] 1    0    [1    /1   ]  7.49158019319        1
[INPUT] 1    0    [1    /1   ]  0.00398200729368      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [24.817552896444415, 1.0]], [0, [15.422929300356536, 1.0]], [0, [0.0017014619554132037, 1.0]], [1, [7.4915801931892965, 1.0]], [1, [0.003982007293675061, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [24.8175529]
bas 1, expnt(s) = [15.4229293]
bas 2, expnt(s) = [0.00170146]
bas 3, expnt(s) = [7.49158019]
bas 4, expnt(s) = [0.00398201]
CPU time:        30.96
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 2.48175529e+01 2.80921023e+01 1.54229293e+01 1.96625652e+01
 1.70146196e-03 2.11656547e-02 7.49158019e+00 3.61577322e+01
 3.98200729e-03 2.91817919e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.703921623661756
cond(S) = 47.587677817270354
E1 = -401.63426317131615  E_coul = 86.90972810565097
init E= -314.724535065665
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-84.38764596 -15.45184445 -15.45184445 -15.45184445  -6.86065264
  -0.61435904  -0.61435904  -0.61435904  -0.60798793]
E1 = -486.97133392787737  E_coul = 124.25891612174286
cycle= 1 E= -362.712417806135  delta_E=  -48  |g|=    0  |ddm|= 12.2
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.15355e-15
diis-c [-9.94485412e-30  1.00000000e+00]
  mo_energy =
[-79.70075496 -11.86183954 -11.86183954 -11.86183954  -3.18036653
  -0.20947387  -0.18354562  -0.18354562  -0.18354562]
E1 = -486.9713339278777  E_coul = 124.25891612174271
cycle= 2 E= -362.712417806135  delta_E= -5.12e-13  |g|=    0  |ddm|= 5.71e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -486.9713339278777  E_coul = 124.25891612174271
  mo_energy =
[-79.70075496 -11.86183954 -11.86183954 -11.86183954  -3.18036653
  -0.20947387  -0.18354562  -0.18354562  -0.18354562]
E1 = -486.97133392787725  E_coul = 124.25891612174279
Extra cycle  E= -362.712417806134  delta_E= 5.68e-13  |g|=    0  |ddm|= 3.95e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 47.587677817270354
E1 = -486.97133392787725  E_coul = 124.25891612174279
init E= -362.712417806134
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-79.70075496 -11.86183954 -11.86183954 -11.86183954  -3.18036653
  -0.20947387  -0.18354562  -0.18354562  -0.18354562]
E1 = -486.97133392787725  E_coul = 124.25891612174266
cycle= 1 E= -362.712417806135  delta_E= -1.14e-13  |g|=    0  |ddm|= 9.86e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -486.97133392787725  E_coul = 124.25891612174266
  mo_energy =
[-79.70075496 -11.86183954 -11.86183954 -11.86183954  -3.18036653
  -0.20947387  -0.18354562  -0.18354562  -0.18354562]
E1 = -486.97133392787714  E_coul = 124.25891612174296
Extra cycle  E= -362.712417806134  delta_E= 3.98e-13  |g|=    0  |ddm|= 7.12e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [2.48175529e+01 1.54229293e+01 1.70146196e-03 7.49158019e+00
 3.98200729e-03]
grad_E = [  -1.24199413    0.6803031  -213.42441827   -0.73862965 -260.27660011]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:39 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  30.0219828332        1
[INPUT] 0    0    [1    /1   ]  16.3758507358        1
[INPUT] 0    0    [1    /1   ]  0.00170643936193      1
[INPUT] 1    0    [1    /1   ]  7.12514056798        1
[INPUT] 1    0    [1    /1   ]  0.00398231779079      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [30.02198283316274, 1.0]], [0, [16.375850735767497, 1.0]], [0, [0.0017064393619342884, 1.0]], [1, [7.125140567982603, 1.0]], [1, [0.003982317790792501, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [30.02198283]
bas 1, expnt(s) = [16.37585074]
bas 2, expnt(s) = [0.00170644]
bas 3, expnt(s) = [7.12514057]
bas 4, expnt(s) = [0.00398232]
CPU time:        33.71
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 3.00219828e+01 3.24036963e+01 1.63758507e+01 2.05668570e+01
 1.70643936e-03 2.12120758e-02 7.12514057e+00 3.39606652e+01
 3.98231779e-03 2.91846363e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.670700222457643
cond(S) = 29.48630571590275
E1 = -410.44784441063257  E_coul = 86.81136727561343
init E= -323.636477135019
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-88.72837314 -15.38054906 -15.38054906 -15.38054906  -5.21460554
  -0.61661278  -0.61661278  -0.61661278  -0.61063416]
E1 = -492.2474963439821  E_coul = 124.75094406490874
cycle= 1 E= -367.496552279073  delta_E= -43.9  |g|=    0  |ddm|= 8.62
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.01009e-13
diis-c [-4.0404486e-26  1.0000000e+00]
  mo_energy =
[-83.78207534 -11.79324543 -11.79324543 -11.79324543  -1.45400231
  -0.2065237   -0.18348882  -0.18348882  -0.18348882]
E1 = -492.24749634398216  E_coul = 124.7509440649088
cycle= 2 E= -367.496552279073  delta_E=    0  |g|=    0  |ddm|= 1.36e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -492.24749634398216  E_coul = 124.7509440649088
  mo_energy =
[-83.78207534 -11.79324543 -11.79324543 -11.79324543  -1.45400231
  -0.2065237   -0.18348882  -0.18348882  -0.18348882]
E1 = -492.24749634398233  E_coul = 124.7509440649089
Extra cycle  E= -367.496552279073  delta_E= -5.68e-14  |g|=    0  |ddm|= 5.95e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [3.00219828e+01 1.63758507e+01 1.70643936e-03 7.12514057e+00
 3.98231779e-03]
E = -367.49655227907346
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:39 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  30.0219828332        1
[INPUT] 0    0    [1    /1   ]  16.3758507358        1
[INPUT] 0    0    [1    /1   ]  0.00170643936193      1
[INPUT] 1    0    [1    /1   ]  7.12514056798        1
[INPUT] 1    0    [1    /1   ]  0.00398231779079      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [30.02198283316274, 1.0]], [0, [16.375850735767497, 1.0]], [0, [0.0017064393619342884, 1.0]], [1, [7.125140567982603, 1.0]], [1, [0.003982317790792501, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [30.02198283]
bas 1, expnt(s) = [16.37585074]
bas 2, expnt(s) = [0.00170644]
bas 3, expnt(s) = [7.12514057]
bas 4, expnt(s) = [0.00398232]
CPU time:        33.93
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 3.00219828e+01 3.24036963e+01 1.63758507e+01 2.05668570e+01
 1.70643936e-03 2.12120758e-02 7.12514057e+00 3.39606652e+01
 3.98231779e-03 2.91846363e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.670700222457643
cond(S) = 29.48630571590275
E1 = -410.44784441063257  E_coul = 86.81136727561343
init E= -323.636477135019
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-88.72837314 -15.38054906 -15.38054906 -15.38054906  -5.21460554
  -0.61661278  -0.61661278  -0.61661278  -0.61063416]
E1 = -492.2474963439821  E_coul = 124.75094406490874
cycle= 1 E= -367.496552279073  delta_E= -43.9  |g|=    0  |ddm|= 8.62
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.01009e-13
diis-c [-4.0404486e-26  1.0000000e+00]
  mo_energy =
[-83.78207534 -11.79324543 -11.79324543 -11.79324543  -1.45400231
  -0.2065237   -0.18348882  -0.18348882  -0.18348882]
E1 = -492.24749634398216  E_coul = 124.7509440649088
cycle= 2 E= -367.496552279073  delta_E=    0  |g|=    0  |ddm|= 1.36e-14
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -492.24749634398216  E_coul = 124.7509440649088
  mo_energy =
[-83.78207534 -11.79324543 -11.79324543 -11.79324543  -1.45400231
  -0.2065237   -0.18348882  -0.18348882  -0.18348882]
E1 = -492.24749634398233  E_coul = 124.7509440649089
Extra cycle  E= -367.496552279073  delta_E= -5.68e-14  |g|=    0  |ddm|= 5.95e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 29.48630571590275
E1 = -492.24749634398233  E_coul = 124.7509440649089
init E= -367.496552279073
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-83.78207534 -11.79324543 -11.79324543 -11.79324543  -1.45400231
  -0.2065237   -0.18348882  -0.18348882  -0.18348882]
E1 = -492.24749634398245  E_coul = 124.7509440649089
cycle= 1 E= -367.496552279074  delta_E= -1.14e-13  |g|=    0  |ddm|= 1.14e-14
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -492.24749634398245  E_coul = 124.7509440649089
  mo_energy =
[-83.78207534 -11.79324543 -11.79324543 -11.79324543  -1.45400231
  -0.2065237   -0.18348882  -0.18348882  -0.18348882]
E1 = -492.24749634398245  E_coul = 124.7509440649089
Extra cycle  E= -367.496552279074  delta_E=    0  |g|=    0  |ddm|= 2.01e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [3.00219828e+01 1.63758507e+01 1.70643936e-03 7.12514057e+00
 3.98231779e-03]
grad_E = [  -1.08560114    1.31802215 -213.32909938   -0.96178324 -260.21224802]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:41 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  54.3916745995        1
[INPUT] 0    0    [1    /1   ]  16.6969012814        1
[INPUT] 0    0    [1    /1   ]  0.00173787537808      1
[INPUT] 1    0    [1    /1   ]  7.00558759643        1
[INPUT] 1    0    [1    /1   ]  0.00398398863663      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [54.39167459953265, 1.0]], [0, [16.696901281444102, 1.0]], [0, [0.0017378753780759727, 1.0]], [1, [7.005587596430522, 1.0]], [1, [0.003983988636633372, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [54.3916746]
bas 1, expnt(s) = [16.69690128]
bas 2, expnt(s) = [0.00173788]
bas 3, expnt(s) = [7.0055876]
bas 4, expnt(s) = [0.00398399]
CPU time:        36.68
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 5.43916746e+01 5.06016114e+01 1.66969013e+01 2.08685336e+01
 1.73787538e-03 2.15044826e-02 7.00558760e+00 3.32498815e+01
 3.98398864e-03 2.91999432e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.672205400905092
cond(S) = 8.11909859644668
E1 = -453.32208196679863  E_coul = 91.50892820412504
init E= -361.813153762674
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-101.93537522  -15.08323102  -15.08323102  -15.08323102   -0.95122608
   -0.61664129   -0.61664129   -0.61664129   -0.5931218 ]
E1 = -518.7170406801805  E_coul = 130.32604145054646
cycle= 1 E= -388.390999229634  delta_E= -26.6  |g|=    0  |ddm|= 4.95
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.2217e-13
diis-c [-1.49255226e-26  1.00000000e+00]
  mo_energy =
[-96.43178089 -11.53045004 -11.53045004 -11.53045004  -0.21819659
  -0.18312963  -0.18312963  -0.18312963   2.7582376 ]
E1 = -518.7170406801804  E_coul = 130.32604145054643
cycle= 2 E= -388.390999229634  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.88e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -518.7170406801804  E_coul = 130.32604145054643
  mo_energy =
[-96.43178089 -11.53045004 -11.53045004 -11.53045004  -0.21819659
  -0.18312963  -0.18312963  -0.18312963   2.7582376 ]
E1 = -518.7170406801805  E_coul = 130.3260414505465
Extra cycle  E= -388.390999229634  delta_E=    0  |g|=    0  |ddm|= 2.98e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [5.43916746e+01 1.66969013e+01 1.73787538e-03 7.00558760e+00
 3.98398864e-03]
E = -388.39099922963396
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:42 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  54.3916745995        1
[INPUT] 0    0    [1    /1   ]  16.6969012814        1
[INPUT] 0    0    [1    /1   ]  0.00173787537808      1
[INPUT] 1    0    [1    /1   ]  7.00558759643        1
[INPUT] 1    0    [1    /1   ]  0.00398398863663      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [54.39167459953265, 1.0]], [0, [16.696901281444102, 1.0]], [0, [0.0017378753780759727, 1.0]], [1, [7.005587596430522, 1.0]], [1, [0.003983988636633372, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [54.3916746]
bas 1, expnt(s) = [16.69690128]
bas 2, expnt(s) = [0.00173788]
bas 3, expnt(s) = [7.0055876]
bas 4, expnt(s) = [0.00398399]
CPU time:        36.91
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 5.43916746e+01 5.06016114e+01 1.66969013e+01 2.08685336e+01
 1.73787538e-03 2.15044826e-02 7.00558760e+00 3.32498815e+01
 3.98398864e-03 2.91999432e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.672205400905092
cond(S) = 8.11909859644668
E1 = -453.32208196679863  E_coul = 91.50892820412504
init E= -361.813153762674
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-101.93537522  -15.08323102  -15.08323102  -15.08323102   -0.95122608
   -0.61664129   -0.61664129   -0.61664129   -0.5931218 ]
E1 = -518.7170406801805  E_coul = 130.32604145054646
cycle= 1 E= -388.390999229634  delta_E= -26.6  |g|=    0  |ddm|= 4.95
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.2217e-13
diis-c [-1.49255226e-26  1.00000000e+00]
  mo_energy =
[-96.43178089 -11.53045004 -11.53045004 -11.53045004  -0.21819659
  -0.18312963  -0.18312963  -0.18312963   2.7582376 ]
E1 = -518.7170406801804  E_coul = 130.32604145054643
cycle= 2 E= -388.390999229634  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.88e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -518.7170406801804  E_coul = 130.32604145054643
  mo_energy =
[-96.43178089 -11.53045004 -11.53045004 -11.53045004  -0.21819659
  -0.18312963  -0.18312963  -0.18312963   2.7582376 ]
E1 = -518.7170406801805  E_coul = 130.3260414505465
Extra cycle  E= -388.390999229634  delta_E=    0  |g|=    0  |ddm|= 2.98e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 8.11909859644668
E1 = -518.7170406801805  E_coul = 130.3260414505465
init E= -388.390999229634
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-96.43178089 -11.53045004 -11.53045004 -11.53045004  -0.21819659
  -0.18312963  -0.18312963  -0.18312963   2.7582376 ]
E1 = -518.7170406801805  E_coul = 130.3260414505465
cycle= 1 E= -388.390999229634  delta_E=    0  |g|=    0  |ddm|= 2.86e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -518.7170406801805  E_coul = 130.3260414505465
  mo_energy =
[-96.43178089 -11.53045004 -11.53045004 -11.53045004  -0.21819659
  -0.18312963  -0.18312963  -0.18312963   2.7582376 ]
E1 = -518.7170406801805  E_coul = 130.32604145054646
Extra cycle  E= -388.390999229634  delta_E= -1.14e-13  |g|=    0  |ddm|= 2.35e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [5.43916746e+01 1.66969013e+01 1.73787538e-03 7.00558760e+00
 3.98398864e-03]
grad_E = [  -0.67100512    3.30443416 -212.25039892   -0.7812655  -259.82925627]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:45 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  116.035933721        1
[INPUT] 0    0    [1    /1   ]  11.404253811         1
[INPUT] 0    0    [1    /1   ]  0.00182781151106      1
[INPUT] 1    0    [1    /1   ]  7.89645125569        1
[INPUT] 1    0    [1    /1   ]  0.00398848873336      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [116.03593372059808, 1.0]], [0, [11.404253811014481, 1.0]], [0, [0.001827811511060915, 1.0]], [1, [7.896451255690699, 1.0]], [1, [0.003988488733357369, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [116.03593372]
bas 1, expnt(s) = [11.40425381]
bas 2, expnt(s) = [0.00182781]
bas 3, expnt(s) = [7.89645126]
bas 4, expnt(s) = [0.00398849]
CPU time:        39.77
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.16035934e+02 8.93221977e+01 1.14042538e+01 1.56788852e+01
 1.82781151e-03 2.23338492e-02 7.89645126e+00 3.86166273e+01
 3.98848873e-03 2.92411773e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.989324465799498
cond(S) = 2.5172049337638307
E1 = -515.1912887858487  E_coul = 106.31358884235767
init E= -408.877699943491
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-111.09595875  -14.1776048   -14.1776048   -14.1776048    -3.73541077
   -0.60923502   -0.59568673   -0.59568673   -0.59568673]
E1 = -561.8079370622775  E_coul = 139.12280507181666
cycle= 1 E= -422.685131990461  delta_E= -13.8  |g|=    0  |ddm|= 4.13
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.77988e-15
diis-c [-3.16798353e-30  1.00000000e+00]
  mo_energy =
[-106.33604102  -11.27823319  -11.27823319  -11.27823319   -0.85251453
   -0.21149863   -0.18213657   -0.18213657   -0.18213657]
E1 = -561.8079370622775  E_coul = 139.12280507181666
cycle= 2 E= -422.685131990461  delta_E=    0  |g|=    0  |ddm|= 2.34e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -561.8079370622775  E_coul = 139.12280507181666
  mo_energy =
[-106.33604102  -11.27823319  -11.27823319  -11.27823319   -0.85251453
   -0.21149863   -0.18213657   -0.18213657   -0.18213657]
E1 = -561.8079370622776  E_coul = 139.12280507181669
Extra cycle  E= -422.685131990461  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.58e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [1.16035934e+02 1.14042538e+01 1.82781151e-03 7.89645126e+00
 3.98848873e-03]
E = -422.6851319904609
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:45 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  116.035933721        1
[INPUT] 0    0    [1    /1   ]  11.404253811         1
[INPUT] 0    0    [1    /1   ]  0.00182781151106      1
[INPUT] 1    0    [1    /1   ]  7.89645125569        1
[INPUT] 1    0    [1    /1   ]  0.00398848873336      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [116.03593372059808, 1.0]], [0, [11.404253811014481, 1.0]], [0, [0.001827811511060915, 1.0]], [1, [7.896451255690699, 1.0]], [1, [0.003988488733357369, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [116.03593372]
bas 1, expnt(s) = [11.40425381]
bas 2, expnt(s) = [0.00182781]
bas 3, expnt(s) = [7.89645126]
bas 4, expnt(s) = [0.00398849]
CPU time:        40.02
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.16035934e+02 8.93221977e+01 1.14042538e+01 1.56788852e+01
 1.82781151e-03 2.23338492e-02 7.89645126e+00 3.86166273e+01
 3.98848873e-03 2.92411773e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 8.989324465799498
cond(S) = 2.5172049337638307
E1 = -515.1912887858487  E_coul = 106.31358884235767
init E= -408.877699943491
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-111.09595875  -14.1776048   -14.1776048   -14.1776048    -3.73541077
   -0.60923502   -0.59568673   -0.59568673   -0.59568673]
E1 = -561.8079370622775  E_coul = 139.12280507181666
cycle= 1 E= -422.685131990461  delta_E= -13.8  |g|=    0  |ddm|= 4.13
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.77988e-15
diis-c [-3.16798353e-30  1.00000000e+00]
  mo_energy =
[-106.33604102  -11.27823319  -11.27823319  -11.27823319   -0.85251453
   -0.21149863   -0.18213657   -0.18213657   -0.18213657]
E1 = -561.8079370622775  E_coul = 139.12280507181666
cycle= 2 E= -422.685131990461  delta_E=    0  |g|=    0  |ddm|= 2.34e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -561.8079370622775  E_coul = 139.12280507181666
  mo_energy =
[-106.33604102  -11.27823319  -11.27823319  -11.27823319   -0.85251453
   -0.21149863   -0.18213657   -0.18213657   -0.18213657]
E1 = -561.8079370622776  E_coul = 139.12280507181669
Extra cycle  E= -422.685131990461  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.58e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.5172049337638307
E1 = -561.8079370622776  E_coul = 139.12280507181669
init E= -422.685131990461
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-106.33604102  -11.27823319  -11.27823319  -11.27823319   -0.85251453
   -0.21149863   -0.18213657   -0.18213657   -0.18213657]
E1 = -561.8079370622776  E_coul = 139.12280507181666
cycle= 1 E= -422.685131990461  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.63e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -561.8079370622776  E_coul = 139.12280507181666
  mo_energy =
[-106.33604102  -11.27823319  -11.27823319  -11.27823319   -0.85251453
   -0.21149863   -0.18213657   -0.18213657   -0.18213657]
E1 = -561.8079370622775  E_coul = 139.12280507181663
Extra cycle  E= -422.685131990461  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.06e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [1.16035934e+02 1.14042538e+01 1.82781151e-03 7.89645126e+00
 3.98848873e-03]
grad_E = [ 2.18989977e-01  3.83637734e+00 -2.08666304e+02  9.90976975e-02
 -2.58784034e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:48 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  125.416455047        1
[INPUT] 0    0    [1    /1   ]  7.30773632438        1
[INPUT] 0    0    [1    /1   ]  0.00184975570511      1
[INPUT] 1    0    [1    /1   ]  8.5407120232         1
[INPUT] 1    0    [1    /1   ]  0.00398941765672      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [125.41645504724806, 1.0]], [0, [7.307736324380976, 1.0]], [0, [0.0018497557051089144, 1.0]], [1, [8.540712023200477, 1.0]], [1, [0.0039894176567171315, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [125.41645505]
bas 1, expnt(s) = [7.30773632]
bas 2, expnt(s) = [0.00184976]
bas 3, expnt(s) = [8.54071202]
bas 4, expnt(s) = [0.00398942]
CPU time:        42.84
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.25416455e+02 9.46849415e+01 7.30773632e+00 1.12292868e+01
 1.84975571e-03 2.25346494e-02 8.54071202e+00 4.25943496e+01
 3.98941766e-03 2.92496905e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.317565740215628
cond(S) = 1.8908889906688555
E1 = -528.6528889565129  E_coul = 113.46281932736618
init E= -415.190069629147
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.05393492  -13.50072846  -13.50072846  -13.50072846  -11.82962702
   -0.59215315   -0.57370118   -0.57370118   -0.57370118]
E1 = -570.3228078613722  E_coul = 137.79720287304505
cycle= 1 E= -432.525604988327  delta_E= -17.3  |g|=    0  |ddm|= 4.02
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.79243e-15
diis-c [-6.07219249e-29  1.00000000e+00]
  mo_energy =
[-102.80675963  -11.38269337  -11.38269337  -11.38269337   -9.63821638
   -0.22544741   -0.18189918   -0.18189918   -0.18189918]
E1 = -570.3228078613724  E_coul = 137.7972028730451
cycle= 2 E= -432.525604988327  delta_E= -2.27e-13  |g|=    0  |ddm|= 2.5e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -570.3228078613724  E_coul = 137.7972028730451
  mo_energy =
[-102.80675963  -11.38269337  -11.38269337  -11.38269337   -9.63821638
   -0.22544741   -0.18189918   -0.18189918   -0.18189918]
E1 = -570.3228078613724  E_coul = 137.7972028730452
Extra cycle  E= -432.525604988327  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.83e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [1.25416455e+02 7.30773632e+00 1.84975571e-03 8.54071202e+00
 3.98941766e-03]
E = -432.52560498832725
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:48 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  125.416455047        1
[INPUT] 0    0    [1    /1   ]  7.30773632438        1
[INPUT] 0    0    [1    /1   ]  0.00184975570511      1
[INPUT] 1    0    [1    /1   ]  8.5407120232         1
[INPUT] 1    0    [1    /1   ]  0.00398941765672      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [125.41645504724806, 1.0]], [0, [7.307736324380976, 1.0]], [0, [0.0018497557051089144, 1.0]], [1, [8.540712023200477, 1.0]], [1, [0.0039894176567171315, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [125.41645505]
bas 1, expnt(s) = [7.30773632]
bas 2, expnt(s) = [0.00184976]
bas 3, expnt(s) = [8.54071202]
bas 4, expnt(s) = [0.00398942]
CPU time:        43.10
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.25416455e+02 9.46849415e+01 7.30773632e+00 1.12292868e+01
 1.84975571e-03 2.25346494e-02 8.54071202e+00 4.25943496e+01
 3.98941766e-03 2.92496905e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.317565740215628
cond(S) = 1.8908889906688555
E1 = -528.6528889565129  E_coul = 113.46281932736618
init E= -415.190069629147
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.05393492  -13.50072846  -13.50072846  -13.50072846  -11.82962702
   -0.59215315   -0.57370118   -0.57370118   -0.57370118]
E1 = -570.3228078613722  E_coul = 137.79720287304505
cycle= 1 E= -432.525604988327  delta_E= -17.3  |g|=    0  |ddm|= 4.02
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.79243e-15
diis-c [-6.07219249e-29  1.00000000e+00]
  mo_energy =
[-102.80675963  -11.38269337  -11.38269337  -11.38269337   -9.63821638
   -0.22544741   -0.18189918   -0.18189918   -0.18189918]
E1 = -570.3228078613724  E_coul = 137.7972028730451
cycle= 2 E= -432.525604988327  delta_E= -2.27e-13  |g|=    0  |ddm|= 2.5e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -570.3228078613724  E_coul = 137.7972028730451
  mo_energy =
[-102.80675963  -11.38269337  -11.38269337  -11.38269337   -9.63821638
   -0.22544741   -0.18189918   -0.18189918   -0.18189918]
E1 = -570.3228078613724  E_coul = 137.7972028730452
Extra cycle  E= -432.525604988327  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.83e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.8908889906688555
E1 = -570.3228078613724  E_coul = 137.7972028730452
init E= -432.525604988327
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-102.80675963  -11.38269337  -11.38269337  -11.38269337   -9.63821638
   -0.22544741   -0.18189918   -0.18189918   -0.18189918]
E1 = -570.3228078613726  E_coul = 137.79720287304517
cycle= 1 E= -432.525604988327  delta_E= -1.14e-13  |g|=    0  |ddm|= 2.26e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -570.3228078613726  E_coul = 137.79720287304517
  mo_energy =
[-102.80675963  -11.38269337  -11.38269337  -11.38269337   -9.63821638
   -0.22544741   -0.18189918   -0.18189918   -0.18189918]
E1 = -570.3228078613727  E_coul = 137.79720287304522
Extra cycle  E= -432.525604988327  delta_E= -1.14e-13  |g|=    0  |ddm|= 4.48e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [1.25416455e+02 7.30773632e+00 1.84975571e-03 8.54071202e+00
 3.98941766e-03]
grad_E = [   0.36234283    2.11112356 -207.48777807    0.46760532 -258.54373938]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:51 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  112.355674277        1
[INPUT] 0    0    [1    /1   ]  3.44382129868        1
[INPUT] 0    0    [1    /1   ]  0.00184639236236      1
[INPUT] 1    0    [1    /1   ]  8.97189376155        1
[INPUT] 1    0    [1    /1   ]  0.00398895030501      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [112.35567427724033, 1.0]], [0, [3.4438212986817716, 1.0]], [0, [0.0018463923623577168, 1.0]], [1, [8.971893761553975, 1.0]], [1, [0.003988950305006367, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [112.35567428]
bas 1, expnt(s) = [3.4438213]
bas 2, expnt(s) = [0.00184639]
bas 3, expnt(s) = [8.97189376]
bas 4, expnt(s) = [0.00398895]
CPU time:        46.10
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.12355674e+02 8.71889168e+01 3.44382130e+00 6.38697888e+00
 1.84639236e-03 2.25039120e-02 8.97189376e+00 4.52990971e+01
 3.98895031e-03 2.92454073e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.490883613298811
cond(S) = 1.494591382205256
E1 = -530.2041311803497  E_coul = 110.58325824057106
init E= -419.620872939779
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.24304619  -17.47585586  -13.6354021   -13.6354021   -13.6354021
   -0.57939667   -0.5620163    -0.5620163    -0.5620163 ]
E1 = -568.3472974243142  E_coul = 129.95309909355188
cycle= 1 E= -438.394198330762  delta_E= -18.8  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.2402e-15
diis-c [-1.049892e-29  1.000000e+00]
  mo_energy =
[-101.84107061  -15.80507482  -11.93456125  -11.93456125  -11.93456125
   -0.22492982   -0.18193021   -0.18193021   -0.18193021]
E1 = -568.3472974243141  E_coul = 129.95309909355183
cycle= 2 E= -438.394198330762  delta_E= 5.68e-14  |g|=    0  |ddm|= 4.2e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -568.3472974243141  E_coul = 129.95309909355183
  mo_energy =
[-101.84107061  -15.80507482  -11.93456125  -11.93456125  -11.93456125
   -0.22492982   -0.18193021   -0.18193021   -0.18193021]
E1 = -568.347297424314  E_coul = 129.9530990935518
Extra cycle  E= -438.394198330762  delta_E= 1.14e-13  |g|=    0  |ddm|= 2.37e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [1.12355674e+02 3.44382130e+00 1.84639236e-03 8.97189376e+00
 3.98895031e-03]
E = -438.39419833076215
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:52 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  112.355674277        1
[INPUT] 0    0    [1    /1   ]  3.44382129868        1
[INPUT] 0    0    [1    /1   ]  0.00184639236236      1
[INPUT] 1    0    [1    /1   ]  8.97189376155        1
[INPUT] 1    0    [1    /1   ]  0.00398895030501      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [112.35567427724033, 1.0]], [0, [3.4438212986817716, 1.0]], [0, [0.0018463923623577168, 1.0]], [1, [8.971893761553975, 1.0]], [1, [0.003988950305006367, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [112.35567428]
bas 1, expnt(s) = [3.4438213]
bas 2, expnt(s) = [0.00184639]
bas 3, expnt(s) = [8.97189376]
bas 4, expnt(s) = [0.00398895]
CPU time:        46.41
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 1.12355674e+02 8.71889168e+01 3.44382130e+00 6.38697888e+00
 1.84639236e-03 2.25039120e-02 8.97189376e+00 4.52990971e+01
 3.98895031e-03 2.92454073e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.490883613298811
cond(S) = 1.494591382205256
E1 = -530.2041311803497  E_coul = 110.58325824057106
init E= -419.620872939779
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.24304619  -17.47585586  -13.6354021   -13.6354021   -13.6354021
   -0.57939667   -0.5620163    -0.5620163    -0.5620163 ]
E1 = -568.3472974243142  E_coul = 129.95309909355188
cycle= 1 E= -438.394198330762  delta_E= -18.8  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.2402e-15
diis-c [-1.049892e-29  1.000000e+00]
  mo_energy =
[-101.84107061  -15.80507482  -11.93456125  -11.93456125  -11.93456125
   -0.22492982   -0.18193021   -0.18193021   -0.18193021]
E1 = -568.3472974243141  E_coul = 129.95309909355183
cycle= 2 E= -438.394198330762  delta_E= 5.68e-14  |g|=    0  |ddm|= 4.2e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -568.3472974243141  E_coul = 129.95309909355183
  mo_energy =
[-101.84107061  -15.80507482  -11.93456125  -11.93456125  -11.93456125
   -0.22492982   -0.18193021   -0.18193021   -0.18193021]
E1 = -568.347297424314  E_coul = 129.9530990935518
Extra cycle  E= -438.394198330762  delta_E= 1.14e-13  |g|=    0  |ddm|= 2.37e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.494591382205256
E1 = -568.347297424314  E_coul = 129.9530990935518
init E= -438.394198330762
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.84107061  -15.80507482  -11.93456125  -11.93456125  -11.93456125
   -0.22492982   -0.18193021   -0.18193021   -0.18193021]
E1 = -568.3472974243141  E_coul = 129.9530990935518
cycle= 1 E= -438.394198330762  delta_E= -1.14e-13  |g|=    0  |ddm|= 3.39e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -568.3472974243141  E_coul = 129.9530990935518
  mo_energy =
[-101.84107061  -15.80507482  -11.93456125  -11.93456125  -11.93456125
   -0.22492982   -0.18193021   -0.18193021   -0.18193021]
E1 = -568.3472974243141  E_coul = 129.9530990935518
Extra cycle  E= -438.394198330762  delta_E=    0  |g|=    0  |ddm|= 2.59e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.12 sec
exp = [1.12355674e+02 3.44382130e+00 1.84639236e-03 8.97189376e+00
 3.98895031e-03]
grad_E = [   0.27663635   -1.84340973 -206.67059171    0.53227999 -258.59667339]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:55 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  92.8029007896        1
[INPUT] 0    0    [1    /1   ]  4.80817898844        1
[INPUT] 0    0    [1    /1   ]  0.00182361174388      1
[INPUT] 1    0    [1    /1   ]  8.65646742575        1
[INPUT] 1    0    [1    /1   ]  0.00398772618878      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [92.8029007896393, 1.0]], [0, [4.808178988440794, 1.0]], [0, [0.001823611743884921, 1.0]], [1, [8.65646742575146, 1.0]], [1, [0.00398772618878269, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [92.80290079]
bas 1, expnt(s) = [4.80817899]
bas 2, expnt(s) = [0.00182361]
bas 3, expnt(s) = [8.65646743]
bas 4, expnt(s) = [0.00398773]
CPU time:        49.53
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.28029008e+01 7.55416015e+01 4.80817899e+00 8.20352477e+00
 1.82361174e-03 2.22953508e-02 8.65646743e+00 4.33171890e+01
 3.98772619e-03 2.92341894e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.525343088334836
cond(S) = 1.796582328336995
E1 = -538.3592407764384  E_coul = 112.34262933681788
init E= -426.01661143962
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.39381949  -16.88478091  -13.37769238  -13.37769238  -13.37769238
   -0.57379164   -0.55961881   -0.55961881   -0.55961881]
E1 = -572.5142563745834  E_coul = 130.73781266476107
cycle= 1 E= -441.776443709822  delta_E= -15.8  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.13808e-14
diis-c [-4.57137057e-28  1.00000000e+00]
  mo_energy =
[-104.17438219  -15.22716199  -11.78275545  -11.78275545  -11.78275545
   -0.22299663   -0.18216946   -0.18216946   -0.18216946]
E1 = -572.5142563745832  E_coul = 130.73781266476098
cycle= 2 E= -441.776443709822  delta_E= 1.71e-13  |g|=    0  |ddm|= 2.42e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -572.5142563745832  E_coul = 130.73781266476098
  mo_energy =
[-104.17438219  -15.22716199  -11.78275545  -11.78275545  -11.78275545
   -0.22299663   -0.18216946   -0.18216946   -0.18216946]
E1 = -572.5142563745832  E_coul = 130.737812664761
Extra cycle  E= -441.776443709822  delta_E=    0  |g|=    0  |ddm|= 2.07e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
exp = [9.28029008e+01 4.80817899e+00 1.82361174e-03 8.65646743e+00
 3.98772619e-03]
E = -441.77644370982216
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:55 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  92.8029007896        1
[INPUT] 0    0    [1    /1   ]  4.80817898844        1
[INPUT] 0    0    [1    /1   ]  0.00182361174388      1
[INPUT] 1    0    [1    /1   ]  8.65646742575        1
[INPUT] 1    0    [1    /1   ]  0.00398772618878      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [92.8029007896393, 1.0]], [0, [4.808178988440794, 1.0]], [0, [0.001823611743884921, 1.0]], [1, [8.65646742575146, 1.0]], [1, [0.00398772618878269, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [92.80290079]
bas 1, expnt(s) = [4.80817899]
bas 2, expnt(s) = [0.00182361]
bas 3, expnt(s) = [8.65646743]
bas 4, expnt(s) = [0.00398773]
CPU time:        49.86
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.28029008e+01 7.55416015e+01 4.80817899e+00 8.20352477e+00
 1.82361174e-03 2.22953508e-02 8.65646743e+00 4.33171890e+01
 3.98772619e-03 2.92341894e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.525343088334836
cond(S) = 1.796582328336995
E1 = -538.3592407764384  E_coul = 112.34262933681788
init E= -426.01661143962
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.39381949  -16.88478091  -13.37769238  -13.37769238  -13.37769238
   -0.57379164   -0.55961881   -0.55961881   -0.55961881]
E1 = -572.5142563745834  E_coul = 130.73781266476107
cycle= 1 E= -441.776443709822  delta_E= -15.8  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.02 sec
diis-norm(errvec)=2.13808e-14
diis-c [-4.57137057e-28  1.00000000e+00]
  mo_energy =
[-104.17438219  -15.22716199  -11.78275545  -11.78275545  -11.78275545
   -0.22299663   -0.18216946   -0.18216946   -0.18216946]
E1 = -572.5142563745832  E_coul = 130.73781266476098
cycle= 2 E= -441.776443709822  delta_E= 1.71e-13  |g|=    0  |ddm|= 2.42e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -572.5142563745832  E_coul = 130.73781266476098
  mo_energy =
[-104.17438219  -15.22716199  -11.78275545  -11.78275545  -11.78275545
   -0.22299663   -0.18216946   -0.18216946   -0.18216946]
E1 = -572.5142563745832  E_coul = 130.737812664761
Extra cycle  E= -441.776443709822  delta_E=    0  |g|=    0  |ddm|= 2.07e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.796582328336995
E1 = -572.5142563745832  E_coul = 130.737812664761
init E= -441.776443709822
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.17438219  -15.22716199  -11.78275545  -11.78275545  -11.78275545
   -0.22299663   -0.18216946   -0.18216946   -0.18216946]
E1 = -572.5142563745833  E_coul = 130.73781266476104
cycle= 1 E= -441.776443709822  delta_E= -1.14e-13  |g|=    0  |ddm|= 1.01e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -572.5142563745833  E_coul = 130.73781266476104
  mo_energy =
[-104.17438219  -15.22716199  -11.78275545  -11.78275545  -11.78275545
   -0.22299663   -0.18216946   -0.18216946   -0.18216946]
E1 = -572.5142563745832  E_coul = 130.737812664761
Extra cycle  E= -441.776443709822  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.47e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.28029008e+01 4.80817899e+00 1.82361174e-03 8.65646743e+00
 3.98772619e-03]
grad_E = [-3.70641559e-02  5.50364583e-01 -2.07953598e+02  3.68366130e-01
 -2.58853988e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:59 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.5826682303        1
[INPUT] 0    0    [1    /1   ]  4.4603338892         1
[INPUT] 0    0    [1    /1   ]  0.00183027938798      1
[INPUT] 1    0    [1    /1   ]  8.494661465          1
[INPUT] 1    0    [1    /1   ]  0.00398800223854      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.58266823030263, 1.0]], [0, [4.460333889200389, 1.0]], [0, [0.0018302793879818886, 1.0]], [1, [8.494661464999183, 1.0]], [1, [0.003988002238536186, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.58266823]
bas 1, expnt(s) = [4.46033389]
bas 2, expnt(s) = [0.00183028]
bas 3, expnt(s) = [8.49466146]
bas 4, expnt(s) = [0.003988]
CPU time:        53.23
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.45826682e+01 7.66255660e+01 4.46033389e+00 7.75426345e+00
 1.83027939e-03 2.23564615e-02 8.49466146e+00 4.23074634e+01
 3.98800224e-03 2.92367190e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.533878296857289
cond(S) = 1.7293727516486375
E1 = -537.1883301692442  E_coul = 111.14500853908906
init E= -426.043321630155
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.4341113   -17.22986212  -13.47911314  -13.47911314  -13.47911314
   -0.57419839   -0.55906414   -0.55906414   -0.55906414]
E1 = -571.2149754539422  E_coul = 129.24401652369224
cycle= 1 E= -441.97095893025  delta_E= -15.9  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.00987e-14
diis-c [-4.03958485e-28  1.00000000e+00]
  mo_energy =
[-104.25258706  -15.60531514  -11.91189395  -11.91189395  -11.91189395
   -0.22359772   -0.18209648   -0.18209648   -0.18209648]
E1 = -571.2149754539421  E_coul = 129.24401652369224
cycle= 2 E= -441.97095893025  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.63e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -571.2149754539421  E_coul = 129.24401652369224
  mo_energy =
[-104.25258706  -15.60531514  -11.91189395  -11.91189395  -11.91189395
   -0.22359772   -0.18209648   -0.18209648   -0.18209648]
E1 = -571.214975453942  E_coul = 129.2440165236922
Extra cycle  E= -441.97095893025  delta_E= 5.68e-14  |g|=    0  |ddm|= 1.17e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [9.45826682e+01 4.46033389e+00 1.83027939e-03 8.49466146e+00
 3.98800224e-03]
E = -441.97095893024976
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:10:59 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.5826682303        1
[INPUT] 0    0    [1    /1   ]  4.4603338892         1
[INPUT] 0    0    [1    /1   ]  0.00183027938798      1
[INPUT] 1    0    [1    /1   ]  8.494661465          1
[INPUT] 1    0    [1    /1   ]  0.00398800223854      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.58266823030263, 1.0]], [0, [4.460333889200389, 1.0]], [0, [0.0018302793879818886, 1.0]], [1, [8.494661464999183, 1.0]], [1, [0.003988002238536186, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.58266823]
bas 1, expnt(s) = [4.46033389]
bas 2, expnt(s) = [0.00183028]
bas 3, expnt(s) = [8.49466146]
bas 4, expnt(s) = [0.003988]
CPU time:        53.59
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.45826682e+01 7.66255660e+01 4.46033389e+00 7.75426345e+00
 1.83027939e-03 2.23564615e-02 8.49466146e+00 4.23074634e+01
 3.98800224e-03 2.92367190e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.533878296857289
cond(S) = 1.7293727516486375
E1 = -537.1883301692442  E_coul = 111.14500853908906
init E= -426.043321630155
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  mo_energy =
[-106.4341113   -17.22986212  -13.47911314  -13.47911314  -13.47911314
   -0.57419839   -0.55906414   -0.55906414   -0.55906414]
E1 = -571.2149754539422  E_coul = 129.24401652369224
cycle= 1 E= -441.97095893025  delta_E= -15.9  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.02 sec
diis-norm(errvec)=2.00987e-14
diis-c [-4.03958485e-28  1.00000000e+00]
  mo_energy =
[-104.25258706  -15.60531514  -11.91189395  -11.91189395  -11.91189395
   -0.22359772   -0.18209648   -0.18209648   -0.18209648]
E1 = -571.2149754539421  E_coul = 129.24401652369224
cycle= 2 E= -441.97095893025  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.63e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -571.2149754539421  E_coul = 129.24401652369224
  mo_energy =
[-104.25258706  -15.60531514  -11.91189395  -11.91189395  -11.91189395
   -0.22359772   -0.18209648   -0.18209648   -0.18209648]
E1 = -571.214975453942  E_coul = 129.2440165236922
Extra cycle  E= -441.97095893025  delta_E= 5.68e-14  |g|=    0  |ddm|= 1.17e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.7293727516486375
E1 = -571.214975453942  E_coul = 129.2440165236922
init E= -441.97095893025
    CPU time for initialize scf      0.07 sec, wall time      0.08 sec
  mo_energy =
[-104.25258706  -15.60531514  -11.91189395  -11.91189395  -11.91189395
   -0.22359772   -0.18209648   -0.18209648   -0.18209648]
E1 = -571.214975453942  E_coul = 129.24401652369218
cycle= 1 E= -441.97095893025  delta_E= -5.68e-14  |g|=    0  |ddm|= 1.07e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -571.214975453942  E_coul = 129.24401652369218
  mo_energy =
[-104.25258706  -15.60531514  -11.91189395  -11.91189395  -11.91189395
   -0.22359772   -0.18209648   -0.18209648   -0.18209648]
E1 = -571.214975453942  E_coul = 129.24401652369215
Extra cycle  E= -441.97095893025  delta_E=    0  |g|=    0  |ddm|= 1.86e-15
    CPU time for scf_cycle      0.17 sec, wall time      0.18 sec
exp = [9.45826682e+01 4.46033389e+00 1.83027939e-03 8.49466146e+00
 3.98800224e-03]
grad_E = [-5.49287433e-04  8.48139394e-02 -2.07612210e+02  2.18816227e-01
 -2.58779751e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:02 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.6060885632        1
[INPUT] 0    0    [1    /1   ]  4.37063539884        1
[INPUT] 0    0    [1    /1   ]  0.00183614879581      1
[INPUT] 1    0    [1    /1   ]  8.32933332273        1
[INPUT] 1    0    [1    /1   ]  0.00398821561912      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.6060885631952, 1.0]], [0, [4.370635398836988, 1.0]], [0, [0.0018361487958097463, 1.0]], [1, [8.329333322729823, 1.0]], [1, [0.003988215619118489, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.60608856]
bas 1, expnt(s) = [4.3706354]
bas 2, expnt(s) = [0.00183615]
bas 3, expnt(s) = [8.32933332]
bas 4, expnt(s) = [0.00398822]
CPU time:        56.92
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.46060886e+01 7.66397959e+01 4.37063540e+00 7.63701174e+00
 1.83614880e-03 2.24102101e-02 8.32933332e+00 4.12807135e+01
 3.98821562e-03 2.92386745e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.535219338764819
cond(S) = 1.7155880980748694
E1 = -536.2130528097698  E_coul = 110.22672764706196
init E= -425.986325162708
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.57260304  -17.35887702  -13.54673086  -13.54673086  -13.54673086
   -0.57500506   -0.55898887   -0.55898887   -0.55898887]
E1 = -570.1981344090033  E_coul = 128.1996006645717
cycle= 1 E= -441.998533744432  delta_E=  -16  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.00973e-14
diis-c [-4.03902995e-28  1.00000000e+00]
  mo_energy =
[-104.40723655  -15.74568156  -11.99210061  -11.99210061  -11.99210061
   -0.22415219   -0.18203147   -0.18203147   -0.18203147]
E1 = -570.1981344090033  E_coul = 128.19960066457173
cycle= 2 E= -441.998533744432  delta_E= 5.68e-14  |g|=    0  |ddm|= 1.84e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -570.1981344090033  E_coul = 128.19960066457173
  mo_energy =
[-104.40723655  -15.74568156  -11.99210061  -11.99210061  -11.99210061
   -0.22415219   -0.18203147   -0.18203147   -0.18203147]
E1 = -570.1981344090034  E_coul = 128.1996006645717
Extra cycle  E= -441.998533744432  delta_E= -1.71e-13  |g|=    0  |ddm|= 2.24e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.46060886e+01 4.37063540e+00 1.83614880e-03 8.32933332e+00
 3.98821562e-03]
E = -441.9985337444317
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:03 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.6060885632        1
[INPUT] 0    0    [1    /1   ]  4.37063539884        1
[INPUT] 0    0    [1    /1   ]  0.00183614879581      1
[INPUT] 1    0    [1    /1   ]  8.32933332273        1
[INPUT] 1    0    [1    /1   ]  0.00398821561912      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.6060885631952, 1.0]], [0, [4.370635398836988, 1.0]], [0, [0.0018361487958097463, 1.0]], [1, [8.329333322729823, 1.0]], [1, [0.003988215619118489, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.60608856]
bas 1, expnt(s) = [4.3706354]
bas 2, expnt(s) = [0.00183615]
bas 3, expnt(s) = [8.32933332]
bas 4, expnt(s) = [0.00398822]
CPU time:        57.24
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.46060886e+01 7.66397959e+01 4.37063540e+00 7.63701174e+00
 1.83614880e-03 2.24102101e-02 8.32933332e+00 4.12807135e+01
 3.98821562e-03 2.92386745e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.535219338764819
cond(S) = 1.7155880980748694
E1 = -536.2130528097698  E_coul = 110.22672764706196
init E= -425.986325162708
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.57260304  -17.35887702  -13.54673086  -13.54673086  -13.54673086
   -0.57500506   -0.55898887   -0.55898887   -0.55898887]
E1 = -570.1981344090033  E_coul = 128.1996006645717
cycle= 1 E= -441.998533744432  delta_E=  -16  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.00973e-14
diis-c [-4.03902995e-28  1.00000000e+00]
  mo_energy =
[-104.40723655  -15.74568156  -11.99210061  -11.99210061  -11.99210061
   -0.22415219   -0.18203147   -0.18203147   -0.18203147]
E1 = -570.1981344090033  E_coul = 128.19960066457173
cycle= 2 E= -441.998533744432  delta_E= 5.68e-14  |g|=    0  |ddm|= 1.84e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -570.1981344090033  E_coul = 128.19960066457173
  mo_energy =
[-104.40723655  -15.74568156  -11.99210061  -11.99210061  -11.99210061
   -0.22415219   -0.18203147   -0.18203147   -0.18203147]
E1 = -570.1981344090034  E_coul = 128.1996006645717
Extra cycle  E= -441.998533744432  delta_E= -1.71e-13  |g|=    0  |ddm|= 2.24e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.7155880980748694
E1 = -570.1981344090034  E_coul = 128.1996006645717
init E= -441.998533744432
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.40723655  -15.74568156  -11.99210061  -11.99210061  -11.99210061
   -0.22415219   -0.18203147   -0.18203147   -0.18203147]
E1 = -570.1981344090033  E_coul = 128.19960066457173
cycle= 1 E= -441.998533744432  delta_E= 1.71e-13  |g|=    0  |ddm|= 2.24e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -570.1981344090033  E_coul = 128.19960066457173
  mo_energy =
[-104.40723655  -15.74568156  -11.99210061  -11.99210061  -11.99210061
   -0.22415219   -0.18203147   -0.18203147   -0.18203147]
E1 = -570.1981344090034  E_coul = 128.1996006645717
Extra cycle  E= -441.998533744432  delta_E= -1.71e-13  |g|=    0  |ddm|= 2.26e-15
    CPU time for scf_cycle      0.12 sec, wall time      0.12 sec
exp = [9.46060886e+01 4.37063540e+00 1.83614880e-03 8.32933332e+00
 3.98821562e-03]
grad_E = [ 1.45432891e-03 -4.42874195e-02 -2.07366857e+02  7.64016539e-02
 -2.58715109e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:06 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.7036713595        1
[INPUT] 0    0    [1    /1   ]  4.39790463881        1
[INPUT] 0    0    [1    /1   ]  0.00184255861919      1
[INPUT] 1    0    [1    /1   ]  8.2365023532         1
[INPUT] 1    0    [1    /1   ]  0.00398845161902      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.70367135947983, 1.0]], [0, [4.397904638809988, 1.0]], [0, [0.0018425586191872332, 1.0]], [1, [8.236502353202166, 1.0]], [1, [0.003988451619017724, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.70367136]
bas 1, expnt(s) = [4.39790464]
bas 2, expnt(s) = [0.00184256]
bas 3, expnt(s) = [8.23650235]
bas 4, expnt(s) = [0.00398845]
CPU time:        60.40
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.47036714e+01 7.66990767e+01 4.39790464e+00 7.67272054e+00
 1.84255862e-03 2.24688585e-02 8.23650235e+00 4.07064216e+01
 3.98845162e-03 2.92408372e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.53454435161021
cond(S) = 1.7190397463446772
E1 = -535.8494124597247  E_coul = 109.87052942321694
init E= -425.978883036508
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.66662754  -17.37521582  -13.56992223  -13.56992223  -13.56992223
   -0.57605162   -0.55905099   -0.55905099   -0.55905099]
E1 = -569.8210106823365  E_coul = 127.81683833070348
cycle= 1 E= -442.004172351633  delta_E=  -16  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.02924e-14
diis-c [-1.62348003e-27  1.00000000e+00]
  mo_energy =
[-104.50432593  -15.76127578  -12.01913607  -12.01913607  -12.01913607
   -0.22477484   -0.18196075   -0.18196075   -0.18196075]
E1 = -569.8210106823362  E_coul = 127.81683833070339
cycle= 2 E= -442.004172351633  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.12e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.8210106823362  E_coul = 127.81683833070339
  mo_energy =
[-104.50432593  -15.76127578  -12.01913607  -12.01913607  -12.01913607
   -0.22477484   -0.18196075   -0.18196075   -0.18196075]
E1 = -569.8210106823364  E_coul = 127.81683833070343
Extra cycle  E= -442.004172351633  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.12e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.47036714e+01 4.39790464e+00 1.84255862e-03 8.23650235e+00
 3.98845162e-03]
E = -442.0041723516329
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:06 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.7036713595        1
[INPUT] 0    0    [1    /1   ]  4.39790463881        1
[INPUT] 0    0    [1    /1   ]  0.00184255861919      1
[INPUT] 1    0    [1    /1   ]  8.2365023532         1
[INPUT] 1    0    [1    /1   ]  0.00398845161902      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.70367135947983, 1.0]], [0, [4.397904638809988, 1.0]], [0, [0.0018425586191872332, 1.0]], [1, [8.236502353202166, 1.0]], [1, [0.003988451619017724, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.70367136]
bas 1, expnt(s) = [4.39790464]
bas 2, expnt(s) = [0.00184256]
bas 3, expnt(s) = [8.23650235]
bas 4, expnt(s) = [0.00398845]
CPU time:        60.74
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.47036714e+01 7.66990767e+01 4.39790464e+00 7.67272054e+00
 1.84255862e-03 2.24688585e-02 8.23650235e+00 4.07064216e+01
 3.98845162e-03 2.92408372e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.53454435161021
cond(S) = 1.7190397463446772
E1 = -535.8494124597247  E_coul = 109.87052942321694
init E= -425.978883036508
    CPU time for initialize scf      0.02 sec, wall time      0.03 sec
  mo_energy =
[-106.66662754  -17.37521582  -13.56992223  -13.56992223  -13.56992223
   -0.57605162   -0.55905099   -0.55905099   -0.55905099]
E1 = -569.8210106823365  E_coul = 127.81683833070348
cycle= 1 E= -442.004172351633  delta_E=  -16  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.02924e-14
diis-c [-1.62348003e-27  1.00000000e+00]
  mo_energy =
[-104.50432593  -15.76127578  -12.01913607  -12.01913607  -12.01913607
   -0.22477484   -0.18196075   -0.18196075   -0.18196075]
E1 = -569.8210106823362  E_coul = 127.81683833070339
cycle= 2 E= -442.004172351633  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.12e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -569.8210106823362  E_coul = 127.81683833070339
  mo_energy =
[-104.50432593  -15.76127578  -12.01913607  -12.01913607  -12.01913607
   -0.22477484   -0.18196075   -0.18196075   -0.18196075]
E1 = -569.8210106823364  E_coul = 127.81683833070343
Extra cycle  E= -442.004172351633  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.12e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.7190397463446772
E1 = -569.8210106823364  E_coul = 127.81683833070343
init E= -442.004172351633
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.50432593  -15.76127578  -12.01913607  -12.01913607  -12.01913607
   -0.22477484   -0.18196075   -0.18196075   -0.18196075]
E1 = -569.8210106823365  E_coul = 127.81683833070348
cycle= 1 E= -442.004172351633  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.19e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -569.8210106823365  E_coul = 127.81683833070348
  mo_energy =
[-104.50432593  -15.76127578  -12.01913607  -12.01913607  -12.01913607
   -0.22477484   -0.18196075   -0.18196075   -0.18196075]
E1 = -569.8210106823362  E_coul = 127.81683833070339
Extra cycle  E= -442.004172351633  delta_E= 1.14e-13  |g|=    0  |ddm|= 2.99e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.12 sec
exp = [9.47036714e+01 4.39790464e+00 1.84255862e-03 8.23650235e+00
 3.98845162e-03]
grad_E = [ 2.26878964e-03 -1.76747158e-02 -2.07136918e+02  6.50427927e-04
 -2.58644706e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:09 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.5861293862        1
[INPUT] 0    0    [1    /1   ]  4.40908527841        1
[INPUT] 0    0    [1    /1   ]  0.00184863594659      1
[INPUT] 1    0    [1    /1   ]  8.21661507468        1
[INPUT] 1    0    [1    /1   ]  0.00398867027078      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.58612938619926, 1.0]], [0, [4.409085278414986, 1.0]], [0, [0.0018486359465929704, 1.0]], [1, [8.216615074680275, 1.0]], [1, [0.003988670270778952, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.58612939]
bas 1, expnt(s) = [4.40908528]
bas 2, expnt(s) = [0.00184864]
bas 3, expnt(s) = [8.21661507]
bas 4, expnt(s) = [0.00398867]
CPU time:        63.69
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.45861294e+01 7.66276690e+01 4.40908528e+00 7.68734546e+00
 1.84863595e-03 2.25244175e-02 8.21661507e+00 4.05836001e+01
 3.98867027e-03 2.92428410e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.534348076247563
cond(S) = 1.721568978581384
E1 = -535.7768118992511  E_coul = 109.79475743799819
init E= -425.982054461253
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.69160382  -17.37570716  -13.57406458  -13.57406458  -13.57406458
   -0.57700876   -0.55907976   -0.55907976   -0.55907976]
E1 = -569.74416643954  E_coul = 127.73858086051902
cycle= 1 E= -442.005585579021  delta_E=  -16  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.15478e-14
diis-c [-1.7262222e-27  1.0000000e+00]
  mo_energy =
[-104.52984121  -15.76119176  -12.0238087   -12.0238087   -12.0238087
   -0.2253617    -0.18189387   -0.18189387   -0.18189387]
E1 = -569.7441664395403  E_coul = 127.73858086051916
cycle= 2 E= -442.005585579021  delta_E= -2.27e-13  |g|=    0  |ddm|= 3.62e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.7441664395403  E_coul = 127.73858086051916
  mo_energy =
[-104.52984121  -15.76119176  -12.0238087   -12.0238087   -12.0238087
   -0.2253617    -0.18189387   -0.18189387   -0.18189387]
E1 = -569.74416643954  E_coul = 127.73858086051905
Extra cycle  E= -442.005585579021  delta_E= 2.27e-13  |g|=    0  |ddm|= 3.38e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.45861294e+01 4.40908528e+00 1.84863595e-03 8.21661507e+00
 3.98867027e-03]
E = -442.00558557902093
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:10 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.5861293862        1
[INPUT] 0    0    [1    /1   ]  4.40908527841        1
[INPUT] 0    0    [1    /1   ]  0.00184863594659      1
[INPUT] 1    0    [1    /1   ]  8.21661507468        1
[INPUT] 1    0    [1    /1   ]  0.00398867027078      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.58612938619926, 1.0]], [0, [4.409085278414986, 1.0]], [0, [0.0018486359465929704, 1.0]], [1, [8.216615074680275, 1.0]], [1, [0.003988670270778952, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.58612939]
bas 1, expnt(s) = [4.40908528]
bas 2, expnt(s) = [0.00184864]
bas 3, expnt(s) = [8.21661507]
bas 4, expnt(s) = [0.00398867]
CPU time:        64.03
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.45861294e+01 7.66276690e+01 4.40908528e+00 7.68734546e+00
 1.84863595e-03 2.25244175e-02 8.21661507e+00 4.05836001e+01
 3.98867027e-03 2.92428410e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.534348076247563
cond(S) = 1.721568978581384
E1 = -535.7768118992511  E_coul = 109.79475743799819
init E= -425.982054461253
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.69160382  -17.37570716  -13.57406458  -13.57406458  -13.57406458
   -0.57700876   -0.55907976   -0.55907976   -0.55907976]
E1 = -569.74416643954  E_coul = 127.73858086051902
cycle= 1 E= -442.005585579021  delta_E=  -16  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.15478e-14
diis-c [-1.7262222e-27  1.0000000e+00]
  mo_energy =
[-104.52984121  -15.76119176  -12.0238087   -12.0238087   -12.0238087
   -0.2253617    -0.18189387   -0.18189387   -0.18189387]
E1 = -569.7441664395403  E_coul = 127.73858086051916
cycle= 2 E= -442.005585579021  delta_E= -2.27e-13  |g|=    0  |ddm|= 3.62e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.7441664395403  E_coul = 127.73858086051916
  mo_energy =
[-104.52984121  -15.76119176  -12.0238087   -12.0238087   -12.0238087
   -0.2253617    -0.18189387   -0.18189387   -0.18189387]
E1 = -569.74416643954  E_coul = 127.73858086051905
Extra cycle  E= -442.005585579021  delta_E= 2.27e-13  |g|=    0  |ddm|= 3.38e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.721568978581384
E1 = -569.74416643954  E_coul = 127.73858086051905
init E= -442.005585579021
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.52984121  -15.76119176  -12.0238087   -12.0238087   -12.0238087
   -0.2253617    -0.18189387   -0.18189387   -0.18189387]
E1 = -569.74416643954  E_coul = 127.73858086051902
cycle= 1 E= -442.005585579021  delta_E=    0  |g|=    0  |ddm|= 1.69e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -569.74416643954  E_coul = 127.73858086051902
  mo_energy =
[-104.52984121  -15.76119176  -12.0238087   -12.0238087   -12.0238087
   -0.2253617    -0.18189387   -0.18189387   -0.18189387]
E1 = -569.7441664395403  E_coul = 127.73858086051916
Extra cycle  E= -442.005585579021  delta_E= -2.27e-13  |g|=    0  |ddm|= 4.11e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.45861294e+01 4.40908528e+00 1.84863595e-03 8.21661507e+00
 3.98867027e-03]
grad_E = [ 6.43419337e-05 -2.02695511e-03 -2.06914026e+02 -1.56173087e-02
 -2.58578574e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:13 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.4594844041        1
[INPUT] 0    0    [1    /1   ]  4.43036245854        1
[INPUT] 0    0    [1    /1   ]  0.00186859469048      1
[INPUT] 1    0    [1    /1   ]  8.19097882414        1
[INPUT] 1    0    [1    /1   ]  0.0039893937123      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.45948440410008, 1.0]], [0, [4.430362458537567, 1.0]], [0, [0.0018685946904835472, 1.0]], [1, [8.190978824143398, 1.0]], [1, [0.003989393712302026, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.4594844]
bas 1, expnt(s) = [4.43036246]
bas 2, expnt(s) = [0.00186859]
bas 3, expnt(s) = [8.19097882]
bas 4, expnt(s) = [0.00398939]
CPU time:        67.04
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.44594844e+01 7.65507063e+01 4.43036246e+00 7.71515167e+00
 1.86859469e-03 2.27065607e-02 8.19097882e+00 4.04253833e+01
 3.98939371e-03 2.92494710e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.534037619335196
cond(S) = 1.7257110633233534
E1 = -535.6998350437993  E_coul = 109.71238168154464
init E= -425.987453362255
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.7245696   -17.37112492  -13.5781596   -13.5781596   -13.5781596
   -0.58011544   -0.55915212   -0.55915212   -0.55915212]
E1 = -569.6714211683709  E_coul = 127.66260444560197
cycle= 1 E= -442.008816722769  delta_E=  -16  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.08778e-14
diis-c [-1.67099371e-27  1.00000000e+00]
  mo_energy =
[-104.56247084  -15.75479155  -12.02784448  -12.02784448  -12.02784448
   -0.22728188   -0.18167614   -0.18167614   -0.18167614]
E1 = -569.671421168371  E_coul = 127.66260444560201
cycle= 2 E= -442.008816722769  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.39e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.671421168371  E_coul = 127.66260444560201
  mo_energy =
[-104.56247084  -15.75479155  -12.02784448  -12.02784448  -12.02784448
   -0.22728188   -0.18167614   -0.18167614   -0.18167614]
E1 = -569.671421168371  E_coul = 127.66260444560201
Extra cycle  E= -442.008816722769  delta_E=    0  |g|=    0  |ddm|= 1.01e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.44594844e+01 4.43036246e+00 1.86859469e-03 8.19097882e+00
 3.98939371e-03]
E = -442.008816722769
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:13 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.4594844041        1
[INPUT] 0    0    [1    /1   ]  4.43036245854        1
[INPUT] 0    0    [1    /1   ]  0.00186859469048      1
[INPUT] 1    0    [1    /1   ]  8.19097882414        1
[INPUT] 1    0    [1    /1   ]  0.0039893937123      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.45948440410008, 1.0]], [0, [4.430362458537567, 1.0]], [0, [0.0018685946904835472, 1.0]], [1, [8.190978824143398, 1.0]], [1, [0.003989393712302026, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.4594844]
bas 1, expnt(s) = [4.43036246]
bas 2, expnt(s) = [0.00186859]
bas 3, expnt(s) = [8.19097882]
bas 4, expnt(s) = [0.00398939]
CPU time:        67.41
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.44594844e+01 7.65507063e+01 4.43036246e+00 7.71515167e+00
 1.86859469e-03 2.27065607e-02 8.19097882e+00 4.04253833e+01
 3.98939371e-03 2.92494710e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.534037619335196
cond(S) = 1.7257110633233534
E1 = -535.6998350437993  E_coul = 109.71238168154464
init E= -425.987453362255
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.7245696   -17.37112492  -13.5781596   -13.5781596   -13.5781596
   -0.58011544   -0.55915212   -0.55915212   -0.55915212]
E1 = -569.6714211683709  E_coul = 127.66260444560197
cycle= 1 E= -442.008816722769  delta_E=  -16  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.08778e-14
diis-c [-1.67099371e-27  1.00000000e+00]
  mo_energy =
[-104.56247084  -15.75479155  -12.02784448  -12.02784448  -12.02784448
   -0.22728188   -0.18167614   -0.18167614   -0.18167614]
E1 = -569.671421168371  E_coul = 127.66260444560201
cycle= 2 E= -442.008816722769  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.39e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.671421168371  E_coul = 127.66260444560201
  mo_energy =
[-104.56247084  -15.75479155  -12.02784448  -12.02784448  -12.02784448
   -0.22728188   -0.18167614   -0.18167614   -0.18167614]
E1 = -569.671421168371  E_coul = 127.66260444560201
Extra cycle  E= -442.008816722769  delta_E=    0  |g|=    0  |ddm|= 1.01e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.7257110633233534
E1 = -569.671421168371  E_coul = 127.66260444560201
init E= -442.008816722769
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.56247084  -15.75479155  -12.02784448  -12.02784448  -12.02784448
   -0.22728188   -0.18167614   -0.18167614   -0.18167614]
E1 = -569.671421168371  E_coul = 127.66260444560199
cycle= 1 E= -442.008816722769  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.64e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -569.671421168371  E_coul = 127.66260444560199
  mo_energy =
[-104.56247084  -15.75479155  -12.02784448  -12.02784448  -12.02784448
   -0.22728188   -0.18167614   -0.18167614   -0.18167614]
E1 = -569.6714211683711  E_coul = 127.6626044456021
Extra cycle  E= -442.008816722769  delta_E=    0  |g|=    0  |ddm|= 4.51e-15
    CPU time for scf_cycle      0.12 sec, wall time      0.12 sec
exp = [9.44594844e+01 4.43036246e+00 1.86859469e-03 8.19097882e+00
 3.98939371e-03]
grad_E = [-2.52402050e-03  2.64051736e-02 -2.06182234e+02 -3.61130167e-02
 -2.58362864e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:16 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.2267235464        1
[INPUT] 0    0    [1    /1   ]  4.46511782843        1
[INPUT] 0    0    [1    /1   ]  0.00193338699686      1
[INPUT] 1    0    [1    /1   ]  8.14920404239        1
[INPUT] 1    0    [1    /1   ]  0.00399174623755      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.22672354640713, 1.0]], [0, [4.46511782843217, 1.0]], [0, [0.0019333869968564336, 1.0]], [1, [8.149204042392759, 1.0]], [1, [0.003991746237553207, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.22672355]
bas 1, expnt(s) = [4.46511783]
bas 2, expnt(s) = [0.00193339]
bas 3, expnt(s) = [8.14920404]
bas 4, expnt(s) = [0.00399175]
CPU time:        70.70
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.42267235e+01 7.64091893e+01 4.46511783e+00 7.76050025e+00
 1.93338700e-03 2.32945390e-02 8.14920404e+00 4.01678311e+01
 3.99174624e-03 2.92710329e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.533592929207346
cond(S) = 1.73270478188492
E1 = -535.5639916314854  E_coul = 109.5727924555648
init E= -425.991199175921
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  mo_energy =
[-106.77894894  -17.36358252  -13.58499751  -13.58499751  -13.58499751
   -0.59004289   -0.55934939   -0.55934939   -0.55934939]
E1 = -569.5681380168402  E_coul = 127.55050080955156
cycle= 1 E= -442.017637207289  delta_E=  -16  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.34267e-14
diis-c [-5.48810344e-28  1.00000000e+00]
  mo_energy =
[-104.61479349  -15.74291096  -12.0331462   -12.0331462   -12.0331462
   -0.23346412   -0.18098701   -0.18098701   -0.18098701]
E1 = -569.56813801684  E_coul = 127.55050080955152
cycle= 2 E= -442.017637207288  delta_E= 1.71e-13  |g|=    0  |ddm|= 4.61e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.56813801684  E_coul = 127.55050080955152
  mo_energy =
[-104.61479349  -15.74291096  -12.0331462   -12.0331462   -12.0331462
   -0.23346412   -0.18098701   -0.18098701   -0.18098701]
E1 = -569.5681380168398  E_coul = 127.55050080955141
Extra cycle  E= -442.017637207288  delta_E=    0  |g|=    0  |ddm|= 3.86e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [9.42267235e+01 4.46511783e+00 1.93338700e-03 8.14920404e+00
 3.99174624e-03]
E = -442.01763720728843
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:17 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  94.2267235464        1
[INPUT] 0    0    [1    /1   ]  4.46511782843        1
[INPUT] 0    0    [1    /1   ]  0.00193338699686      1
[INPUT] 1    0    [1    /1   ]  8.14920404239        1
[INPUT] 1    0    [1    /1   ]  0.00399174623755      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [94.22672354640713, 1.0]], [0, [4.46511782843217, 1.0]], [0, [0.0019333869968564336, 1.0]], [1, [8.149204042392759, 1.0]], [1, [0.003991746237553207, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [94.22672355]
bas 1, expnt(s) = [4.46511783]
bas 2, expnt(s) = [0.00193339]
bas 3, expnt(s) = [8.14920404]
bas 4, expnt(s) = [0.00399175]
CPU time:        71.08
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.42267235e+01 7.64091893e+01 4.46511783e+00 7.76050025e+00
 1.93338700e-03 2.32945390e-02 8.14920404e+00 4.01678311e+01
 3.99174624e-03 2.92710329e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.533592929207346
cond(S) = 1.73270478188492
E1 = -535.5639916314854  E_coul = 109.5727924555648
init E= -425.991199175921
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.77894894  -17.36358252  -13.58499751  -13.58499751  -13.58499751
   -0.59004289   -0.55934939   -0.55934939   -0.55934939]
E1 = -569.5681380168402  E_coul = 127.55050080955156
cycle= 1 E= -442.017637207289  delta_E=  -16  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.34267e-14
diis-c [-5.48810344e-28  1.00000000e+00]
  mo_energy =
[-104.61479349  -15.74291096  -12.0331462   -12.0331462   -12.0331462
   -0.23346412   -0.18098701   -0.18098701   -0.18098701]
E1 = -569.56813801684  E_coul = 127.55050080955152
cycle= 2 E= -442.017637207288  delta_E= 1.71e-13  |g|=    0  |ddm|= 4.61e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.56813801684  E_coul = 127.55050080955152
  mo_energy =
[-104.61479349  -15.74291096  -12.0331462   -12.0331462   -12.0331462
   -0.23346412   -0.18098701   -0.18098701   -0.18098701]
E1 = -569.5681380168398  E_coul = 127.55050080955141
Extra cycle  E= -442.017637207288  delta_E=    0  |g|=    0  |ddm|= 3.86e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.73270478188492
E1 = -569.5681380168398  E_coul = 127.55050080955141
init E= -442.017637207288
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.61479349  -15.74291096  -12.0331462   -12.0331462   -12.0331462
   -0.23346412   -0.18098701   -0.18098701   -0.18098701]
E1 = -569.56813801684  E_coul = 127.55050080955155
cycle= 1 E= -442.017637207288  delta_E=    0  |g|=    0  |ddm|= 4.72e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -569.56813801684  E_coul = 127.55050080955155
  mo_energy =
[-104.61479349  -15.74291096  -12.0331462   -12.0331462   -12.0331462
   -0.23346412   -0.18098701   -0.18098701   -0.18098701]
E1 = -569.56813801684  E_coul = 127.55050080955148
Extra cycle  E= -442.017637207288  delta_E= -5.68e-14  |g|=    0  |ddm|= 4.33e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.42267235e+01 4.46511783e+00 1.93338700e-03 8.14920404e+00
 3.99174624e-03]
grad_E = [-7.18542524e-03  7.29822980e-02 -2.03844446e+02 -6.97882572e-02
 -2.57677761e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:20 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  93.8821160815        1
[INPUT] 0    0    [1    /1   ]  4.51965768447        1
[INPUT] 0    0    [1    /1   ]  0.00211291269405      1
[INPUT] 1    0    [1    /1   ]  8.08629389206        1
[INPUT] 1    0    [1    /1   ]  0.00399827297791      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [93.88211608150596, 1.0]], [0, [4.51965768446784, 1.0]], [0, [0.0021129126940464577, 1.0]], [1, [8.086293892062406, 1.0]], [1, [0.003998272977907938, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [93.88211608]
bas 1, expnt(s) = [4.51965768]
bas 2, expnt(s) = [0.00211291]
bas 3, expnt(s) = [8.08629389]
bas 4, expnt(s) = [0.00399827]
CPU time:        74.03
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.38821161e+01 7.61995097e+01 4.51965768e+00 7.83148610e+00
 2.11291269e-03 2.48986722e-02 8.08629389e+00 3.97805968e+01
 3.99827298e-03 2.93308700e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.533076757855481
cond(S) = 1.7436384037144659
E1 = -535.3429481127099  E_coul = 109.35874267583925
init E= -425.984205436871
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.86116734  -17.35010953  -13.59525785  -13.59525785  -13.59525785
   -0.61664664   -0.55984795   -0.55984795   -0.55984795]
E1 = -569.4600964992635  E_coul = 127.42036279645569
cycle= 1 E= -442.039733702808  delta_E= -16.1  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.67724e-15
diis-c [-2.18765971e-29  1.00000000e+00]
  mo_energy =
[-104.68993609  -15.71933013  -12.03752243  -12.03752243  -12.03752243
   -0.25023548   -0.17920549   -0.17920549   -0.17920549]
E1 = -569.4600964992635  E_coul = 127.42036279645565
cycle= 2 E= -442.039733702808  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.59e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.4600964992635  E_coul = 127.42036279645565
  mo_energy =
[-104.68993609  -15.71933013  -12.03752243  -12.03752243  -12.03752243
   -0.25023548   -0.17920549   -0.17920549   -0.17920549]
E1 = -569.4600964992635  E_coul = 127.42036279645566
Extra cycle  E= -442.039733702808  delta_E=    0  |g|=    0  |ddm|= 3.7e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [9.38821161e+01 4.51965768e+00 2.11291269e-03 8.08629389e+00
 3.99827298e-03]
E = -442.03973370280784
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:20 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  93.8821160815        1
[INPUT] 0    0    [1    /1   ]  4.51965768447        1
[INPUT] 0    0    [1    /1   ]  0.00211291269405      1
[INPUT] 1    0    [1    /1   ]  8.08629389206        1
[INPUT] 1    0    [1    /1   ]  0.00399827297791      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [93.88211608150596, 1.0]], [0, [4.51965768446784, 1.0]], [0, [0.0021129126940464577, 1.0]], [1, [8.086293892062406, 1.0]], [1, [0.003998272977907938, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [93.88211608]
bas 1, expnt(s) = [4.51965768]
bas 2, expnt(s) = [0.00211291]
bas 3, expnt(s) = [8.08629389]
bas 4, expnt(s) = [0.00399827]
CPU time:        74.43
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.38821161e+01 7.61995097e+01 4.51965768e+00 7.83148610e+00
 2.11291269e-03 2.48986722e-02 8.08629389e+00 3.97805968e+01
 3.99827298e-03 2.93308700e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.533076757855481
cond(S) = 1.7436384037144659
E1 = -535.3429481127099  E_coul = 109.35874267583925
init E= -425.984205436871
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  mo_energy =
[-106.86116734  -17.35010953  -13.59525785  -13.59525785  -13.59525785
   -0.61664664   -0.55984795   -0.55984795   -0.55984795]
E1 = -569.4600964992635  E_coul = 127.42036279645569
cycle= 1 E= -442.039733702808  delta_E= -16.1  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.67724e-15
diis-c [-2.18765971e-29  1.00000000e+00]
  mo_energy =
[-104.68993609  -15.71933013  -12.03752243  -12.03752243  -12.03752243
   -0.25023548   -0.17920549   -0.17920549   -0.17920549]
E1 = -569.4600964992635  E_coul = 127.42036279645565
cycle= 2 E= -442.039733702808  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.59e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -569.4600964992635  E_coul = 127.42036279645565
  mo_energy =
[-104.68993609  -15.71933013  -12.03752243  -12.03752243  -12.03752243
   -0.25023548   -0.17920549   -0.17920549   -0.17920549]
E1 = -569.4600964992635  E_coul = 127.42036279645566
Extra cycle  E= -442.039733702808  delta_E=    0  |g|=    0  |ddm|= 3.7e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.7436384037144659
E1 = -569.4600964992635  E_coul = 127.42036279645566
init E= -442.039733702808
    CPU time for initialize scf      0.07 sec, wall time      0.07 sec
  mo_energy =
[-104.68993609  -15.71933013  -12.03752243  -12.03752243  -12.03752243
   -0.25023548   -0.17920549   -0.17920549   -0.17920549]
E1 = -569.4600964992635  E_coul = 127.42036279645566
cycle= 1 E= -442.039733702808  delta_E=    0  |g|=    0  |ddm|= 2.22e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -569.4600964992635  E_coul = 127.42036279645566
  mo_energy =
[-104.68993609  -15.71933013  -12.03752243  -12.03752243  -12.03752243
   -0.25023548   -0.17920549   -0.17920549   -0.17920549]
E1 = -569.4600964992635  E_coul = 127.42036279645568
Extra cycle  E= -442.039733702808  delta_E=    0  |g|=    0  |ddm|= 1.49e-15
    CPU time for scf_cycle      0.15 sec, wall time      0.15 sec
exp = [9.38821161e+01 4.51965768e+00 2.11291269e-03 8.08629389e+00
 3.99827298e-03]
grad_E = [-1.41780381e-02  1.44744270e-01 -1.97721279e+02 -1.20872298e-01
 -2.55887885e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:23 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  93.3842818396        1
[INPUT] 0    0    [1    /1   ]  4.60084103515        1
[INPUT] 0    0    [1    /1   ]  0.00258435788381      1
[INPUT] 1    0    [1    /1   ]  7.99708015584        1
[INPUT] 1    0    [1    /1   ]  0.00401542785313      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [93.38428183959232, 1.0]], [0, [4.600841035147367, 1.0]], [0, [0.0025843578838148362, 1.0]], [1, [7.997080155840329, 1.0]], [1, [0.004015427853133015, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [93.38428184]
bas 1, expnt(s) = [4.60084104]
bas 2, expnt(s) = [0.00258436]
bas 3, expnt(s) = [7.99708016]
bas 4, expnt(s) = [0.00401543]
CPU time:        77.88
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.33842818e+01 7.58962576e+01 4.60084104e+00 7.93675447e+00
 2.58435788e-03 2.89587302e-02 7.99708016e+00 3.92327458e+01
 4.01542785e-03 2.94882620e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.533090084898596
cond(S) = 1.760057881879417
E1 = -534.9909590867176  E_coul = 109.0439776332047
init E= -425.946981453513
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.97867744  -17.327028    -13.60989941  -13.60989941  -13.60989941
   -0.68136857   -0.56106262   -0.56106262   -0.56106262]
E1 = -569.4142108372595  E_coul = 127.31993878575338
cycle= 1 E= -442.094272051506  delta_E= -16.1  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.01984e-14
diis-c [-1.6159138e-27  1.0000000e+00]
  mo_energy =
[-104.78848052  -15.67383875  -12.03569041  -12.03569041  -12.03569041
   -0.29205091   -0.17524174   -0.17524174   -0.17524174]
E1 = -569.4142108372595  E_coul = 127.31993878575337
cycle= 2 E= -442.094272051506  delta_E=    0  |g|=    0  |ddm|= 3.18e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.4142108372595  E_coul = 127.31993878575337
  mo_energy =
[-104.78848052  -15.67383875  -12.03569041  -12.03569041  -12.03569041
   -0.29205091   -0.17524174   -0.17524174   -0.17524174]
E1 = -569.4142108372594  E_coul = 127.31993878575335
Extra cycle  E= -442.094272051506  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.29e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.33842818e+01 4.60084104e+00 2.58435788e-03 7.99708016e+00
 4.01542785e-03]
E = -442.094272051506
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:24 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  93.3842818396        1
[INPUT] 0    0    [1    /1   ]  4.60084103515        1
[INPUT] 0    0    [1    /1   ]  0.00258435788381      1
[INPUT] 1    0    [1    /1   ]  7.99708015584        1
[INPUT] 1    0    [1    /1   ]  0.00401542785313      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [93.38428183959232, 1.0]], [0, [4.600841035147367, 1.0]], [0, [0.0025843578838148362, 1.0]], [1, [7.997080155840329, 1.0]], [1, [0.004015427853133015, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [93.38428184]
bas 1, expnt(s) = [4.60084104]
bas 2, expnt(s) = [0.00258436]
bas 3, expnt(s) = [7.99708016]
bas 4, expnt(s) = [0.00401543]
CPU time:        78.29
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.33842818e+01 7.58962576e+01 4.60084104e+00 7.93675447e+00
 2.58435788e-03 2.89587302e-02 7.99708016e+00 3.92327458e+01
 4.01542785e-03 2.94882620e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.533090084898596
cond(S) = 1.760057881879417
E1 = -534.9909590867176  E_coul = 109.0439776332047
init E= -425.946981453513
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-106.97867744  -17.327028    -13.60989941  -13.60989941  -13.60989941
   -0.68136857   -0.56106262   -0.56106262   -0.56106262]
E1 = -569.4142108372595  E_coul = 127.31993878575338
cycle= 1 E= -442.094272051506  delta_E= -16.1  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.01984e-14
diis-c [-1.6159138e-27  1.0000000e+00]
  mo_energy =
[-104.78848052  -15.67383875  -12.03569041  -12.03569041  -12.03569041
   -0.29205091   -0.17524174   -0.17524174   -0.17524174]
E1 = -569.4142108372595  E_coul = 127.31993878575337
cycle= 2 E= -442.094272051506  delta_E=    0  |g|=    0  |ddm|= 3.18e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.4142108372595  E_coul = 127.31993878575337
  mo_energy =
[-104.78848052  -15.67383875  -12.03569041  -12.03569041  -12.03569041
   -0.29205091   -0.17524174   -0.17524174   -0.17524174]
E1 = -569.4142108372594  E_coul = 127.31993878575335
Extra cycle  E= -442.094272051506  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.29e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.760057881879417
E1 = -569.4142108372594  E_coul = 127.31993878575335
init E= -442.094272051506
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.78848052  -15.67383875  -12.03569041  -12.03569041  -12.03569041
   -0.29205091   -0.17524174   -0.17524174   -0.17524174]
E1 = -569.4142108372595  E_coul = 127.31993878575338
cycle= 1 E= -442.094272051506  delta_E= -1.14e-13  |g|=    0  |ddm|= 1.1e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -569.4142108372595  E_coul = 127.31993878575338
  mo_energy =
[-104.78848052  -15.67383875  -12.03569041  -12.03569041  -12.03569041
   -0.29205091   -0.17524174   -0.17524174   -0.17524174]
E1 = -569.4142108372594  E_coul = 127.31993878575335
Extra cycle  E= -442.094272051506  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.1e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.12 sec
exp = [9.33842818e+01 4.60084104e+00 2.58435788e-03 7.99708016e+00
 4.01542785e-03]
grad_E = [-2.43741120e-02  2.49152975e-01 -1.83864930e+02 -1.94199974e-01
 -2.51763418e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:27 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  92.7739556447        1
[INPUT] 0    0    [1    /1   ]  4.70775948818        1
[INPUT] 0    0    [1    /1   ]  0.00372978580516      1
[INPUT] 1    0    [1    /1   ]  7.88954999402        1
[INPUT] 1    0    [1    /1   ]  0.00405713687877      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [92.77395564465198, 1.0]], [0, [4.70775948817774, 1.0]], [0, [0.003729785805162217, 1.0]], [1, [7.889549994015688, 1.0]], [1, [0.004057136878767978, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [92.77395564]
bas 1, expnt(s) = [4.70775949]
bas 2, expnt(s) = [0.00372979]
bas 3, expnt(s) = [7.88954999]
bas 4, expnt(s) = [0.00405714]
CPU time:        81.28
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.27739556e+01 7.55239298e+01 4.70775949e+00 8.07468752e+00
 3.72978581e-03 3.81309779e-02 7.88954999e+00 3.85744447e+01
 4.05713688e-03 2.98716332e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.536498040889553
cond(S) = 1.7818917207177885
E1 = -534.5128366503034  E_coul = 108.65431463097366
init E= -425.85852201933
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-107.12190997  -17.28957665  -13.62705385  -13.62705385  -13.62705385
   -0.81664474   -0.56376492   -0.56376492   -0.56376492]
E1 = -569.6034590721721  E_coul = 127.38133485694921
cycle= 1 E= -442.222124215223  delta_E= -16.4  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.08955e-14
diis-c [-4.36619913e-28  1.00000000e+00]
  mo_energy =
[-104.89066763  -15.59264992  -12.0162611   -12.0162611   -12.0162611
   -0.38316079   -0.16837768   -0.16837768   -0.16837768]
E1 = -569.6034590721719  E_coul = 127.38133485694914
cycle= 2 E= -442.222124215223  delta_E= 1.71e-13  |g|=    0  |ddm|= 3.78e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.6034590721719  E_coul = 127.38133485694914
  mo_energy =
[-104.89066763  -15.59264992  -12.0162611   -12.0162611   -12.0162611
   -0.38316079   -0.16837768   -0.16837768   -0.16837768]
E1 = -569.6034590721721  E_coul = 127.38133485694925
Extra cycle  E= -442.222124215223  delta_E= -1.14e-13  |g|=    0  |ddm|= 4.63e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.27739556e+01 4.70775949e+00 3.72978581e-03 7.88954999e+00
 4.05713688e-03]
E = -442.22212421522283
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:27 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  92.7739556447        1
[INPUT] 0    0    [1    /1   ]  4.70775948818        1
[INPUT] 0    0    [1    /1   ]  0.00372978580516      1
[INPUT] 1    0    [1    /1   ]  7.88954999402        1
[INPUT] 1    0    [1    /1   ]  0.00405713687877      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [92.77395564465198, 1.0]], [0, [4.70775948817774, 1.0]], [0, [0.003729785805162217, 1.0]], [1, [7.889549994015688, 1.0]], [1, [0.004057136878767978, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [92.77395564]
bas 1, expnt(s) = [4.70775949]
bas 2, expnt(s) = [0.00372979]
bas 3, expnt(s) = [7.88954999]
bas 4, expnt(s) = [0.00405714]
CPU time:        81.73
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.27739556e+01 7.55239298e+01 4.70775949e+00 8.07468752e+00
 3.72978581e-03 3.81309779e-02 7.88954999e+00 3.85744447e+01
 4.05713688e-03 2.98716332e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.536498040889553
cond(S) = 1.7818917207177885
E1 = -534.5128366503034  E_coul = 108.65431463097366
init E= -425.85852201933
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-107.12190997  -17.28957665  -13.62705385  -13.62705385  -13.62705385
   -0.81664474   -0.56376492   -0.56376492   -0.56376492]
E1 = -569.6034590721721  E_coul = 127.38133485694921
cycle= 1 E= -442.222124215223  delta_E= -16.4  |g|=    0  |ddm|=    4
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.08955e-14
diis-c [-4.36619913e-28  1.00000000e+00]
  mo_energy =
[-104.89066763  -15.59264992  -12.0162611   -12.0162611   -12.0162611
   -0.38316079   -0.16837768   -0.16837768   -0.16837768]
E1 = -569.6034590721719  E_coul = 127.38133485694914
cycle= 2 E= -442.222124215223  delta_E= 1.71e-13  |g|=    0  |ddm|= 3.78e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -569.6034590721719  E_coul = 127.38133485694914
  mo_energy =
[-104.89066763  -15.59264992  -12.0162611   -12.0162611   -12.0162611
   -0.38316079   -0.16837768   -0.16837768   -0.16837768]
E1 = -569.6034590721721  E_coul = 127.38133485694925
Extra cycle  E= -442.222124215223  delta_E= -1.14e-13  |g|=    0  |ddm|= 4.63e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.7818917207177885
E1 = -569.6034590721721  E_coul = 127.38133485694925
init E= -442.222124215223
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.89066763  -15.59264992  -12.0162611   -12.0162611   -12.0162611
   -0.38316079   -0.16837768   -0.16837768   -0.16837768]
E1 = -569.603459072172  E_coul = 127.3813348569492
cycle= 1 E= -442.222124215223  delta_E= 5.68e-14  |g|=    0  |ddm|= 3.09e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -569.603459072172  E_coul = 127.3813348569492
  mo_energy =
[-104.89066763  -15.59264992  -12.0162611   -12.0162611   -12.0162611
   -0.38316079   -0.16837768   -0.16837768   -0.16837768]
E1 = -569.603459072172  E_coul = 127.3813348569492
Extra cycle  E= -442.222124215223  delta_E=    0  |g|=    0  |ddm|= 4.91e-15
    CPU time for scf_cycle      0.12 sec, wall time      0.12 sec
exp = [9.27739556e+01 4.70775949e+00 3.72978581e-03 7.88954999e+00
 4.05713688e-03]
grad_E = [-3.70996119e-02  3.82052102e-01 -1.59736378e+02 -2.83782933e-01
 -2.43638838e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:31 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  92.1757403186        1
[INPUT] 0    0    [1    /1   ]  4.82657185191        1
[INPUT] 0    0    [1    /1   ]  0.00645711826023      1
[INPUT] 1    0    [1    /1   ]  7.78790759223        1
[INPUT] 1    0    [1    /1   ]  0.00415649914756      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [92.17574031860919, 1.0]], [0, [4.826571851905054, 1.0]], [0, [0.006457118260233851, 1.0]], [1, [7.787907592227674, 1.0]], [1, [0.0041564991475557525, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [92.17574032]
bas 1, expnt(s) = [4.82657185]
bas 2, expnt(s) = [0.00645712]
bas 3, expnt(s) = [7.78790759]
bas 4, expnt(s) = [0.0041565]
CPU time:        85.05
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.21757403e+01 7.51583955e+01 4.82657185e+00 8.22704942e+00
 6.45711826e-03 5.75498346e-02 7.78790759e+00 3.79542470e+01
 4.15649915e-03 3.07888886e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.5543330365261
cond(S) = 1.806757392598483
E1 = -534.043783569138  E_coul = 108.30543111739715
init E= -425.738352451741
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-107.25877812  -17.23384756  -13.63992537  -13.63992537  -13.63992537
   -1.06828877   -0.56940971   -0.56940971   -0.56940971]
E1 = -570.3599269464514  E_coul = 127.84027283548767
cycle= 1 E= -442.519654110964  delta_E= -16.8  |g|=    0  |ddm|= 3.98
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.06427e-14
diis-c [-4.26120041e-28  1.00000000e+00]
  mo_energy =
[-104.95316653  -15.46180808  -11.96092487  -11.96092487  -11.96092487
   -0.56294284   -0.15966619   -0.15966619   -0.15966619]
E1 = -570.3599269464513  E_coul = 127.84027283548762
cycle= 2 E= -442.519654110964  delta_E= 5.68e-14  |g|=    0  |ddm|= 3.02e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -570.3599269464513  E_coul = 127.84027283548762
  mo_energy =
[-104.95316653  -15.46180808  -11.96092487  -11.96092487  -11.96092487
   -0.56294284   -0.15966619   -0.15966619   -0.15966619]
E1 = -570.3599269464513  E_coul = 127.84027283548762
Extra cycle  E= -442.519654110964  delta_E=    0  |g|=    0  |ddm|= 4.78e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [9.21757403e+01 4.82657185e+00 6.45711826e-03 7.78790759e+00
 4.15649915e-03]
E = -442.5196541109637
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:31 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  92.1757403186        1
[INPUT] 0    0    [1    /1   ]  4.82657185191        1
[INPUT] 0    0    [1    /1   ]  0.00645711826023      1
[INPUT] 1    0    [1    /1   ]  7.78790759223        1
[INPUT] 1    0    [1    /1   ]  0.00415649914756      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [92.17574031860919, 1.0]], [0, [4.826571851905054, 1.0]], [0, [0.006457118260233851, 1.0]], [1, [7.787907592227674, 1.0]], [1, [0.0041564991475557525, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [92.17574032]
bas 1, expnt(s) = [4.82657185]
bas 2, expnt(s) = [0.00645712]
bas 3, expnt(s) = [7.78790759]
bas 4, expnt(s) = [0.0041565]
CPU time:        85.49
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.21757403e+01 7.51583955e+01 4.82657185e+00 8.22704942e+00
 6.45711826e-03 5.75498346e-02 7.78790759e+00 3.79542470e+01
 4.15649915e-03 3.07888886e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.5543330365261
cond(S) = 1.806757392598483
E1 = -534.043783569138  E_coul = 108.30543111739715
init E= -425.738352451741
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-107.25877812  -17.23384756  -13.63992537  -13.63992537  -13.63992537
   -1.06828877   -0.56940971   -0.56940971   -0.56940971]
E1 = -570.3599269464514  E_coul = 127.84027283548767
cycle= 1 E= -442.519654110964  delta_E= -16.8  |g|=    0  |ddm|= 3.98
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.06427e-14
diis-c [-4.26120041e-28  1.00000000e+00]
  mo_energy =
[-104.95316653  -15.46180808  -11.96092487  -11.96092487  -11.96092487
   -0.56294284   -0.15966619   -0.15966619   -0.15966619]
E1 = -570.3599269464513  E_coul = 127.84027283548762
cycle= 2 E= -442.519654110964  delta_E= 5.68e-14  |g|=    0  |ddm|= 3.02e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -570.3599269464513  E_coul = 127.84027283548762
  mo_energy =
[-104.95316653  -15.46180808  -11.96092487  -11.96092487  -11.96092487
   -0.56294284   -0.15966619   -0.15966619   -0.15966619]
E1 = -570.3599269464513  E_coul = 127.84027283548762
Extra cycle  E= -442.519654110964  delta_E=    0  |g|=    0  |ddm|= 4.78e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.806757392598483
E1 = -570.3599269464513  E_coul = 127.84027283548762
init E= -442.519654110964
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.95316653  -15.46180808  -11.96092487  -11.96092487  -11.96092487
   -0.56294284   -0.15966619   -0.15966619   -0.15966619]
E1 = -570.3599269464513  E_coul = 127.84027283548765
cycle= 1 E= -442.519654110964  delta_E= 5.68e-14  |g|=    0  |ddm|= 2.75e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -570.3599269464513  E_coul = 127.84027283548765
  mo_energy =
[-104.95316653  -15.46180808  -11.96092487  -11.96092487  -11.96092487
   -0.56294284   -0.15966619   -0.15966619   -0.15966619]
E1 = -570.3599269464514  E_coul = 127.84027283548764
Extra cycle  E= -442.519654110964  delta_E= -1.14e-13  |g|=    0  |ddm|= 1.61e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.21757403e+01 4.82657185e+00 6.45711826e-03 7.78790759e+00
 4.15649915e-03]
grad_E = [-4.99325045e-02  5.23301761e-01 -1.27911181e+02 -3.69138493e-01
 -2.28645638e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:34 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  91.8323381303        1
[INPUT] 0    0    [1    /1   ]  4.91921387181        1
[INPUT] 0    0    [1    /1   ]  0.013254129816       1
[INPUT] 1    0    [1    /1   ]  7.73533608997        1
[INPUT] 1    0    [1    /1   ]  0.00440420058024      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [91.83233813034907, 1.0]], [0, [4.919213871814304, 1.0]], [0, [0.013254129816016681, 1.0]], [1, [7.735336089974975, 1.0]], [1, [0.00440420058024471, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [91.83233813]
bas 1, expnt(s) = [4.91921387]
bas 2, expnt(s) = [0.01325413]
bas 3, expnt(s) = [7.73533609]
bas 4, expnt(s) = [0.0044042]
CPU time:        88.48
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.18323381e+01 7.49482947e+01 4.91921387e+00 8.34520103e+00
 1.32541298e-02 9.86912022e-02 7.73533609e+00 3.76342597e+01
 4.40420058e-03 3.30992577e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.62585496074337
cond(S) = 1.8289443156284901
E1 = -534.042413187597  E_coul = 108.2924468852771
init E= -425.74996630232
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-107.3225444   -17.16091602  -13.62948763  -13.62948763  -13.62948763
   -1.50787467   -0.5809108    -0.5809108    -0.5809108 ]
E1 = -572.3113869251513  E_coul = 129.0992228871198
cycle= 1 E= -443.212164038031  delta_E= -17.5  |g|=    0  |ddm|= 3.95
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.67435e-15
diis-c [-7.15212138e-30  1.00000000e+00]
  mo_energy =
[-104.90146619  -15.27444535  -11.84005338  -11.84005338  -11.84005338
   -0.89962385   -0.15359168   -0.15359168   -0.15359168]
E1 = -572.3113869251512  E_coul = 129.0992228871198
cycle= 2 E= -443.212164038031  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.56e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -572.3113869251512  E_coul = 129.0992228871198
  mo_energy =
[-104.90146619  -15.27444535  -11.84005338  -11.84005338  -11.84005338
   -0.89962385   -0.15359168   -0.15359168   -0.15359168]
E1 = -572.3113869251512  E_coul = 129.09922288711974
Extra cycle  E= -443.212164038031  delta_E= -1.14e-13  |g|=    0  |ddm|= 4.41e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.18323381e+01 4.91921387e+00 1.32541298e-02 7.73533609e+00
 4.40420058e-03]
E = -443.21216403803146
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:35 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  91.8323381303        1
[INPUT] 0    0    [1    /1   ]  4.91921387181        1
[INPUT] 0    0    [1    /1   ]  0.013254129816       1
[INPUT] 1    0    [1    /1   ]  7.73533608997        1
[INPUT] 1    0    [1    /1   ]  0.00440420058024      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [91.83233813034907, 1.0]], [0, [4.919213871814304, 1.0]], [0, [0.013254129816016681, 1.0]], [1, [7.735336089974975, 1.0]], [1, [0.00440420058024471, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [91.83233813]
bas 1, expnt(s) = [4.91921387]
bas 2, expnt(s) = [0.01325413]
bas 3, expnt(s) = [7.73533609]
bas 4, expnt(s) = [0.0044042]
CPU time:        88.92
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.18323381e+01 7.49482947e+01 4.91921387e+00 8.34520103e+00
 1.32541298e-02 9.86912022e-02 7.73533609e+00 3.76342597e+01
 4.40420058e-03 3.30992577e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.62585496074337
cond(S) = 1.8289443156284901
E1 = -534.042413187597  E_coul = 108.2924468852771
init E= -425.74996630232
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-107.3225444   -17.16091602  -13.62948763  -13.62948763  -13.62948763
   -1.50787467   -0.5809108    -0.5809108    -0.5809108 ]
E1 = -572.3113869251513  E_coul = 129.0992228871198
cycle= 1 E= -443.212164038031  delta_E= -17.5  |g|=    0  |ddm|= 3.95
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.67435e-15
diis-c [-7.15212138e-30  1.00000000e+00]
  mo_energy =
[-104.90146619  -15.27444535  -11.84005338  -11.84005338  -11.84005338
   -0.89962385   -0.15359168   -0.15359168   -0.15359168]
E1 = -572.3113869251512  E_coul = 129.0992228871198
cycle= 2 E= -443.212164038031  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.56e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -572.3113869251512  E_coul = 129.0992228871198
  mo_energy =
[-104.90146619  -15.27444535  -11.84005338  -11.84005338  -11.84005338
   -0.89962385   -0.15359168   -0.15359168   -0.15359168]
E1 = -572.3113869251512  E_coul = 129.09922288711974
Extra cycle  E= -443.212164038031  delta_E= -1.14e-13  |g|=    0  |ddm|= 4.41e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.8289443156284901
E1 = -572.3113869251512  E_coul = 129.09922288711974
init E= -443.212164038031
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.90146619  -15.27444535  -11.84005338  -11.84005338  -11.84005338
   -0.89962385   -0.15359168   -0.15359168   -0.15359168]
E1 = -572.3113869251512  E_coul = 129.09922288711974
cycle= 1 E= -443.212164038031  delta_E=    0  |g|=    0  |ddm|= 3.18e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -572.3113869251512  E_coul = 129.09922288711974
  mo_energy =
[-104.90146619  -15.27444535  -11.84005338  -11.84005338  -11.84005338
   -0.89962385   -0.15359168   -0.15359168   -0.15359168]
E1 = -572.3113869251512  E_coul = 129.09922288711974
Extra cycle  E= -443.212164038031  delta_E=    0  |g|=    0  |ddm|= 3.42e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.12 sec
exp = [9.18323381e+01 4.91921387e+00 1.32541298e-02 7.73533609e+00
 4.40420058e-03]
grad_E = [-5.78403890e-02  6.26421854e-01 -9.24849137e+01 -4.11842342e-01
 -2.05060543e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:40 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  92.1943889402        1
[INPUT] 0    0    [1    /1   ]  4.88186441437        1
[INPUT] 0    0    [1    /1   ]  0.0295030859381      1
[INPUT] 1    0    [1    /1   ]  7.80617849872        1
[INPUT] 1    0    [1    /1   ]  0.00499644135925      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [92.19438894021332, 1.0]], [0, [4.881864414373915, 1.0]], [0, [0.029503085938128316, 1.0]], [1, [7.806178498717716, 1.0]], [1, [0.004996441359245363, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [92.19438894]
bas 1, expnt(s) = [4.88186441]
bas 2, expnt(s) = [0.02950309]
bas 3, expnt(s) = [7.8061785]
bas 4, expnt(s) = [0.00499644]
CPU time:        92.68
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.21943889e+01 7.51697995e+01 4.88186441e+00 8.29763466e+00
 2.95030859e-02 1.79852139e-01 7.80617850e+00 3.80655834e+01
 4.99644136e-03 3.87534513e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.84807598699658
cond(S) = 1.8366699773739863
E1 = -535.7228700333026  E_coul = 109.31409255200882
init E= -426.408777481294
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-107.16627304  -17.09113493  -13.5420865   -13.5420865   -13.5420865
   -2.1697884    -0.60135386   -0.60135386   -0.60135386]
E1 = -576.2094864200766  E_coul = 131.62336945243638
cycle= 1 E= -444.58611696764  delta_E= -18.2  |g|=    0  |ddm|= 3.85
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.05399e-14
diis-c [-6.48667129e-27  1.00000000e+00]
  mo_energy =
[-104.62079904  -15.08065666  -11.62469878  -11.62469878  -11.62469878
   -1.43591177   -0.15663665   -0.15663665   -0.15663665]
E1 = -576.2094864200765  E_coul = 131.62336945243632
cycle= 2 E= -444.58611696764  delta_E= 1.14e-13  |g|=    0  |ddm|= 2.31e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -576.2094864200765  E_coul = 131.62336945243632
  mo_energy =
[-104.62079904  -15.08065666  -11.62469878  -11.62469878  -11.62469878
   -1.43591177   -0.15663665   -0.15663665   -0.15663665]
E1 = -576.2094864200765  E_coul = 131.62336945243632
Extra cycle  E= -444.58611696764  delta_E=    0  |g|=    0  |ddm|= 1.53e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [9.21943889e+01 4.88186441e+00 2.95030859e-02 7.80617850e+00
 4.99644136e-03]
E = -444.5861169676401
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:40 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  92.1943889402        1
[INPUT] 0    0    [1    /1   ]  4.88186441437        1
[INPUT] 0    0    [1    /1   ]  0.0295030859381      1
[INPUT] 1    0    [1    /1   ]  7.80617849872        1
[INPUT] 1    0    [1    /1   ]  0.00499644135925      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [92.19438894021332, 1.0]], [0, [4.881864414373915, 1.0]], [0, [0.029503085938128316, 1.0]], [1, [7.806178498717716, 1.0]], [1, [0.004996441359245363, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [92.19438894]
bas 1, expnt(s) = [4.88186441]
bas 2, expnt(s) = [0.02950309]
bas 3, expnt(s) = [7.8061785]
bas 4, expnt(s) = [0.00499644]
CPU time:        93.19
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.21943889e+01 7.51697995e+01 4.88186441e+00 8.29763466e+00
 2.95030859e-02 1.79852139e-01 7.80617850e+00 3.80655834e+01
 4.99644136e-03 3.87534513e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 9.84807598699658
cond(S) = 1.8366699773739863
E1 = -535.7228700333026  E_coul = 109.31409255200882
init E= -426.408777481294
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-107.16627304  -17.09113493  -13.5420865   -13.5420865   -13.5420865
   -2.1697884    -0.60135386   -0.60135386   -0.60135386]
E1 = -576.2094864200766  E_coul = 131.62336945243638
cycle= 1 E= -444.58611696764  delta_E= -18.2  |g|=    0  |ddm|= 3.85
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.05399e-14
diis-c [-6.48667129e-27  1.00000000e+00]
  mo_energy =
[-104.62079904  -15.08065666  -11.62469878  -11.62469878  -11.62469878
   -1.43591177   -0.15663665   -0.15663665   -0.15663665]
E1 = -576.2094864200765  E_coul = 131.62336945243632
cycle= 2 E= -444.58611696764  delta_E= 1.14e-13  |g|=    0  |ddm|= 2.31e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -576.2094864200765  E_coul = 131.62336945243632
  mo_energy =
[-104.62079904  -15.08065666  -11.62469878  -11.62469878  -11.62469878
   -1.43591177   -0.15663665   -0.15663665   -0.15663665]
E1 = -576.2094864200765  E_coul = 131.62336945243632
Extra cycle  E= -444.58611696764  delta_E=    0  |g|=    0  |ddm|= 1.53e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.8366699773739863
E1 = -576.2094864200765  E_coul = 131.62336945243632
init E= -444.58611696764
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-104.62079904  -15.08065666  -11.62469878  -11.62469878  -11.62469878
   -1.43591177   -0.15663665   -0.15663665   -0.15663665]
E1 = -576.2094864200765  E_coul = 131.62336945243632
cycle= 1 E= -444.58611696764  delta_E=    0  |g|=    0  |ddm|= 3.22e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -576.2094864200765  E_coul = 131.62336945243632
  mo_energy =
[-104.62079904  -15.08065666  -11.62469878  -11.62469878  -11.62469878
   -1.43591177   -0.15663665   -0.15663665   -0.15663665]
E1 = -576.2094864200766  E_coul = 131.62336945243638
Extra cycle  E= -444.58611696764  delta_E= -1.14e-13  |g|=    0  |ddm|= 2.59e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.21943889e+01 4.88186441e+00 2.95030859e-02 7.80617850e+00
 4.99644136e-03]
grad_E = [-5.08736670e-02  5.71868327e-01 -5.98208863e+01 -3.47869318e-01
 -1.79460447e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:44 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  93.5086194518        1
[INPUT] 0    0    [1    /1   ]  4.63398259232        1
[INPUT] 0    0    [1    /1   ]  0.0624127442763      1
[INPUT] 1    0    [1    /1   ]  8.03100088506        1
[INPUT] 1    0    [1    /1   ]  0.0061960159026      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [93.50861945183108, 1.0]], [0, [4.633982592318126, 1.0]], [0, [0.06241274427630403, 1.0]], [1, [8.031000885064257, 1.0]], [1, [0.0061960159025986295, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [93.50861945]
bas 1, expnt(s) = [4.63398259]
bas 2, expnt(s) = [0.06241274]
bas 3, expnt(s) = [8.03100089]
bas 4, expnt(s) = [0.00619602]
CPU time:        96.53
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.35086195e+01 7.59720347e+01 4.63398259e+00 7.97959451e+00
 6.24127443e-02 3.15478657e-01 8.03100089e+00 3.94408699e+01
 6.19601590e-03 5.07136708e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 10.296779472391961
cond(S) = 1.8416917250642253
E1 = -540.3769789227492  E_coul = 112.13992102664993
init E= -428.237057896099
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  mo_energy =
[-106.6560031   -16.99813907  -13.29960513  -13.29960513  -13.29960513
   -2.94102108   -0.63062212   -0.63062212   -0.63062212]
E1 = -581.8933577623737  E_coul = 135.3878384772949
cycle= 1 E= -446.505519285079  delta_E= -18.3  |g|=    0  |ddm|= 3.69
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.03902e-14
diis-c [-1.63136447e-27  1.00000000e+00]
  mo_energy =
[-104.06046158  -14.94128366  -11.31996746  -11.31996746  -11.31996746
   -2.0859997    -0.17039769   -0.17039769   -0.17039769]
E1 = -581.8933577623737  E_coul = 135.38783847729493
cycle= 2 E= -446.505519285079  delta_E= 5.68e-14  |g|=    0  |ddm|= 1.81e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -581.8933577623737  E_coul = 135.38783847729493
  mo_energy =
[-104.06046158  -14.94128366  -11.31996746  -11.31996746  -11.31996746
   -2.0859997    -0.17039769   -0.17039769   -0.17039769]
E1 = -581.8933577623737  E_coul = 135.38783847729488
Extra cycle  E= -446.505519285079  delta_E= -1.14e-13  |g|=    0  |ddm|= 1.09e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
exp = [9.35086195e+01 4.63398259e+00 6.24127443e-02 8.03100089e+00
 6.19601590e-03]
E = -446.5055192850789
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:45 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  93.5086194518        1
[INPUT] 0    0    [1    /1   ]  4.63398259232        1
[INPUT] 0    0    [1    /1   ]  0.0624127442763      1
[INPUT] 1    0    [1    /1   ]  8.03100088506        1
[INPUT] 1    0    [1    /1   ]  0.0061960159026      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [93.50861945183108, 1.0]], [0, [4.633982592318126, 1.0]], [0, [0.06241274427630403, 1.0]], [1, [8.031000885064257, 1.0]], [1, [0.0061960159025986295, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [93.50861945]
bas 1, expnt(s) = [4.63398259]
bas 2, expnt(s) = [0.06241274]
bas 3, expnt(s) = [8.03100089]
bas 4, expnt(s) = [0.00619602]
CPU time:        97.07
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.35086195e+01 7.59720347e+01 4.63398259e+00 7.97959451e+00
 6.24127443e-02 3.15478657e-01 8.03100089e+00 3.94408699e+01
 6.19601590e-03 5.07136708e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 10.296779472391961
cond(S) = 1.8416917250642253
E1 = -540.3769789227492  E_coul = 112.13992102664993
init E= -428.237057896099
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  mo_energy =
[-106.6560031   -16.99813907  -13.29960513  -13.29960513  -13.29960513
   -2.94102108   -0.63062212   -0.63062212   -0.63062212]
E1 = -581.8933577623737  E_coul = 135.3878384772949
cycle= 1 E= -446.505519285079  delta_E= -18.3  |g|=    0  |ddm|= 3.69
    CPU time for cycle= 1      0.01 sec, wall time      0.02 sec
diis-norm(errvec)=4.03902e-14
diis-c [-1.63136447e-27  1.00000000e+00]
  mo_energy =
[-104.06046158  -14.94128366  -11.31996746  -11.31996746  -11.31996746
   -2.0859997    -0.17039769   -0.17039769   -0.17039769]
E1 = -581.8933577623737  E_coul = 135.38783847729493
cycle= 2 E= -446.505519285079  delta_E= 5.68e-14  |g|=    0  |ddm|= 1.81e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -581.8933577623737  E_coul = 135.38783847729493
  mo_energy =
[-104.06046158  -14.94128366  -11.31996746  -11.31996746  -11.31996746
   -2.0859997    -0.17039769   -0.17039769   -0.17039769]
E1 = -581.8933577623737  E_coul = 135.38783847729488
Extra cycle  E= -446.505519285079  delta_E= -1.14e-13  |g|=    0  |ddm|= 1.09e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.8416917250642253
E1 = -581.8933577623737  E_coul = 135.38783847729488
init E= -446.505519285079
    CPU time for initialize scf      0.06 sec, wall time      0.06 sec
  mo_energy =
[-104.06046158  -14.94128366  -11.31996746  -11.31996746  -11.31996746
   -2.0859997    -0.17039769   -0.17039769   -0.17039769]
E1 = -581.8933577623737  E_coul = 135.38783847729493
cycle= 1 E= -446.505519285079  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.33e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -581.8933577623737  E_coul = 135.38783847729493
  mo_energy =
[-104.06046158  -14.94128366  -11.31996746  -11.31996746  -11.31996746
   -2.0859997    -0.17039769   -0.17039769   -0.17039769]
E1 = -581.8933577623737  E_coul = 135.38783847729488
Extra cycle  E= -446.505519285079  delta_E= -1.14e-13  |g|=    0  |ddm|= 1.22e-15
    CPU time for scf_cycle      0.12 sec, wall time      0.13 sec
exp = [9.35086195e+01 4.63398259e+00 6.24127443e-02 8.03100089e+00
 6.19601590e-03]
grad_E = [-2.34873608e-02  2.44729017e-01 -3.61296608e+01 -1.59632486e-01
 -1.54944042e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:49 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.3885596671        1
[INPUT] 0    0    [1    /1   ]  4.34584213728        1
[INPUT] 0    0    [1    /1   ]  0.115307007986       1
[INPUT] 1    0    [1    /1   ]  8.32932644177        1
[INPUT] 1    0    [1    /1   ]  0.00812410772673      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.38855966709187, 1.0]], [0, [4.345842137281265, 1.0]], [0, [0.11530700798597873, 1.0]], [1, [8.329326441767009, 1.0]], [1, [0.008124107726733311, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.38855967]
bas 1, expnt(s) = [4.34584214]
bas 2, expnt(s) = [0.11530701]
bas 3, expnt(s) = [8.32932644]
bas 4, expnt(s) = [0.00812411]
CPU time:       100.73
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.53885597e+01 7.71147123e+01 4.34584214e+00 7.60449685e+00
 1.15307008e-01 4.99927240e-01 8.32932644e+00 4.12806709e+01
 8.12410773e-03 7.11547643e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 10.833423356233727
cond(S) = 1.9144996654528894
E1 = -547.3036390720488  E_coul = 116.5718525548757
init E= -430.731786517173
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.90572853  -16.74184401  -12.90250612  -12.90250612  -12.90250612
   -3.61496131   -0.6684017    -0.6684017    -0.6684017 ]
E1 = -588.1133975212946  E_coul = 139.83927962138424
cycle= 1 E= -448.27411789991  delta_E= -17.5  |g|=    0  |ddm|= 3.54
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.09752e-14
diis-c [-1.67896837e-27  1.00000000e+00]
  mo_energy =
[-103.35132906  -14.74470554  -10.95952859  -10.95952859  -10.95952859
   -2.66785312   -0.19164855   -0.19164855   -0.19164855]
E1 = -588.1133975212945  E_coul = 139.83927962138424
cycle= 2 E= -448.27411789991  delta_E= 1.14e-13  |g|=    0  |ddm|= 2.64e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -588.1133975212945  E_coul = 139.83927962138424
  mo_energy =
[-103.35132906  -14.74470554  -10.95952859  -10.95952859  -10.95952859
   -2.66785312   -0.19164855   -0.19164855   -0.19164855]
E1 = -588.1133975212944  E_coul = 139.83927962138412
Extra cycle  E= -448.27411789991  delta_E=    0  |g|=    0  |ddm|= 3.36e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [9.53885597e+01 4.34584214e+00 1.15307008e-01 8.32932644e+00
 8.12410773e-03]
E = -448.27411789991027
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:49 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.3885596671        1
[INPUT] 0    0    [1    /1   ]  4.34584213728        1
[INPUT] 0    0    [1    /1   ]  0.115307007986       1
[INPUT] 1    0    [1    /1   ]  8.32932644177        1
[INPUT] 1    0    [1    /1   ]  0.00812410772673      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.38855966709187, 1.0]], [0, [4.345842137281265, 1.0]], [0, [0.11530700798597873, 1.0]], [1, [8.329326441767009, 1.0]], [1, [0.008124107726733311, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.38855967]
bas 1, expnt(s) = [4.34584214]
bas 2, expnt(s) = [0.11530701]
bas 3, expnt(s) = [8.32932644]
bas 4, expnt(s) = [0.00812411]
CPU time:       101.25
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.53885597e+01 7.71147123e+01 4.34584214e+00 7.60449685e+00
 1.15307008e-01 4.99927240e-01 8.32932644e+00 4.12806709e+01
 8.12410773e-03 7.11547643e-03]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 10.833423356233727
cond(S) = 1.9144996654528894
E1 = -547.3036390720488  E_coul = 116.5718525548757
init E= -430.731786517173
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.90572853  -16.74184401  -12.90250612  -12.90250612  -12.90250612
   -3.61496131   -0.6684017    -0.6684017    -0.6684017 ]
E1 = -588.1133975212946  E_coul = 139.83927962138424
cycle= 1 E= -448.27411789991  delta_E= -17.5  |g|=    0  |ddm|= 3.54
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.09752e-14
diis-c [-1.67896837e-27  1.00000000e+00]
  mo_energy =
[-103.35132906  -14.74470554  -10.95952859  -10.95952859  -10.95952859
   -2.66785312   -0.19164855   -0.19164855   -0.19164855]
E1 = -588.1133975212945  E_coul = 139.83927962138424
cycle= 2 E= -448.27411789991  delta_E= 1.14e-13  |g|=    0  |ddm|= 2.64e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -588.1133975212945  E_coul = 139.83927962138424
  mo_energy =
[-103.35132906  -14.74470554  -10.95952859  -10.95952859  -10.95952859
   -2.66785312   -0.19164855   -0.19164855   -0.19164855]
E1 = -588.1133975212944  E_coul = 139.83927962138412
Extra cycle  E= -448.27411789991  delta_E=    0  |g|=    0  |ddm|= 3.36e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 1.9144996654528894
E1 = -588.1133975212944  E_coul = 139.83927962138412
init E= -448.27411789991
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-103.35132906  -14.74470554  -10.95952859  -10.95952859  -10.95952859
   -2.66785312   -0.19164855   -0.19164855   -0.19164855]
E1 = -588.1133975212944  E_coul = 139.83927962138418
cycle= 1 E= -448.27411789991  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.53e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -588.1133975212944  E_coul = 139.83927962138418
  mo_energy =
[-103.35132906  -14.74470554  -10.95952859  -10.95952859  -10.95952859
   -2.66785312   -0.19164855   -0.19164855   -0.19164855]
E1 = -588.1133975212945  E_coul = 139.83927962138426
Extra cycle  E= -448.27411789991  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.25e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.12 sec
exp = [9.53885597e+01 4.34584214e+00 1.15307008e-01 8.32932644e+00
 8.12410773e-03]
grad_E = [ 1.33856577e-02 -1.89347462e-01 -2.13665934e+01  8.06463434e-02
 -1.31997562e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:53 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  96.9774047457        1
[INPUT] 0    0    [1    /1   ]  4.21959268112        1
[INPUT] 0    0    [1    /1   ]  0.186395469319       1
[INPUT] 1    0    [1    /1   ]  8.573036854          1
[INPUT] 1    0    [1    /1   ]  0.0107154531073      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [96.97740474570745, 1.0]], [0, [4.219592681122236, 1.0]], [0, [0.18639546931941556, 1.0]], [1, [8.573036854003657, 1.0]], [1, [0.010715453107303737, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [96.97740475]
bas 1, expnt(s) = [4.21959268]
bas 2, expnt(s) = [0.18639547]
bas 3, expnt(s) = [8.57303685]
bas 4, expnt(s) = [0.01071545]
CPU time:       104.88
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.69774047e+01 7.80760696e+01 4.21959268e+00 7.43820121e+00
 1.86395469e-01 7.16706822e-01 8.57303685e+00 4.27959583e+01
 1.07154531e-02 1.00576743e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.259410170233666
cond(S) = 2.1007713803897565
E1 = -554.4358321626005  E_coul = 121.37479259414933
init E= -433.061039568451
    CPU time for initialize scf      0.02 sec, wall time      0.03 sec
  mo_energy =
[-105.2080205   -16.34978204  -12.45814594  -12.45814594  -12.45814594
   -4.10360855   -0.71802544   -0.71802544   -0.71802544]
E1 = -594.0000725408738  E_coul = 144.36896898805963
cycle= 1 E= -449.631103552814  delta_E= -16.6  |g|=    0  |ddm|= 3.46
    CPU time for cycle= 1      0.01 sec, wall time      0.02 sec
diis-norm(errvec)=5.61736e-15
diis-c [-3.15547251e-29  1.00000000e+00]
  mo_energy =
[-102.71762746  -14.43745792  -10.58339999  -10.58339999  -10.58339999
   -3.07703389   -0.21624935   -0.21624935   -0.21624935]
E1 = -594.0000725408738  E_coul = 144.36896898805966
cycle= 2 E= -449.631103552814  delta_E= 5.68e-14  |g|=    0  |ddm|= 2.92e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -594.0000725408738  E_coul = 144.36896898805966
  mo_energy =
[-102.71762746  -14.43745792  -10.58339999  -10.58339999  -10.58339999
   -3.07703389   -0.21624935   -0.21624935   -0.21624935]
E1 = -594.0000725408738  E_coul = 144.36896898805963
Extra cycle  E= -449.631103552814  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.63e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.09 sec
exp = [9.69774047e+01 4.21959268e+00 1.86395469e-01 8.57303685e+00
 1.07154531e-02]
E = -449.6311035528142
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:54 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  96.9774047457        1
[INPUT] 0    0    [1    /1   ]  4.21959268112        1
[INPUT] 0    0    [1    /1   ]  0.186395469319       1
[INPUT] 1    0    [1    /1   ]  8.573036854          1
[INPUT] 1    0    [1    /1   ]  0.0107154531073      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [96.97740474570745, 1.0]], [0, [4.219592681122236, 1.0]], [0, [0.18639546931941556, 1.0]], [1, [8.573036854003657, 1.0]], [1, [0.010715453107303737, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [96.97740475]
bas 1, expnt(s) = [4.21959268]
bas 2, expnt(s) = [0.18639547]
bas 3, expnt(s) = [8.57303685]
bas 4, expnt(s) = [0.01071545]
CPU time:       105.51
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.69774047e+01 7.80760696e+01 4.21959268e+00 7.43820121e+00
 1.86395469e-01 7.16706822e-01 8.57303685e+00 4.27959583e+01
 1.07154531e-02 1.00576743e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.259410170233666
cond(S) = 2.1007713803897565
E1 = -554.4358321626005  E_coul = 121.37479259414933
init E= -433.061039568451
    CPU time for initialize scf      0.02 sec, wall time      0.04 sec
  mo_energy =
[-105.2080205   -16.34978204  -12.45814594  -12.45814594  -12.45814594
   -4.10360855   -0.71802544   -0.71802544   -0.71802544]
E1 = -594.0000725408738  E_coul = 144.36896898805963
cycle= 1 E= -449.631103552814  delta_E= -16.6  |g|=    0  |ddm|= 3.46
    CPU time for cycle= 1      0.01 sec, wall time      0.02 sec
diis-norm(errvec)=5.61736e-15
diis-c [-3.15547251e-29  1.00000000e+00]
  mo_energy =
[-102.71762746  -14.43745792  -10.58339999  -10.58339999  -10.58339999
   -3.07703389   -0.21624935   -0.21624935   -0.21624935]
E1 = -594.0000725408738  E_coul = 144.36896898805966
cycle= 2 E= -449.631103552814  delta_E= 5.68e-14  |g|=    0  |ddm|= 2.92e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -594.0000725408738  E_coul = 144.36896898805966
  mo_energy =
[-102.71762746  -14.43745792  -10.58339999  -10.58339999  -10.58339999
   -3.07703389   -0.21624935   -0.21624935   -0.21624935]
E1 = -594.0000725408738  E_coul = 144.36896898805963
Extra cycle  E= -449.631103552814  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.63e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.09 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.1007713803897565
E1 = -594.0000725408738  E_coul = 144.36896898805963
init E= -449.631103552814
    CPU time for initialize scf      0.06 sec, wall time      0.08 sec
  mo_energy =
[-102.71762746  -14.43745792  -10.58339999  -10.58339999  -10.58339999
   -3.07703389   -0.21624935   -0.21624935   -0.21624935]
E1 = -594.0000725408738  E_coul = 144.3689689880596
cycle= 1 E= -449.631103552814  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.66e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -594.0000725408738  E_coul = 144.3689689880596
  mo_energy =
[-102.71762746  -14.43745792  -10.58339999  -10.58339999  -10.58339999
   -3.07703389   -0.21624935   -0.21624935   -0.21624935]
E1 = -594.0000725408738  E_coul = 144.36896898805963
Extra cycle  E= -449.631103552814  delta_E= 5.68e-14  |g|=    0  |ddm|= 2.4e-15
    CPU time for scf_cycle      0.14 sec, wall time      0.19 sec
exp = [9.69774047e+01 4.21959268e+00 1.86395469e-01 8.57303685e+00
 1.07154531e-02]
grad_E = [ 4.07537417e-02 -4.30812467e-01 -1.25657913e+01  2.76880156e-01
 -1.12517154e+02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:59 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  97.6415305799        1
[INPUT] 0    0    [1    /1   ]  4.23006810654        1
[INPUT] 0    0    [1    /1   ]  0.287625347169       1
[INPUT] 1    0    [1    /1   ]  8.67393034372        1
[INPUT] 1    0    [1    /1   ]  0.0144055471318      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [97.64153057994014, 1.0]], [0, [4.230068106535619, 1.0]], [0, [0.2876253471686979, 1.0]], [1, [8.673930343717844, 1.0]], [1, [0.01440554713183681, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [97.64153058]
bas 1, expnt(s) = [4.23006811]
bas 2, expnt(s) = [0.28762535]
bas 3, expnt(s) = [8.67393034]
bas 4, expnt(s) = [0.01440555]
CPU time:       109.47
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.76415306e+01 7.84767408e+01 4.23006811e+00 7.45204629e+00
 2.87625347e-01 9.92282635e-01 8.67393034e+00 4.34264477e+01
 1.44055471e-02 1.45595043e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.544534938344148
cond(S) = 2.433982246198461
E1 = -560.7787086662266  E_coul = 125.69727807735413
init E= -435.081430588873
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.72808603  -15.95253275  -12.04504268  -12.04504268  -12.04504268
   -4.45905487   -0.79296303   -0.79296303   -0.79296303]
E1 = -599.7288799730753  E_coul = 148.84474020647403
cycle= 1 E= -450.884139766601  delta_E= -15.8  |g|=    0  |ddm|= 3.42
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=5.90648e-15
diis-c [-3.48865234e-29  1.00000000e+00]
  mo_energy =
[-102.26781539  -14.08091305  -10.20345315  -10.20345315  -10.20345315
   -3.32402194   -0.24552998   -0.24552998   -0.24552998]
E1 = -599.7288799730755  E_coul = 148.8447402064741
cycle= 2 E= -450.884139766601  delta_E= -1.71e-13  |g|=    0  |ddm|= 3.31e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -599.7288799730755  E_coul = 148.8447402064741
  mo_energy =
[-102.26781539  -14.08091305  -10.20345315  -10.20345315  -10.20345315
   -3.32402194   -0.24552998   -0.24552998   -0.24552998]
E1 = -599.7288799730754  E_coul = 148.84474020647403
Extra cycle  E= -450.884139766601  delta_E= 5.68e-14  |g|=    0  |ddm|= 3.31e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [9.76415306e+01 4.23006811e+00 2.87625347e-01 8.67393034e+00
 1.44055471e-02]
E = -450.8841397666014
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:11:59 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  97.6415305799        1
[INPUT] 0    0    [1    /1   ]  4.23006810654        1
[INPUT] 0    0    [1    /1   ]  0.287625347169       1
[INPUT] 1    0    [1    /1   ]  8.67393034372        1
[INPUT] 1    0    [1    /1   ]  0.0144055471318      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [97.64153057994014, 1.0]], [0, [4.230068106535619, 1.0]], [0, [0.2876253471686979, 1.0]], [1, [8.673930343717844, 1.0]], [1, [0.01440554713183681, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [97.64153058]
bas 1, expnt(s) = [4.23006811]
bas 2, expnt(s) = [0.28762535]
bas 3, expnt(s) = [8.67393034]
bas 4, expnt(s) = [0.01440555]
CPU time:       110.04
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.76415306e+01 7.84767408e+01 4.23006811e+00 7.45204629e+00
 2.87625347e-01 9.92282635e-01 8.67393034e+00 4.34264477e+01
 1.44055471e-02 1.45595043e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.544534938344148
cond(S) = 2.433982246198461
E1 = -560.7787086662266  E_coul = 125.69727807735413
init E= -435.081430588873
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  mo_energy =
[-104.72808603  -15.95253275  -12.04504268  -12.04504268  -12.04504268
   -4.45905487   -0.79296303   -0.79296303   -0.79296303]
E1 = -599.7288799730753  E_coul = 148.84474020647403
cycle= 1 E= -450.884139766601  delta_E= -15.8  |g|=    0  |ddm|= 3.42
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=5.90648e-15
diis-c [-3.48865234e-29  1.00000000e+00]
  mo_energy =
[-102.26781539  -14.08091305  -10.20345315  -10.20345315  -10.20345315
   -3.32402194   -0.24552998   -0.24552998   -0.24552998]
E1 = -599.7288799730755  E_coul = 148.8447402064741
cycle= 2 E= -450.884139766601  delta_E= -1.71e-13  |g|=    0  |ddm|= 3.31e-15
    CPU time for cycle= 2      0.02 sec, wall time      0.02 sec
E1 = -599.7288799730755  E_coul = 148.8447402064741
  mo_energy =
[-102.26781539  -14.08091305  -10.20345315  -10.20345315  -10.20345315
   -3.32402194   -0.24552998   -0.24552998   -0.24552998]
E1 = -599.7288799730754  E_coul = 148.84474020647403
Extra cycle  E= -450.884139766601  delta_E= 5.68e-14  |g|=    0  |ddm|= 3.31e-15
    CPU time for scf_cycle      0.07 sec, wall time      0.08 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.433982246198461
E1 = -599.7288799730754  E_coul = 148.84474020647403
init E= -450.884139766601
    CPU time for initialize scf      0.08 sec, wall time      0.09 sec
  mo_energy =
[-102.26781539  -14.08091305  -10.20345315  -10.20345315  -10.20345315
   -3.32402194   -0.24552998   -0.24552998   -0.24552998]
E1 = -599.7288799730755  E_coul = 148.8447402064741
cycle= 1 E= -450.884139766601  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.97e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.02 sec
E1 = -599.7288799730755  E_coul = 148.8447402064741
  mo_energy =
[-102.26781539  -14.08091305  -10.20345315  -10.20345315  -10.20345315
   -3.32402194   -0.24552998   -0.24552998   -0.24552998]
E1 = -599.7288799730754  E_coul = 148.84474020647403
Extra cycle  E= -450.884139766601  delta_E= 5.68e-14  |g|=    0  |ddm|= 4.24e-15
    CPU time for scf_cycle      0.17 sec, wall time      0.19 sec
exp = [9.76415306e+01 4.23006811e+00 2.87625347e-01 8.67393034e+00
 1.44055471e-02]
grad_E = [ 4.92021155e-02 -4.63608794e-01 -6.53396920e+00  3.65539529e-01
 -9.47546674e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:05 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  97.1654535888        1
[INPUT] 0    0    [1    /1   ]  4.34336712286        1
[INPUT] 0    0    [1    /1   ]  0.432067867427       1
[INPUT] 1    0    [1    /1   ]  8.55377391485        1
[INPUT] 1    0    [1    /1   ]  0.0196708772343      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [97.16545358879681, 1.0]], [0, [4.34336712286207, 1.0]], [0, [0.4320678674274544, 1.0]], [1, [8.553773914850131, 1.0]], [1, [0.019670877234335228, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [97.16545359]
bas 1, expnt(s) = [4.34336712]
bas 2, expnt(s) = [0.43206787]
bas 3, expnt(s) = [8.55377391]
bas 4, expnt(s) = [0.01967088]
CPU time:       114.30
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.71654536e+01 7.81895900e+01 4.34336712e+00 7.60124847e+00
 4.32067867e-01 1.34641519e+00 8.55377391e+00 4.26757932e+01
 1.96708772e-02 2.14913676e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.667899429375815
cond(S) = 2.9653137854302383
E1 = -564.7226138449377  E_coul = 128.3417860492977
init E= -436.38082779564
    CPU time for initialize scf      0.03 sec, wall time      0.07 sec
  mo_energy =
[-104.6334164   -15.68479626  -11.7762102   -11.7762102   -11.7762102
   -4.65086903   -0.90522308   -0.90522308   -0.90522308]
E1 = -604.9463532450919  E_coul = 152.90100224469495
cycle= 1 E= -452.045351000397  delta_E= -15.7  |g|=    0  |ddm|= 3.38
    CPU time for cycle= 1      0.01 sec, wall time      0.04 sec
diis-norm(errvec)=4.42608e-14
diis-c [-1.95902063e-27  1.00000000e+00]
  mo_energy =
[-102.09044245  -13.73512717   -9.85483925   -9.85483925   -9.85483925
   -3.34333495   -0.27958402   -0.27958402   -0.27958402]
E1 = -604.9463532450912  E_coul = 152.90100224469478
cycle= 2 E= -452.045351000396  delta_E= 5.12e-13  |g|=    0  |ddm|= 5.3e-15
    CPU time for cycle= 2      0.02 sec, wall time      0.03 sec
E1 = -604.9463532450912  E_coul = 152.90100224469478
  mo_energy =
[-102.09044245  -13.73512717   -9.85483925   -9.85483925   -9.85483925
   -3.34333495   -0.27958402   -0.27958402   -0.27958402]
E1 = -604.9463532450917  E_coul = 152.9010022446949
Extra cycle  E= -452.045351000397  delta_E= -3.41e-13  |g|=    0  |ddm|= 4.34e-15
    CPU time for scf_cycle      0.07 sec, wall time      0.15 sec
exp = [9.71654536e+01 4.34336712e+00 4.32067867e-01 8.55377391e+00
 1.96708772e-02]
E = -452.0453510003968
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:06 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  97.1654535888        1
[INPUT] 0    0    [1    /1   ]  4.34336712286        1
[INPUT] 0    0    [1    /1   ]  0.432067867427       1
[INPUT] 1    0    [1    /1   ]  8.55377391485        1
[INPUT] 1    0    [1    /1   ]  0.0196708772343      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [97.16545358879681, 1.0]], [0, [4.34336712286207, 1.0]], [0, [0.4320678674274544, 1.0]], [1, [8.553773914850131, 1.0]], [1, [0.019670877234335228, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [97.16545359]
bas 1, expnt(s) = [4.34336712]
bas 2, expnt(s) = [0.43206787]
bas 3, expnt(s) = [8.55377391]
bas 4, expnt(s) = [0.01967088]
CPU time:       114.95
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.71654536e+01 7.81895900e+01 4.34336712e+00 7.60124847e+00
 4.32067867e-01 1.34641519e+00 8.55377391e+00 4.26757932e+01
 1.96708772e-02 2.14913676e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.667899429375815
cond(S) = 2.9653137854302383
E1 = -564.7226138449377  E_coul = 128.3417860492977
init E= -436.38082779564
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.6334164   -15.68479626  -11.7762102   -11.7762102   -11.7762102
   -4.65086903   -0.90522308   -0.90522308   -0.90522308]
E1 = -604.9463532450919  E_coul = 152.90100224469495
cycle= 1 E= -452.045351000397  delta_E= -15.7  |g|=    0  |ddm|= 3.38
    CPU time for cycle= 1      0.01 sec, wall time      0.02 sec
diis-norm(errvec)=4.42608e-14
diis-c [-1.95902063e-27  1.00000000e+00]
  mo_energy =
[-102.09044245  -13.73512717   -9.85483925   -9.85483925   -9.85483925
   -3.34333495   -0.27958402   -0.27958402   -0.27958402]
E1 = -604.9463532450912  E_coul = 152.90100224469478
cycle= 2 E= -452.045351000396  delta_E= 5.12e-13  |g|=    0  |ddm|= 5.3e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -604.9463532450912  E_coul = 152.90100224469478
  mo_energy =
[-102.09044245  -13.73512717   -9.85483925   -9.85483925   -9.85483925
   -3.34333495   -0.27958402   -0.27958402   -0.27958402]
E1 = -604.9463532450917  E_coul = 152.9010022446949
Extra cycle  E= -452.045351000397  delta_E= -3.41e-13  |g|=    0  |ddm|= 4.34e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.08 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.9653137854302383
E1 = -604.9463532450917  E_coul = 152.9010022446949
init E= -452.045351000397
    CPU time for initialize scf      0.06 sec, wall time      0.07 sec
  mo_energy =
[-102.09044245  -13.73512717   -9.85483925   -9.85483925   -9.85483925
   -3.34333495   -0.27958402   -0.27958402   -0.27958402]
E1 = -604.9463532450917  E_coul = 152.90100224469487
cycle= 1 E= -452.045351000397  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.14e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -604.9463532450917  E_coul = 152.90100224469487
  mo_energy =
[-102.09044245  -13.73512717   -9.85483925   -9.85483925   -9.85483925
   -3.34333495   -0.27958402   -0.27958402   -0.27958402]
E1 = -604.9463532450919  E_coul = 152.901002244695
Extra cycle  E= -452.045351000397  delta_E= -5.68e-14  |g|=    0  |ddm|= 4.21e-15
    CPU time for scf_cycle      0.14 sec, wall time      0.16 sec
exp = [9.71654536e+01 4.34336712e+00 4.32067867e-01 8.55377391e+00
 1.96708772e-02]
grad_E = [ 3.60956359e-02 -3.13912004e-01 -2.32176277e+00  2.89283706e-01
 -7.87810372e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:10 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  96.0471195856        1
[INPUT] 0    0    [1    /1   ]  4.48589509403        1
[INPUT] 0    0    [1    /1   ]  0.595018043909       1
[INPUT] 1    0    [1    /1   ]  8.2859630856         1
[INPUT] 1    0    [1    /1   ]  0.0256108942686      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [96.04711958561899, 1.0]], [0, [4.485895094034524, 1.0]], [0, [0.595018043909421, 1.0]], [1, [8.285963085600745, 1.0]], [1, [0.025610894268585108, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [96.04711959]
bas 1, expnt(s) = [4.48589509]
bas 2, expnt(s) = [0.59501804]
bas 3, expnt(s) = [8.28596309]
bas 4, expnt(s) = [0.02561089]
CPU time:       118.88
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.60471196e+01 7.75136670e+01 4.48589509e+00 7.78756813e+00
 5.95018044e-01 1.71164078e+00 8.28596309e+00 4.10122065e+01
 2.56108943e-02 2.98892709e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.671451370341881
cond(S) = 3.623532381252662
E1 = -565.2170195210997  E_coul = 128.63080091986552
init E= -436.586218601234
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.88973386  -15.63316187  -11.71511818  -11.71511818  -11.71511818
   -4.63890182   -1.03117116   -1.03117116   -1.03117116]
E1 = -608.5856987869267  E_coul = 155.84555291026868
cycle= 1 E= -452.740145876658  delta_E= -16.2  |g|=    0  |ddm|= 3.32
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.07275e-14
diis-c [-1.6587279e-27  1.0000000e+00]
  mo_energy =
[-102.12988656  -13.48452756   -9.59272257   -9.59272257   -9.59272257
   -3.12222794   -0.31082891   -0.31082891   -0.31082891]
E1 = -608.5856987869269  E_coul = 155.84555291026868
cycle= 2 E= -452.740145876658  delta_E= -1.14e-13  |g|=    0  |ddm|= 2.37e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -608.5856987869269  E_coul = 155.84555291026868
  mo_energy =
[-102.12988656  -13.48452756   -9.59272257   -9.59272257   -9.59272257
   -3.12222794   -0.31082891   -0.31082891   -0.31082891]
E1 = -608.5856987869267  E_coul = 155.8455529102687
Extra cycle  E= -452.740145876658  delta_E= 1.14e-13  |g|=    0  |ddm|= 4.38e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [9.60471196e+01 4.48589509e+00 5.95018044e-01 8.28596309e+00
 2.56108943e-02]
E = -452.74014587665806
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:11 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  96.0471195856        1
[INPUT] 0    0    [1    /1   ]  4.48589509403        1
[INPUT] 0    0    [1    /1   ]  0.595018043909       1
[INPUT] 1    0    [1    /1   ]  8.2859630856         1
[INPUT] 1    0    [1    /1   ]  0.0256108942686      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [96.04711958561899, 1.0]], [0, [4.485895094034524, 1.0]], [0, [0.595018043909421, 1.0]], [1, [8.285963085600745, 1.0]], [1, [0.025610894268585108, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [96.04711959]
bas 1, expnt(s) = [4.48589509]
bas 2, expnt(s) = [0.59501804]
bas 3, expnt(s) = [8.28596309]
bas 4, expnt(s) = [0.02561089]
CPU time:       119.49
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.60471196e+01 7.75136670e+01 4.48589509e+00 7.78756813e+00
 5.95018044e-01 1.71164078e+00 8.28596309e+00 4.10122065e+01
 2.56108943e-02 2.98892709e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.671451370341881
cond(S) = 3.623532381252662
E1 = -565.2170195210997  E_coul = 128.63080091986552
init E= -436.586218601234
    CPU time for initialize scf      0.02 sec, wall time      0.03 sec
  mo_energy =
[-104.88973386  -15.63316187  -11.71511818  -11.71511818  -11.71511818
   -4.63890182   -1.03117116   -1.03117116   -1.03117116]
E1 = -608.5856987869267  E_coul = 155.84555291026868
cycle= 1 E= -452.740145876658  delta_E= -16.2  |g|=    0  |ddm|= 3.32
    CPU time for cycle= 1      0.01 sec, wall time      0.02 sec
diis-norm(errvec)=4.07275e-14
diis-c [-1.6587279e-27  1.0000000e+00]
  mo_energy =
[-102.12988656  -13.48452756   -9.59272257   -9.59272257   -9.59272257
   -3.12222794   -0.31082891   -0.31082891   -0.31082891]
E1 = -608.5856987869269  E_coul = 155.84555291026868
cycle= 2 E= -452.740145876658  delta_E= -1.14e-13  |g|=    0  |ddm|= 2.37e-15
    CPU time for cycle= 2      0.02 sec, wall time      0.02 sec
E1 = -608.5856987869269  E_coul = 155.84555291026868
  mo_energy =
[-102.12988656  -13.48452756   -9.59272257   -9.59272257   -9.59272257
   -3.12222794   -0.31082891   -0.31082891   -0.31082891]
E1 = -608.5856987869267  E_coul = 155.8455529102687
Extra cycle  E= -452.740145876658  delta_E= 1.14e-13  |g|=    0  |ddm|= 4.38e-15
    CPU time for scf_cycle      0.07 sec, wall time      0.08 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 3.623532381252662
E1 = -608.5856987869267  E_coul = 155.8455529102687
init E= -452.740145876658
    CPU time for initialize scf      0.06 sec, wall time      0.08 sec
  mo_energy =
[-102.12988656  -13.48452756   -9.59272257   -9.59272257   -9.59272257
   -3.12222794   -0.31082891   -0.31082891   -0.31082891]
E1 = -608.5856987869266  E_coul = 155.84555291026868
cycle= 1 E= -452.740145876658  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.61e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -608.5856987869266  E_coul = 155.84555291026868
  mo_energy =
[-102.12988656  -13.48452756   -9.59272257   -9.59272257   -9.59272257
   -3.12222794   -0.31082891   -0.31082891   -0.31082891]
E1 = -608.5856987869267  E_coul = 155.84555291026868
Extra cycle  E= -452.740145876658  delta_E= -1.14e-13  |g|=    0  |ddm|= 4.45e-15
    CPU time for scf_cycle      0.14 sec, wall time      0.18 sec
exp = [9.60471196e+01 4.48589509e+00 5.95018044e-01 8.28596309e+00
 2.56108943e-02]
grad_E = [ 1.12314120e-02 -8.58022960e-02  1.48377839e-01  9.37441039e-02
 -6.70711093e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:15 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.345107037         1
[INPUT] 0    0    [1    /1   ]  4.56349851203        1
[INPUT] 0    0    [1    /1   ]  0.71756281986        1
[INPUT] 1    0    [1    /1   ]  8.11233726019        1
[INPUT] 1    0    [1    /1   ]  0.030078050464       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.34510703703371, 1.0]], [0, [4.5634985120293585, 1.0]], [0, [0.7175628198604316, 1.0]], [1, [8.112337260188918, 1.0]], [1, [0.030078050464040225, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.34510704]
bas 1, expnt(s) = [4.56349851]
bas 2, expnt(s) = [0.71756282]
bas 3, expnt(s) = [8.11233726]
bas 4, expnt(s) = [0.03007805]
CPU time:       123.17
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.53451070e+01 7.70883646e+01 4.56349851e+00 7.88839155e+00
 7.17562820e-01 1.96974483e+00 8.11233726e+00 3.99408120e+01
 3.00780505e-02 3.65423520e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.653791375034887
cond(S) = 4.175316325022383
E1 = -564.4114785162634  E_coul = 128.12542133456043
init E= -436.286057181703
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.12343747  -15.67696419  -11.73707032  -11.73707032  -11.73707032
   -4.53535876   -1.12140345   -1.12140345   -1.12140345]
E1 = -610.6233695655917  E_coul = 157.6822324695572
cycle= 1 E= -452.941137096034  delta_E= -16.7  |g|=    0  |ddm|= 3.31
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.1937e-14
diis-c [-5.17493216e-27  1.00000000e+00]
  mo_energy =
[-102.15265742  -13.34433873   -9.4259569    -9.4259569    -9.4259569
   -2.86219792   -0.33079585   -0.33079585   -0.33079585]
E1 = -610.623369565592  E_coul = 157.6822324695573
cycle= 2 E= -452.941137096035  delta_E= -2.27e-13  |g|=    0  |ddm|= 3.2e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -610.623369565592  E_coul = 157.6822324695573
  mo_energy =
[-102.15265742  -13.34433873   -9.4259569    -9.4259569    -9.4259569
   -2.86219792   -0.33079585   -0.33079585   -0.33079585]
E1 = -610.6233695655918  E_coul = 157.68223246955725
Extra cycle  E= -452.941137096035  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.41e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.53451070e+01 4.56349851e+00 7.17562820e-01 8.11233726e+00
 3.00780505e-02]
E = -452.9411370960346
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:16 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.345107037         1
[INPUT] 0    0    [1    /1   ]  4.56349851203        1
[INPUT] 0    0    [1    /1   ]  0.71756281986        1
[INPUT] 1    0    [1    /1   ]  8.11233726019        1
[INPUT] 1    0    [1    /1   ]  0.030078050464       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.34510703703371, 1.0]], [0, [4.5634985120293585, 1.0]], [0, [0.7175628198604316, 1.0]], [1, [8.112337260188918, 1.0]], [1, [0.030078050464040225, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.34510704]
bas 1, expnt(s) = [4.56349851]
bas 2, expnt(s) = [0.71756282]
bas 3, expnt(s) = [8.11233726]
bas 4, expnt(s) = [0.03007805]
CPU time:       123.80
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.53451070e+01 7.70883646e+01 4.56349851e+00 7.88839155e+00
 7.17562820e-01 1.96974483e+00 8.11233726e+00 3.99408120e+01
 3.00780505e-02 3.65423520e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.653791375034887
cond(S) = 4.175316325022383
E1 = -564.4114785162634  E_coul = 128.12542133456043
init E= -436.286057181703
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.12343747  -15.67696419  -11.73707032  -11.73707032  -11.73707032
   -4.53535876   -1.12140345   -1.12140345   -1.12140345]
E1 = -610.6233695655917  E_coul = 157.6822324695572
cycle= 1 E= -452.941137096034  delta_E= -16.7  |g|=    0  |ddm|= 3.31
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=7.1937e-14
diis-c [-5.17493216e-27  1.00000000e+00]
  mo_energy =
[-102.15265742  -13.34433873   -9.4259569    -9.4259569    -9.4259569
   -2.86219792   -0.33079585   -0.33079585   -0.33079585]
E1 = -610.623369565592  E_coul = 157.6822324695573
cycle= 2 E= -452.941137096035  delta_E= -2.27e-13  |g|=    0  |ddm|= 3.2e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -610.623369565592  E_coul = 157.6822324695573
  mo_energy =
[-102.15265742  -13.34433873   -9.4259569    -9.4259569    -9.4259569
   -2.86219792   -0.33079585   -0.33079585   -0.33079585]
E1 = -610.6233695655918  E_coul = 157.68223246955725
Extra cycle  E= -452.941137096035  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.41e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 4.175316325022383
E1 = -610.6233695655918  E_coul = 157.68223246955725
init E= -452.941137096035
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-102.15265742  -13.34433873   -9.4259569    -9.4259569    -9.4259569
   -2.86219792   -0.33079585   -0.33079585   -0.33079585]
E1 = -610.6233695655919  E_coul = 157.68223246955728
cycle= 1 E= -452.941137096035  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.17e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -610.6233695655919  E_coul = 157.68223246955728
  mo_energy =
[-102.15265742  -13.34433873   -9.4259569    -9.4259569    -9.4259569
   -2.86219792   -0.33079585   -0.33079585   -0.33079585]
E1 = -610.623369565592  E_coul = 157.6822324695573
Extra cycle  E= -452.941137096035  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.11e-15
    CPU time for scf_cycle      0.12 sec, wall time      0.12 sec
exp = [9.53451070e+01 4.56349851e+00 7.17562820e-01 8.11233726e+00
 3.00780505e-02]
grad_E = [-4.81413121e-03  6.42676264e-02  1.28047534e+00 -3.65865663e-02
 -6.06449552e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:20 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.2032107826        1
[INPUT] 0    0    [1    /1   ]  4.56233462799        1
[INPUT] 0    0    [1    /1   ]  0.785021286581       1
[INPUT] 1    0    [1    /1   ]  8.0739638341         1
[INPUT] 1    0    [1    /1   ]  0.0325371648536      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.20321078263594, 1.0]], [0, [4.562334627993239, 1.0]], [0, [0.7850212865809499, 1.0]], [1, [8.07396383410166, 1.0]], [1, [0.032537164853623526, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.20321078]
bas 1, expnt(s) = [4.56233463]
bas 2, expnt(s) = [0.78502129]
bas 3, expnt(s) = [8.07396383]
bas 4, expnt(s) = [0.03253716]
CPU time:       127.61
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.52032108e+01 7.70023042e+01 4.56233463e+00 7.88688260e+00
 7.85021287e-01 2.10705610e+00 8.07396383e+00 3.97047890e+01
 3.25371649e-02 4.03142911e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.648703928710663
cond(S) = 4.528347877398245
E1 = -563.9739687585528  E_coul = 127.91648768628896
init E= -436.057481072264
    CPU time for initialize scf      0.03 sec, wall time      0.04 sec
  mo_energy =
[-105.19286787  -15.71234004  -11.75079759  -11.75079759  -11.75079759
   -4.4587024    -1.16818888   -1.16818888   -1.16818888]
E1 = -611.7402396733731  E_coul = 158.75833448824517
cycle= 1 E= -452.981905185128  delta_E= -16.9  |g|=    0  |ddm|= 3.31
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.31539e-14
diis-c [-5.36104001e-28  1.00000000e+00]
  mo_energy =
[-102.10365602  -13.27886305   -9.333773     -9.333773     -9.333773
   -2.70562251   -0.34077492   -0.34077492   -0.34077492]
E1 = -611.7402396733731  E_coul = 158.75833448824525
cycle= 2 E= -452.981905185128  delta_E= 1.14e-13  |g|=    0  |ddm|= 4.62e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.03 sec
E1 = -611.7402396733731  E_coul = 158.75833448824525
  mo_energy =
[-102.10365602  -13.27886305   -9.333773     -9.333773     -9.333773
   -2.70562251   -0.34077492   -0.34077492   -0.34077492]
E1 = -611.740239673373  E_coul = 158.75833448824517
Extra cycle  E= -452.981905185128  delta_E=    0  |g|=    0  |ddm|= 2.29e-15
    CPU time for scf_cycle      0.07 sec, wall time      0.09 sec
exp = [9.52032108e+01 4.56233463e+00 7.85021287e-01 8.07396383e+00
 3.25371649e-02]
E = -452.98190518512786
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:22 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.2032107826        1
[INPUT] 0    0    [1    /1   ]  4.56233462799        1
[INPUT] 0    0    [1    /1   ]  0.785021286581       1
[INPUT] 1    0    [1    /1   ]  8.0739638341         1
[INPUT] 1    0    [1    /1   ]  0.0325371648536      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.20321078263594, 1.0]], [0, [4.562334627993239, 1.0]], [0, [0.7850212865809499, 1.0]], [1, [8.07396383410166, 1.0]], [1, [0.032537164853623526, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.20321078]
bas 1, expnt(s) = [4.56233463]
bas 2, expnt(s) = [0.78502129]
bas 3, expnt(s) = [8.07396383]
bas 4, expnt(s) = [0.03253716]
CPU time:       128.34
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.52032108e+01 7.70023042e+01 4.56233463e+00 7.88688260e+00
 7.85021287e-01 2.10705610e+00 8.07396383e+00 3.97047890e+01
 3.25371649e-02 4.03142911e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.648703928710663
cond(S) = 4.528347877398245
E1 = -563.9739687585528  E_coul = 127.91648768628896
init E= -436.057481072264
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.19286787  -15.71234004  -11.75079759  -11.75079759  -11.75079759
   -4.4587024    -1.16818888   -1.16818888   -1.16818888]
E1 = -611.7402396733731  E_coul = 158.75833448824517
cycle= 1 E= -452.981905185128  delta_E= -16.9  |g|=    0  |ddm|= 3.31
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.31539e-14
diis-c [-5.36104001e-28  1.00000000e+00]
  mo_energy =
[-102.10365602  -13.27886305   -9.333773     -9.333773     -9.333773
   -2.70562251   -0.34077492   -0.34077492   -0.34077492]
E1 = -611.7402396733731  E_coul = 158.75833448824525
cycle= 2 E= -452.981905185128  delta_E= 1.14e-13  |g|=    0  |ddm|= 4.62e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -611.7402396733731  E_coul = 158.75833448824525
  mo_energy =
[-102.10365602  -13.27886305   -9.333773     -9.333773     -9.333773
   -2.70562251   -0.34077492   -0.34077492   -0.34077492]
E1 = -611.740239673373  E_coul = 158.75833448824517
Extra cycle  E= -452.981905185128  delta_E=    0  |g|=    0  |ddm|= 2.29e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 4.528347877398245
E1 = -611.740239673373  E_coul = 158.75833448824517
init E= -452.981905185128
    CPU time for initialize scf      0.06 sec, wall time      0.06 sec
  mo_energy =
[-102.10365602  -13.27886305   -9.333773     -9.333773     -9.333773
   -2.70562251   -0.34077492   -0.34077492   -0.34077492]
E1 = -611.7402396733731  E_coul = 158.75833448824528
cycle= 1 E= -452.981905185128  delta_E=    0  |g|=    0  |ddm|= 3e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -611.7402396733731  E_coul = 158.75833448824528
  mo_energy =
[-102.10365602  -13.27886305   -9.333773     -9.333773     -9.333773
   -2.70562251   -0.34077492   -0.34077492   -0.34077492]
E1 = -611.7402396733733  E_coul = 158.75833448824523
Extra cycle  E= -452.981905185128  delta_E= -1.71e-13  |g|=    0  |ddm|= 3.23e-15
    CPU time for scf_cycle      0.13 sec, wall time      0.14 sec
exp = [9.52032108e+01 4.56233463e+00 7.85021287e-01 8.07396383e+00
 3.25371649e-02]
grad_E = [-8.70767902e-03  1.02059772e-01  1.72449018e+00 -6.32376821e-02
 -5.76850551e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:26 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.3072301873        1
[INPUT] 0    0    [1    /1   ]  4.51976906516        1
[INPUT] 0    0    [1    /1   ]  0.829175610346       1
[INPUT] 1    0    [1    /1   ]  8.08809548223        1
[INPUT] 1    0    [1    /1   ]  0.0341467920458      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.30723018733192, 1.0]], [0, [4.519769065163014, 1.0]], [0, [0.8291756103462231, 1.0]], [1, [8.088095482226493, 1.0]], [1, [0.03414679204575023, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.30723019]
bas 1, expnt(s) = [4.51976907]
bas 2, expnt(s) = [0.82917561]
bas 3, expnt(s) = [8.08809548]
bas 4, expnt(s) = [0.03414679]
CPU time:       132.17
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.53072302e+01 7.70653953e+01 4.51976907e+00 7.83163085e+00
 8.29175610e-01 2.19533051e+00 8.08809548e+00 3.97916758e+01
 3.41467920e-02 4.28224765e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.65049184392658
cond(S) = 4.806432627539831
E1 = -563.7920633274481  E_coul = 127.89240169344662
init E= -435.899661634001
    CPU time for initialize scf      0.02 sec, wall time      0.03 sec
  mo_energy =
[-105.1860778   -15.73867573  -11.75563717  -11.75563717  -11.75563717
   -4.4090673    -1.19714329   -1.19714329   -1.19714329]
E1 = -612.5156755804707  E_coul = 159.51786229337753
cycle= 1 E= -452.997813287093  delta_E= -17.1  |g|=    0  |ddm|= 3.32
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.36597e-14
diis-c [-5.59780371e-28  1.00000000e+00]
  mo_energy =
[-102.02551525  -13.24449675   -9.27319192   -9.27319192   -9.27319192
   -2.60946417   -0.34697452   -0.34697452   -0.34697452]
E1 = -612.5156755804703  E_coul = 159.51786229337745
cycle= 2 E= -452.997813287093  delta_E= 2.27e-13  |g|=    0  |ddm|= 3.39e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -612.5156755804703  E_coul = 159.51786229337745
  mo_energy =
[-102.02551525  -13.24449675   -9.27319192   -9.27319192   -9.27319192
   -2.60946417   -0.34697452   -0.34697452   -0.34697452]
E1 = -612.5156755804705  E_coul = 159.51786229337748
Extra cycle  E= -452.997813287093  delta_E= -2.27e-13  |g|=    0  |ddm|= 2.47e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
exp = [9.53072302e+01 4.51976907e+00 8.29175610e-01 8.08809548e+00
 3.41467920e-02]
E = -452.9978132870931
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:27 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.3072301873        1
[INPUT] 0    0    [1    /1   ]  4.51976906516        1
[INPUT] 0    0    [1    /1   ]  0.829175610346       1
[INPUT] 1    0    [1    /1   ]  8.08809548223        1
[INPUT] 1    0    [1    /1   ]  0.0341467920458      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.30723018733192, 1.0]], [0, [4.519769065163014, 1.0]], [0, [0.8291756103462231, 1.0]], [1, [8.088095482226493, 1.0]], [1, [0.03414679204575023, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.30723019]
bas 1, expnt(s) = [4.51976907]
bas 2, expnt(s) = [0.82917561]
bas 3, expnt(s) = [8.08809548]
bas 4, expnt(s) = [0.03414679]
CPU time:       132.77
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.53072302e+01 7.70653953e+01 4.51976907e+00 7.83163085e+00
 8.29175610e-01 2.19533051e+00 8.08809548e+00 3.97916758e+01
 3.41467920e-02 4.28224765e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.65049184392658
cond(S) = 4.806432627539831
E1 = -563.7920633274481  E_coul = 127.89240169344662
init E= -435.899661634001
    CPU time for initialize scf      0.04 sec, wall time      0.07 sec
  mo_energy =
[-105.1860778   -15.73867573  -11.75563717  -11.75563717  -11.75563717
   -4.4090673    -1.19714329   -1.19714329   -1.19714329]
E1 = -612.5156755804707  E_coul = 159.51786229337753
cycle= 1 E= -452.997813287093  delta_E= -17.1  |g|=    0  |ddm|= 3.32
    CPU time for cycle= 1      0.02 sec, wall time      0.04 sec
diis-norm(errvec)=2.36597e-14
diis-c [-5.59780371e-28  1.00000000e+00]
  mo_energy =
[-102.02551525  -13.24449675   -9.27319192   -9.27319192   -9.27319192
   -2.60946417   -0.34697452   -0.34697452   -0.34697452]
E1 = -612.5156755804703  E_coul = 159.51786229337745
cycle= 2 E= -452.997813287093  delta_E= 2.27e-13  |g|=    0  |ddm|= 3.39e-15
    CPU time for cycle= 2      0.03 sec, wall time      0.12 sec
E1 = -612.5156755804703  E_coul = 159.51786229337745
  mo_energy =
[-102.02551525  -13.24449675   -9.27319192   -9.27319192   -9.27319192
   -2.60946417   -0.34697452   -0.34697452   -0.34697452]
E1 = -612.5156755804705  E_coul = 159.51786229337748
Extra cycle  E= -452.997813287093  delta_E= -2.27e-13  |g|=    0  |ddm|= 2.47e-15
    CPU time for scf_cycle      0.10 sec, wall time      0.25 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 4.806432627539831
E1 = -612.5156755804705  E_coul = 159.51786229337748
init E= -452.997813287093
    CPU time for initialize scf      0.07 sec, wall time      0.09 sec
  mo_energy =
[-102.02551525  -13.24449675   -9.27319192   -9.27319192   -9.27319192
   -2.60946417   -0.34697452   -0.34697452   -0.34697452]
E1 = -612.5156755804704  E_coul = 159.5178622933775
cycle= 1 E= -452.997813287093  delta_E= 1.71e-13  |g|=    0  |ddm|= 3.29e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -612.5156755804704  E_coul = 159.5178622933775
  mo_energy =
[-102.02551525  -13.24449675   -9.27319192   -9.27319192   -9.27319192
   -2.60946417   -0.34697452   -0.34697452   -0.34697452]
E1 = -612.5156755804704  E_coul = 159.5178622933775
Extra cycle  E= -452.997813287093  delta_E=    0  |g|=    0  |ddm|= 5.31e-15
    CPU time for scf_cycle      0.16 sec, wall time      0.21 sec
exp = [9.53072302e+01 4.51976907e+00 8.29175610e-01 8.08809548e+00
 3.41467920e-02]
grad_E = [-7.11873340e-03  8.26907341e-02  1.94074854e+00 -4.98750713e-02
 -5.59255704e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:31 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.5135001646        1
[INPUT] 0    0    [1    /1   ]  4.46114022531        1
[INPUT] 0    0    [1    /1   ]  0.855396939527       1
[INPUT] 1    0    [1    /1   ]  8.12372427227        1
[INPUT] 1    0    [1    /1   ]  0.0351027248163      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.51350016460006, 1.0]], [0, [4.461140225310992, 1.0]], [0, [0.855396939526826, 1.0]], [1, [8.123724272268221, 1.0]], [1, [0.03510272481628063, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.51350016]
bas 1, expnt(s) = [4.46114023]
bas 2, expnt(s) = [0.85539694]
bas 3, expnt(s) = [8.12372427]
bas 4, expnt(s) = [0.03510272]
CPU time:       136.68
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.55135002e+01 7.71904539e+01 4.46114023e+00 7.75531478e+00
 8.55396940e-01 2.24719517e+00 8.12372427e+00 4.00109037e+01
 3.51027248e-02 4.43261926e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.654965578828135
cond(S) = 5.0114277943107925
E1 = -563.7566634936311  E_coul = 127.96128036850303
init E= -435.795383125128
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.14272756  -15.75571578  -11.75496462  -11.75496462  -11.75496462
   -4.38466673   -1.21341823   -1.21341823   -1.21341823]
E1 = -613.0092942776354  E_coul = 160.0047987407006
cycle= 1 E= -453.004495536935  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.69896e-14
diis-c [-1.36823002e-27  1.00000000e+00]
  mo_energy =
[-101.9453602   -13.22994892   -9.23713242   -9.23713242   -9.23713242
   -2.56150343   -0.35054619   -0.35054619   -0.35054619]
E1 = -613.0092942776356  E_coul = 160.0047987407007
cycle= 2 E= -453.004495536935  delta_E= -1.14e-13  |g|=    0  |ddm|= 4.49e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0092942776356  E_coul = 160.0047987407007
  mo_energy =
[-101.9453602   -13.22994892   -9.23713242   -9.23713242   -9.23713242
   -2.56150343   -0.35054619   -0.35054619   -0.35054619]
E1 = -613.0092942776357  E_coul = 160.0047987407008
Extra cycle  E= -453.004495536935  delta_E=    0  |g|=    0  |ddm|= 3.72e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [9.55135002e+01 4.46114023e+00 8.55396940e-01 8.12372427e+00
 3.51027248e-02]
E = -453.0044955369349
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:32 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.5135001646        1
[INPUT] 0    0    [1    /1   ]  4.46114022531        1
[INPUT] 0    0    [1    /1   ]  0.855396939527       1
[INPUT] 1    0    [1    /1   ]  8.12372427227        1
[INPUT] 1    0    [1    /1   ]  0.0351027248163      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.51350016460006, 1.0]], [0, [4.461140225310992, 1.0]], [0, [0.855396939526826, 1.0]], [1, [8.123724272268221, 1.0]], [1, [0.03510272481628063, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.51350016]
bas 1, expnt(s) = [4.46114023]
bas 2, expnt(s) = [0.85539694]
bas 3, expnt(s) = [8.12372427]
bas 4, expnt(s) = [0.03510272]
CPU time:       137.30
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.55135002e+01 7.71904539e+01 4.46114023e+00 7.75531478e+00
 8.55396940e-01 2.24719517e+00 8.12372427e+00 4.00109037e+01
 3.51027248e-02 4.43261926e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.654965578828135
cond(S) = 5.0114277943107925
E1 = -563.7566634936311  E_coul = 127.96128036850303
init E= -435.795383125128
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.14272756  -15.75571578  -11.75496462  -11.75496462  -11.75496462
   -4.38466673   -1.21341823   -1.21341823   -1.21341823]
E1 = -613.0092942776354  E_coul = 160.0047987407006
cycle= 1 E= -453.004495536935  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.69896e-14
diis-c [-1.36823002e-27  1.00000000e+00]
  mo_energy =
[-101.9453602   -13.22994892   -9.23713242   -9.23713242   -9.23713242
   -2.56150343   -0.35054619   -0.35054619   -0.35054619]
E1 = -613.0092942776356  E_coul = 160.0047987407007
cycle= 2 E= -453.004495536935  delta_E= -1.14e-13  |g|=    0  |ddm|= 4.49e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0092942776356  E_coul = 160.0047987407007
  mo_energy =
[-101.9453602   -13.22994892   -9.23713242   -9.23713242   -9.23713242
   -2.56150343   -0.35054619   -0.35054619   -0.35054619]
E1 = -613.0092942776357  E_coul = 160.0047987407008
Extra cycle  E= -453.004495536935  delta_E=    0  |g|=    0  |ddm|= 3.72e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.0114277943107925
E1 = -613.0092942776357  E_coul = 160.0047987407008
init E= -453.004495536935
    CPU time for initialize scf      0.06 sec, wall time      0.06 sec
  mo_energy =
[-101.9453602   -13.22994892   -9.23713242   -9.23713242   -9.23713242
   -2.56150343   -0.35054619   -0.35054619   -0.35054619]
E1 = -613.0092942776357  E_coul = 160.00479874070083
cycle= 1 E= -453.004495536935  delta_E=    0  |g|=    0  |ddm|= 3.29e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -613.0092942776357  E_coul = 160.00479874070083
  mo_energy =
[-101.9453602   -13.22994892   -9.23713242   -9.23713242   -9.23713242
   -2.56150343   -0.35054619   -0.35054619   -0.35054619]
E1 = -613.0092942776356  E_coul = 160.0047987407007
Extra cycle  E= -453.004495536935  delta_E=    0  |g|=    0  |ddm|= 4.82e-15
    CPU time for scf_cycle      0.13 sec, wall time      0.13 sec
exp = [9.55135002e+01 4.46114023e+00 8.55396940e-01 8.12372427e+00
 3.51027248e-02]
grad_E = [-3.08798947e-03  3.48524843e-02  2.02782380e+00 -2.10819130e-02
 -5.49414090e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:36 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6296852067        1
[INPUT] 0    0    [1    /1   ]  4.43427199417        1
[INPUT] 0    0    [1    /1   ]  0.858809819307       1
[INPUT] 1    0    [1    /1   ]  8.1447772764         1
[INPUT] 1    0    [1    /1   ]  0.0352271965147      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.62968520670502, 1.0]], [0, [4.434271994167147, 1.0]], [0, [0.8588098193065552, 1.0]], [1, [8.144777276395775, 1.0]], [1, [0.03522719651471662, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.62968521]
bas 1, expnt(s) = [4.43427199]
bas 2, expnt(s) = [0.85880982]
bas 3, expnt(s) = [8.14477728]
bas 4, expnt(s) = [0.0352272]
CPU time:       140.88
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56296852e+01 7.72608655e+01 4.43427199e+00 7.72025723e+00
 8.58809819e-01 2.25391625e+00 8.14477728e+00 4.01405583e+01
 3.52271965e-02 4.45227514e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.6570046868087
cond(S) = 5.057108814761024
E1 = -563.7968645099639  E_coul = 128.02318947440892
init E= -435.773675035555
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.11319684  -15.75858071  -11.75239012  -11.75239012  -11.75239012
   -4.38517643   -1.21523802   -1.21523802   -1.21523802]
E1 = -613.1045659937803  E_coul = 160.09910378467427
cycle= 1 E= -453.005462209106  delta_E= -17.2  |g|=    0  |ddm|= 3.34
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.60021e-14
diis-c [-7.39636293e-27  1.00000000e+00]
  mo_energy =
[-101.91380237  -13.23092416   -9.23153123   -9.23153123   -9.23153123
   -2.56082932   -0.35100989   -0.35100989   -0.35100989]
E1 = -613.1045659937804  E_coul = 160.09910378467427
cycle= 2 E= -453.005462209106  delta_E= -1.14e-13  |g|=    0  |ddm|= 2.84e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.1045659937804  E_coul = 160.09910378467427
  mo_energy =
[-101.91380237  -13.23092416   -9.23153123   -9.23153123   -9.23153123
   -2.56082932   -0.35100989   -0.35100989   -0.35100989]
E1 = -613.1045659937804  E_coul = 160.0991037846743
Extra cycle  E= -453.005462209106  delta_E=    0  |g|=    0  |ddm|= 2.96e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.56296852e+01 4.43427199e+00 8.58809819e-01 8.14477728e+00
 3.52271965e-02]
E = -453.0054622091061
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:36 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6296852067        1
[INPUT] 0    0    [1    /1   ]  4.43427199417        1
[INPUT] 0    0    [1    /1   ]  0.858809819307       1
[INPUT] 1    0    [1    /1   ]  8.1447772764         1
[INPUT] 1    0    [1    /1   ]  0.0352271965147      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.62968520670502, 1.0]], [0, [4.434271994167147, 1.0]], [0, [0.8588098193065552, 1.0]], [1, [8.144777276395775, 1.0]], [1, [0.03522719651471662, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.62968521]
bas 1, expnt(s) = [4.43427199]
bas 2, expnt(s) = [0.85880982]
bas 3, expnt(s) = [8.14477728]
bas 4, expnt(s) = [0.0352272]
CPU time:       141.48
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56296852e+01 7.72608655e+01 4.43427199e+00 7.72025723e+00
 8.58809819e-01 2.25391625e+00 8.14477728e+00 4.01405583e+01
 3.52271965e-02 4.45227514e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.6570046868087
cond(S) = 5.057108814761024
E1 = -563.7968645099639  E_coul = 128.02318947440892
init E= -435.773675035555
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.11319684  -15.75858071  -11.75239012  -11.75239012  -11.75239012
   -4.38517643   -1.21523802   -1.21523802   -1.21523802]
E1 = -613.1045659937803  E_coul = 160.09910378467427
cycle= 1 E= -453.005462209106  delta_E= -17.2  |g|=    0  |ddm|= 3.34
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=8.60021e-14
diis-c [-7.39636293e-27  1.00000000e+00]
  mo_energy =
[-101.91380237  -13.23092416   -9.23153123   -9.23153123   -9.23153123
   -2.56082932   -0.35100989   -0.35100989   -0.35100989]
E1 = -613.1045659937804  E_coul = 160.09910378467427
cycle= 2 E= -453.005462209106  delta_E= -1.14e-13  |g|=    0  |ddm|= 2.84e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.1045659937804  E_coul = 160.09910378467427
  mo_energy =
[-101.91380237  -13.23092416   -9.23153123   -9.23153123   -9.23153123
   -2.56082932   -0.35100989   -0.35100989   -0.35100989]
E1 = -613.1045659937804  E_coul = 160.0991037846743
Extra cycle  E= -453.005462209106  delta_E=    0  |g|=    0  |ddm|= 2.96e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.057108814761024
E1 = -613.1045659937804  E_coul = 160.0991037846743
init E= -453.005462209106
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.91380237  -13.23092416   -9.23153123   -9.23153123   -9.23153123
   -2.56082932   -0.35100989   -0.35100989   -0.35100989]
E1 = -613.1045659937805  E_coul = 160.0991037846743
cycle= 1 E= -453.005462209106  delta_E= -1.14e-13  |g|=    0  |ddm|= 3.71e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -613.1045659937805  E_coul = 160.0991037846743
  mo_energy =
[-101.91380237  -13.23092416   -9.23153123   -9.23153123   -9.23153123
   -2.56082932   -0.35100989   -0.35100989   -0.35100989]
E1 = -613.1045659937806  E_coul = 160.09910378467436
Extra cycle  E= -453.005462209106  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.68e-15
    CPU time for scf_cycle      0.10 sec, wall time      0.10 sec
exp = [9.56296852e+01 4.43427199e+00 8.58809819e-01 8.14477728e+00
 3.52271965e-02]
grad_E = [-6.84929653e-04  6.65613884e-03  2.02335769e+00 -4.75625062e-03
 -5.48183060e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:40 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6593929943        1
[INPUT] 0    0    [1    /1   ]  4.43024113931        1
[INPUT] 0    0    [1    /1   ]  0.856502755113       1
[INPUT] 1    0    [1    /1   ]  8.15037586717        1
[INPUT] 1    0    [1    /1   ]  0.0351431406528      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.65939299427397, 1.0]], [0, [4.430241139314059, 1.0]], [0, [0.8565027551127031, 1.0]], [1, [8.15037586716765, 1.0]], [1, [0.03514314065278747, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.65939299]
bas 1, expnt(s) = [4.43024114]
bas 2, expnt(s) = [0.85650276]
bas 3, expnt(s) = [8.15037587]
bas 4, expnt(s) = [0.03514314]
CPU time:       144.86
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56593930e+01 7.72788659e+01 4.43024114e+00 7.71499322e+00
 8.56502755e-01 2.24937362e+00 8.15037587e+00 4.01750512e+01
 3.51431407e-02 4.43899960e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.657248738990452
cond(S) = 5.046756188907501
E1 = -563.8271367103542  E_coul = 128.0474374912881
init E= -435.779699219066
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.1045694   -15.75720749  -11.75095133  -11.75095133  -11.75095133
   -4.38899838   -1.21369313   -1.21369313   -1.21369313]
E1 = -613.0826757399257  E_coul = 160.077133370305
cycle= 1 E= -453.005542369621  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.38608e-14
diis-c [-1.92377149e-27  1.00000000e+00]
  mo_energy =
[-101.90962726  -13.23332558   -9.23386076   -9.23386076   -9.23386076
   -2.56756181   -0.35070253   -0.35070253   -0.35070253]
E1 = -613.0826757399255  E_coul = 160.07713337030492
cycle= 2 E= -453.005542369621  delta_E= 5.68e-14  |g|=    0  |ddm|= 3.24e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0826757399255  E_coul = 160.07713337030492
  mo_energy =
[-101.90962726  -13.23332558   -9.23386076   -9.23386076   -9.23386076
   -2.56756181   -0.35070253   -0.35070253   -0.35070253]
E1 = -613.0826757399254  E_coul = 160.07713337030492
Extra cycle  E= -453.005542369621  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.38e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.56593930e+01 4.43024114e+00 8.56502755e-01 8.15037587e+00
 3.51431407e-02]
E = -453.0055423696205
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:40 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6593929943        1
[INPUT] 0    0    [1    /1   ]  4.43024113931        1
[INPUT] 0    0    [1    /1   ]  0.856502755113       1
[INPUT] 1    0    [1    /1   ]  8.15037586717        1
[INPUT] 1    0    [1    /1   ]  0.0351431406528      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.65939299427397, 1.0]], [0, [4.430241139314059, 1.0]], [0, [0.8565027551127031, 1.0]], [1, [8.15037586716765, 1.0]], [1, [0.03514314065278747, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.65939299]
bas 1, expnt(s) = [4.43024114]
bas 2, expnt(s) = [0.85650276]
bas 3, expnt(s) = [8.15037587]
bas 4, expnt(s) = [0.03514314]
CPU time:       145.44
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56593930e+01 7.72788659e+01 4.43024114e+00 7.71499322e+00
 8.56502755e-01 2.24937362e+00 8.15037587e+00 4.01750512e+01
 3.51431407e-02 4.43899960e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.657248738990452
cond(S) = 5.046756188907501
E1 = -563.8271367103542  E_coul = 128.0474374912881
init E= -435.779699219066
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.1045694   -15.75720749  -11.75095133  -11.75095133  -11.75095133
   -4.38899838   -1.21369313   -1.21369313   -1.21369313]
E1 = -613.0826757399257  E_coul = 160.077133370305
cycle= 1 E= -453.005542369621  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.38608e-14
diis-c [-1.92377149e-27  1.00000000e+00]
  mo_energy =
[-101.90962726  -13.23332558   -9.23386076   -9.23386076   -9.23386076
   -2.56756181   -0.35070253   -0.35070253   -0.35070253]
E1 = -613.0826757399255  E_coul = 160.07713337030492
cycle= 2 E= -453.005542369621  delta_E= 5.68e-14  |g|=    0  |ddm|= 3.24e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0826757399255  E_coul = 160.07713337030492
  mo_energy =
[-101.90962726  -13.23332558   -9.23386076   -9.23386076   -9.23386076
   -2.56756181   -0.35070253   -0.35070253   -0.35070253]
E1 = -613.0826757399254  E_coul = 160.07713337030492
Extra cycle  E= -453.005542369621  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.38e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.046756188907501
E1 = -613.0826757399254  E_coul = 160.07713337030492
init E= -453.005542369621
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.90962726  -13.23332558   -9.23386076   -9.23386076   -9.23386076
   -2.56756181   -0.35070253   -0.35070253   -0.35070253]
E1 = -613.0826757399255  E_coul = 160.07713337030495
cycle= 1 E= -453.005542369621  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.64e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -613.0826757399255  E_coul = 160.07713337030495
  mo_energy =
[-101.90962726  -13.23332558   -9.23386076   -9.23386076   -9.23386076
   -2.56756181   -0.35070253   -0.35070253   -0.35070253]
E1 = -613.0826757399254  E_coul = 160.0771333703049
Extra cycle  E= -453.005542369621  delta_E=    0  |g|=    0  |ddm|= 4.67e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.56593930e+01 4.43024114e+00 8.56502755e-01 8.15037587e+00
 3.51431407e-02]
grad_E = [-5.58790060e-05  2.30370968e-04  2.00943048e+00 -4.97325362e-04
 -5.49038290e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:44 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6631886403        1
[INPUT] 0    0    [1    /1   ]  4.43060479522        1
[INPUT] 0    0    [1    /1   ]  0.855190562072       1
[INPUT] 1    0    [1    /1   ]  8.15128131106        1
[INPUT] 1    0    [1    /1   ]  0.0350953510289      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.66318864030822, 1.0]], [0, [4.4306047952158725, 1.0]], [0, [0.8551905620721335, 1.0]], [1, [8.151281311056838, 1.0]], [1, [0.035095351028898845, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.66318864]
bas 1, expnt(s) = [4.4306048]
bas 2, expnt(s) = [0.85519056]
bas 3, expnt(s) = [8.15128131]
bas 4, expnt(s) = [0.03509535]
CPU time:       148.75
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56631886e+01 7.72811656e+01 4.43060480e+00 7.71546817e+00
 8.55190562e-01 2.24678853e+00 8.15128131e+00 4.01806302e+01
 3.50953510e-02 4.43145538e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.65719891838176
cond(S) = 5.038384490792763
E1 = -563.8381335665381  E_coul = 128.05382742202568
init E= -435.784306144512
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.10299309  -15.75633012  -11.75048141  -11.75048141  -11.75048141
   -4.39065958   -1.21285104   -1.21285104   -1.21285104]
E1 = -613.0656738223653  E_coul = 160.06012332704097
cycle= 1 E= -453.005550495324  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.07288e-14
diis-c [-4.29682648e-28  1.00000000e+00]
  mo_energy =
[-101.91021826  -13.23429971   -9.23532849   -9.23532849   -9.23532849
   -2.57062968   -0.35052682   -0.35052682   -0.35052682]
E1 = -613.0656738223653  E_coul = 160.06012332704094
cycle= 2 E= -453.005550495324  delta_E=    0  |g|=    0  |ddm|= 2.16e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0656738223653  E_coul = 160.06012332704094
  mo_energy =
[-101.91021826  -13.23429971   -9.23532849   -9.23532849   -9.23532849
   -2.57062968   -0.35052682   -0.35052682   -0.35052682]
E1 = -613.0656738223652  E_coul = 160.06012332704094
Extra cycle  E= -453.005550495324  delta_E= 1.14e-13  |g|=    0  |ddm|= 2.82e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.56631886e+01 4.43060480e+00 8.55190562e-01 8.15128131e+00
 3.50953510e-02]
E = -453.0055504953242
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:44 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6631886403        1
[INPUT] 0    0    [1    /1   ]  4.43060479522        1
[INPUT] 0    0    [1    /1   ]  0.855190562072       1
[INPUT] 1    0    [1    /1   ]  8.15128131106        1
[INPUT] 1    0    [1    /1   ]  0.0350953510289      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.66318864030822, 1.0]], [0, [4.4306047952158725, 1.0]], [0, [0.8551905620721335, 1.0]], [1, [8.151281311056838, 1.0]], [1, [0.035095351028898845, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.66318864]
bas 1, expnt(s) = [4.4306048]
bas 2, expnt(s) = [0.85519056]
bas 3, expnt(s) = [8.15128131]
bas 4, expnt(s) = [0.03509535]
CPU time:       149.35
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56631886e+01 7.72811656e+01 4.43060480e+00 7.71546817e+00
 8.55190562e-01 2.24678853e+00 8.15128131e+00 4.01806302e+01
 3.50953510e-02 4.43145538e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.65719891838176
cond(S) = 5.038384490792763
E1 = -563.8381335665381  E_coul = 128.05382742202568
init E= -435.784306144512
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.10299309  -15.75633012  -11.75048141  -11.75048141  -11.75048141
   -4.39065958   -1.21285104   -1.21285104   -1.21285104]
E1 = -613.0656738223653  E_coul = 160.06012332704097
cycle= 1 E= -453.005550495324  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.07288e-14
diis-c [-4.29682648e-28  1.00000000e+00]
  mo_energy =
[-101.91021826  -13.23429971   -9.23532849   -9.23532849   -9.23532849
   -2.57062968   -0.35052682   -0.35052682   -0.35052682]
E1 = -613.0656738223653  E_coul = 160.06012332704094
cycle= 2 E= -453.005550495324  delta_E=    0  |g|=    0  |ddm|= 2.16e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0656738223653  E_coul = 160.06012332704094
  mo_energy =
[-101.91021826  -13.23429971   -9.23532849   -9.23532849   -9.23532849
   -2.57062968   -0.35052682   -0.35052682   -0.35052682]
E1 = -613.0656738223652  E_coul = 160.06012332704094
Extra cycle  E= -453.005550495324  delta_E= 1.14e-13  |g|=    0  |ddm|= 2.82e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.038384490792763
E1 = -613.0656738223652  E_coul = 160.06012332704094
init E= -453.005550495324
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.91021826  -13.23429971   -9.23532849   -9.23532849   -9.23532849
   -2.57062968   -0.35052682   -0.35052682   -0.35052682]
E1 = -613.0656738223652  E_coul = 160.06012332704097
cycle= 1 E= -453.005550495324  delta_E=    0  |g|=    0  |ddm|= 4.85e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -613.0656738223652  E_coul = 160.06012332704097
  mo_energy =
[-101.91021826  -13.23429971   -9.23532849   -9.23532849   -9.23532849
   -2.57062968   -0.35052682   -0.35052682   -0.35052682]
E1 = -613.0656738223653  E_coul = 160.060123327041
Extra cycle  E= -453.005550495324  delta_E= -1.14e-13  |g|=    0  |ddm|= 6.22e-15
    CPU time for scf_cycle      0.10 sec, wall time      0.11 sec
exp = [9.56631886e+01 4.43060480e+00 8.55190562e-01 8.15128131e+00
 3.50953510e-02]
grad_E = [ 3.01034308e-05 -3.53571610e-04  2.00354280e+00  1.77165985e-04
 -5.49522978e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:48 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6631159139        1
[INPUT] 0    0    [1    /1   ]  4.43094565873        1
[INPUT] 0    0    [1    /1   ]  0.854811066866       1
[INPUT] 1    0    [1    /1   ]  8.15134372799        1
[INPUT] 1    0    [1    /1   ]  0.0350815682999      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.66311591394474, 1.0]], [0, [4.430945658731387, 1.0]], [0, [0.8548110668655329, 1.0]], [1, [8.151343727988927, 1.0]], [1, [0.035081568299914836, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.66311591]
bas 1, expnt(s) = [4.43094566]
bas 2, expnt(s) = [0.85481107]
bas 3, expnt(s) = [8.15134373]
bas 4, expnt(s) = [0.03508157]
CPU time:       152.64
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56631159e+01 7.72811215e+01 4.43094566e+00 7.71591335e+00
 8.54811067e-01 2.24604072e+00 8.15134373e+00 4.01810148e+01
 3.50815683e-02 4.42928007e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.657169003304029
cond(S) = 5.035745964477908
E1 = -563.8407868789932  E_coul = 128.05503763692693
init E= -435.785749242066
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.10282984  -15.75606597  -11.75037516  -11.75037516  -11.75037516
   -4.39109431   -1.21261113   -1.21261113   -1.21261113]
E1 = -613.0603777692  E_coul = 160.05482462450485
cycle= 1 E= -453.005553144695  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.83546e-14
diis-c [-2.33816521e-27  1.00000000e+00]
  mo_energy =
[-101.91064949  -13.23454479   -9.23576426   -9.23576426   -9.23576426
   -2.57144906   -0.35047605   -0.35047605   -0.35047605]
E1 = -613.0603777691997  E_coul = 160.05482462450468
cycle= 2 E= -453.005553144695  delta_E= 2.27e-13  |g|=    0  |ddm|= 7.69e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0603777691997  E_coul = 160.05482462450468
  mo_energy =
[-101.91064949  -13.23454479   -9.23576426   -9.23576426   -9.23576426
   -2.57144906   -0.35047605   -0.35047605   -0.35047605]
E1 = -613.0603777691997  E_coul = 160.05482462450473
Extra cycle  E= -453.005553144695  delta_E=    0  |g|=    0  |ddm|= 5.09e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
exp = [9.56631159e+01 4.43094566e+00 8.54811067e-01 8.15134373e+00
 3.50815683e-02]
E = -453.005553144695
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:48 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6631159139        1
[INPUT] 0    0    [1    /1   ]  4.43094565873        1
[INPUT] 0    0    [1    /1   ]  0.854811066866       1
[INPUT] 1    0    [1    /1   ]  8.15134372799        1
[INPUT] 1    0    [1    /1   ]  0.0350815682999      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.66311591394474, 1.0]], [0, [4.430945658731387, 1.0]], [0, [0.8548110668655329, 1.0]], [1, [8.151343727988927, 1.0]], [1, [0.035081568299914836, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.66311591]
bas 1, expnt(s) = [4.43094566]
bas 2, expnt(s) = [0.85481107]
bas 3, expnt(s) = [8.15134373]
bas 4, expnt(s) = [0.03508157]
CPU time:       153.30
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56631159e+01 7.72811215e+01 4.43094566e+00 7.71591335e+00
 8.54811067e-01 2.24604072e+00 8.15134373e+00 4.01810148e+01
 3.50815683e-02 4.42928007e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.657169003304029
cond(S) = 5.035745964477908
E1 = -563.8407868789932  E_coul = 128.05503763692693
init E= -435.785749242066
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.10282984  -15.75606597  -11.75037516  -11.75037516  -11.75037516
   -4.39109431   -1.21261113   -1.21261113   -1.21261113]
E1 = -613.0603777692  E_coul = 160.05482462450485
cycle= 1 E= -453.005553144695  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.83546e-14
diis-c [-2.33816521e-27  1.00000000e+00]
  mo_energy =
[-101.91064949  -13.23454479   -9.23576426   -9.23576426   -9.23576426
   -2.57144906   -0.35047605   -0.35047605   -0.35047605]
E1 = -613.0603777691997  E_coul = 160.05482462450468
cycle= 2 E= -453.005553144695  delta_E= 2.27e-13  |g|=    0  |ddm|= 7.69e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0603777691997  E_coul = 160.05482462450468
  mo_energy =
[-101.91064949  -13.23454479   -9.23576426   -9.23576426   -9.23576426
   -2.57144906   -0.35047605   -0.35047605   -0.35047605]
E1 = -613.0603777691997  E_coul = 160.05482462450473
Extra cycle  E= -453.005553144695  delta_E=    0  |g|=    0  |ddm|= 5.09e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.035745964477908
E1 = -613.0603777691997  E_coul = 160.05482462450473
init E= -453.005553144695
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.91064949  -13.23454479   -9.23576426   -9.23576426   -9.23576426
   -2.57144906   -0.35047605   -0.35047605   -0.35047605]
E1 = -613.0603777691999  E_coul = 160.05482462450473
cycle= 1 E= -453.005553144695  delta_E= -2.27e-13  |g|=    0  |ddm|= 3.11e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -613.0603777691999  E_coul = 160.05482462450473
  mo_energy =
[-101.91064949  -13.23454479   -9.23576426   -9.23576426   -9.23576426
   -2.57144906   -0.35047605   -0.35047605   -0.35047605]
E1 = -613.0603777691999  E_coul = 160.05482462450485
Extra cycle  E= -453.005553144695  delta_E= 1.14e-13  |g|=    0  |ddm|= 5.28e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.56631159e+01 4.43094566e+00 8.54811067e-01 8.15134373e+00
 3.50815683e-02]
grad_E = [ 3.07348698e-05 -2.48947069e-04  2.00201862e+00  2.19563664e-04
 -5.49662700e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:52 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6625271443        1
[INPUT] 0    0    [1    /1   ]  4.43196649192        1
[INPUT] 0    0    [1    /1   ]  0.853759812993       1
[INPUT] 1    0    [1    /1   ]  8.15145144041        1
[INPUT] 1    0    [1    /1   ]  0.0350435394205      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.66252714426653, 1.0]], [0, [4.4319664919162935, 1.0]], [0, [0.8537598129928673, 1.0]], [1, [8.151451440408275, 1.0]], [1, [0.03504353942054946, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.66252714]
bas 1, expnt(s) = [4.43196649]
bas 2, expnt(s) = [0.85375981]
bas 3, expnt(s) = [8.15145144]
bas 4, expnt(s) = [0.03504354]
CPU time:       156.67
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56625271e+01 7.72807648e+01 4.43196649e+00 7.71724655e+00
 8.53759813e-01 2.24396876e+00 8.15145144e+00 4.01816785e+01
 3.50435394e-02 4.42327914e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.657085350337113
cond(S) = 5.028374217605888
E1 = -563.8479773190186  E_coul = 128.0581886792624
init E= -435.789788639756
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.10247268  -15.75532951  -11.75008995  -11.75008995  -11.75008995
   -4.39228203   -1.21194918   -1.21194918   -1.21194918]
E1 = -613.0456092951111  E_coul = 160.04004470309164
cycle= 1 E= -453.005564592019  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=5.12387e-14
diis-c [-2.62540305e-27  1.00000000e+00]
  mo_energy =
[-101.91192772  -13.23520948   -9.23697362   -9.23697362   -9.23697362
   -2.57369428   -0.35033587   -0.35033587   -0.35033587]
E1 = -613.0456092951111  E_coul = 160.04004470309164
cycle= 2 E= -453.005564592019  delta_E=    0  |g|=    0  |ddm|= 2.96e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0456092951111  E_coul = 160.04004470309164
  mo_energy =
[-101.91192772  -13.23520948   -9.23697362   -9.23697362   -9.23697362
   -2.57369428   -0.35033587   -0.35033587   -0.35033587]
E1 = -613.045609295111  E_coul = 160.04004470309164
Extra cycle  E= -453.005564592019  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.97e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.56625271e+01 4.43196649e+00 8.53759813e-01 8.15145144e+00
 3.50435394e-02]
E = -453.00556459201937
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:53 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6625271443        1
[INPUT] 0    0    [1    /1   ]  4.43196649192        1
[INPUT] 0    0    [1    /1   ]  0.853759812993       1
[INPUT] 1    0    [1    /1   ]  8.15145144041        1
[INPUT] 1    0    [1    /1   ]  0.0350435394205      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.66252714426653, 1.0]], [0, [4.4319664919162935, 1.0]], [0, [0.8537598129928673, 1.0]], [1, [8.151451440408275, 1.0]], [1, [0.03504353942054946, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.66252714]
bas 1, expnt(s) = [4.43196649]
bas 2, expnt(s) = [0.85375981]
bas 3, expnt(s) = [8.15145144]
bas 4, expnt(s) = [0.03504354]
CPU time:       157.35
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56625271e+01 7.72807648e+01 4.43196649e+00 7.71724655e+00
 8.53759813e-01 2.24396876e+00 8.15145144e+00 4.01816785e+01
 3.50435394e-02 4.42327914e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.657085350337113
cond(S) = 5.028374217605888
E1 = -563.8479773190186  E_coul = 128.0581886792624
init E= -435.789788639756
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.10247268  -15.75532951  -11.75008995  -11.75008995  -11.75008995
   -4.39228203   -1.21194918   -1.21194918   -1.21194918]
E1 = -613.0456092951111  E_coul = 160.04004470309164
cycle= 1 E= -453.005564592019  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=5.12387e-14
diis-c [-2.62540305e-27  1.00000000e+00]
  mo_energy =
[-101.91192772  -13.23520948   -9.23697362   -9.23697362   -9.23697362
   -2.57369428   -0.35033587   -0.35033587   -0.35033587]
E1 = -613.0456092951111  E_coul = 160.04004470309164
cycle= 2 E= -453.005564592019  delta_E=    0  |g|=    0  |ddm|= 2.96e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0456092951111  E_coul = 160.04004470309164
  mo_energy =
[-101.91192772  -13.23520948   -9.23697362   -9.23697362   -9.23697362
   -2.57369428   -0.35033587   -0.35033587   -0.35033587]
E1 = -613.045609295111  E_coul = 160.04004470309164
Extra cycle  E= -453.005564592019  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.97e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.028374217605888
E1 = -613.045609295111  E_coul = 160.04004470309164
init E= -453.005564592019
    CPU time for initialize scf      0.06 sec, wall time      0.06 sec
  mo_energy =
[-101.91192772  -13.23520948   -9.23697362   -9.23697362   -9.23697362
   -2.57369428   -0.35033587   -0.35033587   -0.35033587]
E1 = -613.0456092951111  E_coul = 160.04004470309164
cycle= 1 E= -453.005564592019  delta_E= -1.14e-13  |g|=    0  |ddm|= 2.31e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -613.0456092951111  E_coul = 160.04004470309164
  mo_energy =
[-101.91192772  -13.23520948   -9.23697362   -9.23697362   -9.23697362
   -2.57369428   -0.35033587   -0.35033587   -0.35033587]
E1 = -613.045609295111  E_coul = 160.04004470309164
Extra cycle  E= -453.005564592019  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.24e-15
    CPU time for scf_cycle      0.12 sec, wall time      0.12 sec
exp = [9.56625271e+01 4.43196649e+00 8.53759813e-01 8.15145144e+00
 3.50435394e-02]
grad_E = [ 2.44946141e-05  1.30906295e-04  1.99784413e+00  2.87051751e-04
 -5.50048590e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:56 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6616639366        1
[INPUT] 0    0    [1    /1   ]  4.43333960856        1
[INPUT] 0    0    [1    /1   ]  0.852360289403       1
[INPUT] 1    0    [1    /1   ]  8.15158219088        1
[INPUT] 1    0    [1    /1   ]  0.0349932654374      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.66166393661916, 1.0]], [0, [4.433339608561089, 1.0]], [0, [0.8523602894028579, 1.0]], [1, [8.151582190881498, 1.0]], [1, [0.034993265437427076, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.66166394]
bas 1, expnt(s) = [4.43333961]
bas 2, expnt(s) = [0.85236029]
bas 3, expnt(s) = [8.15158219]
bas 4, expnt(s) = [0.03499327]
CPU time:       160.80
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56616639e+01 7.72802418e+01 4.43333961e+00 7.71903971e+00
 8.52360289e-01 2.24120937e+00 8.15158219e+00 4.01824842e+01
 3.49932654e-02 4.41534843e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.65698385202283
cond(S) = 5.0185673776346045
E1 = -563.8575485315944  E_coul = 128.0623611511026
init E= -435.795187380492
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.10201433  -15.75434497  -11.74971071  -11.74971071  -11.74971071
   -4.39385606   -1.21107184   -1.21107184   -1.21107184]
E1 = -613.0259908879129  E_coul = 160.02040132591375
cycle= 1 E= -453.005589561999  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.49401e-14
diis-c [-2.01961642e-27  1.00000000e+00]
  mo_energy =
[-101.91364218  -13.23608629   -9.23858062   -9.23858062   -9.23858062
   -2.57667269   -0.35015036   -0.35015036   -0.35015036]
E1 = -613.0259908879127  E_coul = 160.02040132591375
cycle= 2 E= -453.005589561999  delta_E= 2.27e-13  |g|=    0  |ddm|= 3.49e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -613.0259908879127  E_coul = 160.02040132591375
  mo_energy =
[-101.91364218  -13.23608629   -9.23858062   -9.23858062   -9.23858062
   -2.57667269   -0.35015036   -0.35015036   -0.35015036]
E1 = -613.0259908879127  E_coul = 160.0204013259137
Extra cycle  E= -453.005589561999  delta_E= -1.14e-13  |g|=    0  |ddm|= 3.92e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [9.56616639e+01 4.43333961e+00 8.52360289e-01 8.15158219e+00
 3.49932654e-02]
E = -453.00558956199905
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:12:57 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6616639366        1
[INPUT] 0    0    [1    /1   ]  4.43333960856        1
[INPUT] 0    0    [1    /1   ]  0.852360289403       1
[INPUT] 1    0    [1    /1   ]  8.15158219088        1
[INPUT] 1    0    [1    /1   ]  0.0349932654374      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.66166393661916, 1.0]], [0, [4.433339608561089, 1.0]], [0, [0.8523602894028579, 1.0]], [1, [8.151582190881498, 1.0]], [1, [0.034993265437427076, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.66166394]
bas 1, expnt(s) = [4.43333961]
bas 2, expnt(s) = [0.85236029]
bas 3, expnt(s) = [8.15158219]
bas 4, expnt(s) = [0.03499327]
CPU time:       161.48
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56616639e+01 7.72802418e+01 4.43333961e+00 7.71903971e+00
 8.52360289e-01 2.24120937e+00 8.15158219e+00 4.01824842e+01
 3.49932654e-02 4.41534843e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.65698385202283
cond(S) = 5.0185673776346045
E1 = -563.8575485315944  E_coul = 128.0623611511026
init E= -435.795187380492
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.10201433  -15.75434497  -11.74971071  -11.74971071  -11.74971071
   -4.39385606   -1.21107184   -1.21107184   -1.21107184]
E1 = -613.0259908879129  E_coul = 160.02040132591375
cycle= 1 E= -453.005589561999  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.49401e-14
diis-c [-2.01961642e-27  1.00000000e+00]
  mo_energy =
[-101.91364218  -13.23608629   -9.23858062   -9.23858062   -9.23858062
   -2.57667269   -0.35015036   -0.35015036   -0.35015036]
E1 = -613.0259908879127  E_coul = 160.02040132591375
cycle= 2 E= -453.005589561999  delta_E= 2.27e-13  |g|=    0  |ddm|= 3.49e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -613.0259908879127  E_coul = 160.02040132591375
  mo_energy =
[-101.91364218  -13.23608629   -9.23858062   -9.23858062   -9.23858062
   -2.57667269   -0.35015036   -0.35015036   -0.35015036]
E1 = -613.0259908879127  E_coul = 160.0204013259137
Extra cycle  E= -453.005589561999  delta_E= -1.14e-13  |g|=    0  |ddm|= 3.92e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.0185673776346045
E1 = -613.0259908879127  E_coul = 160.0204013259137
init E= -453.005589561999
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.91364218  -13.23608629   -9.23858062   -9.23858062   -9.23858062
   -2.57667269   -0.35015036   -0.35015036   -0.35015036]
E1 = -613.0259908879125  E_coul = 160.02040132591358
cycle= 1 E= -453.005589561999  delta_E= 1.14e-13  |g|=    0  |ddm|= 6.95e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -613.0259908879125  E_coul = 160.02040132591358
  mo_energy =
[-101.91364218  -13.23608629   -9.23858062   -9.23858062   -9.23858062
   -2.57667269   -0.35015036   -0.35015036   -0.35015036]
E1 = -613.0259908879127  E_coul = 160.02040132591378
Extra cycle  E= -453.005589561999  delta_E=    0  |g|=    0  |ddm|= 6.93e-15
    CPU time for scf_cycle      0.10 sec, wall time      0.11 sec
exp = [9.56616639e+01 4.43333961e+00 8.52360289e-01 8.15158219e+00
 3.49932654e-02]
grad_E = [ 1.45829576e-05  6.55732349e-04  1.99227040e+00  3.67101951e-04
 -5.50559748e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:00 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6601252487        1
[INPUT] 0    0    [1    /1   ]  4.43574481657        1
[INPUT] 0    0    [1    /1   ]  0.849908917398       1
[INPUT] 1    0    [1    /1   ]  8.15180927366        1
[INPUT] 1    0    [1    /1   ]  0.0349061801149      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.66012524867273, 1.0]], [0, [4.43574481657083, 1.0]], [0, [0.8499089173980909, 1.0]], [1, [8.151809273661042, 1.0]], [1, [0.03490618011492389, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.66012525]
bas 1, expnt(s) = [4.43574482]
bas 2, expnt(s) = [0.84990892]
bas 3, expnt(s) = [8.15180927]
bas 4, expnt(s) = [0.03490618]
CPU time:       164.95
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56601252e+01 7.72793095e+01 4.43574482e+00 7.72218034e+00
 8.49908917e-01 2.23637338e+00 8.15180927e+00 4.01838834e+01
 3.49061801e-02 4.40161749e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.65683592734092
cond(S) = 5.001445371568235
E1 = -563.8743959594249  E_coul = 128.06971237326326
init E= -435.804683586162
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  mo_energy =
[-105.10121055  -15.75261091  -11.74904282  -11.74904282  -11.74904282
   -4.39660067   -1.20954545   -1.20954545   -1.20954545]
E1 = -612.991809527494  E_coul = 159.98614942114366
cycle= 1 E= -453.00566010635  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.45069e-14
diis-c [-1.19072924e-27  1.00000000e+00]
  mo_energy =
[-101.9166374   -13.23760567   -9.24138515   -9.24138515   -9.24138515
   -2.58187125   -0.34982852   -0.34982852   -0.34982852]
E1 = -612.9918095274937  E_coul = 159.9861494211436
cycle= 2 E= -453.00566010635  delta_E= 2.27e-13  |g|=    0  |ddm|= 5.39e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.9918095274937  E_coul = 159.9861494211436
  mo_energy =
[-101.9166374   -13.23760567   -9.24138515   -9.24138515   -9.24138515
   -2.58187125   -0.34982852   -0.34982852   -0.34982852]
E1 = -612.9918095274938  E_coul = 159.9861494211436
Extra cycle  E= -453.00566010635  delta_E= -1.14e-13  |g|=    0  |ddm|= 5.22e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [9.56601252e+01 4.43574482e+00 8.49908917e-01 8.15180927e+00
 3.49061801e-02]
E = -453.0056601063502
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:01 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6601252487        1
[INPUT] 0    0    [1    /1   ]  4.43574481657        1
[INPUT] 0    0    [1    /1   ]  0.849908917398       1
[INPUT] 1    0    [1    /1   ]  8.15180927366        1
[INPUT] 1    0    [1    /1   ]  0.0349061801149      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.66012524867273, 1.0]], [0, [4.43574481657083, 1.0]], [0, [0.8499089173980909, 1.0]], [1, [8.151809273661042, 1.0]], [1, [0.03490618011492389, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.66012525]
bas 1, expnt(s) = [4.43574482]
bas 2, expnt(s) = [0.84990892]
bas 3, expnt(s) = [8.15180927]
bas 4, expnt(s) = [0.03490618]
CPU time:       165.61
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56601252e+01 7.72793095e+01 4.43574482e+00 7.72218034e+00
 8.49908917e-01 2.23637338e+00 8.15180927e+00 4.01838834e+01
 3.49061801e-02 4.40161749e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.65683592734092
cond(S) = 5.001445371568235
E1 = -563.8743959594249  E_coul = 128.06971237326326
init E= -435.804683586162
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.10121055  -15.75261091  -11.74904282  -11.74904282  -11.74904282
   -4.39660067   -1.20954545   -1.20954545   -1.20954545]
E1 = -612.991809527494  E_coul = 159.98614942114366
cycle= 1 E= -453.00566010635  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.45069e-14
diis-c [-1.19072924e-27  1.00000000e+00]
  mo_energy =
[-101.9166374   -13.23760567   -9.24138515   -9.24138515   -9.24138515
   -2.58187125   -0.34982852   -0.34982852   -0.34982852]
E1 = -612.9918095274937  E_coul = 159.9861494211436
cycle= 2 E= -453.00566010635  delta_E= 2.27e-13  |g|=    0  |ddm|= 5.39e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.9918095274937  E_coul = 159.9861494211436
  mo_energy =
[-101.9166374   -13.23760567   -9.24138515   -9.24138515   -9.24138515
   -2.58187125   -0.34982852   -0.34982852   -0.34982852]
E1 = -612.9918095274938  E_coul = 159.9861494211436
Extra cycle  E= -453.00566010635  delta_E= -1.14e-13  |g|=    0  |ddm|= 5.22e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 5.001445371568235
E1 = -612.9918095274938  E_coul = 159.9861494211436
init E= -453.00566010635
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.9166374   -13.23760567   -9.24138515   -9.24138515   -9.24138515
   -2.58187125   -0.34982852   -0.34982852   -0.34982852]
E1 = -612.9918095274938  E_coul = 159.9861494211436
cycle= 1 E= -453.00566010635  delta_E=    0  |g|=    0  |ddm|= 3.33e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -612.9918095274938  E_coul = 159.9861494211436
  mo_energy =
[-101.9166374   -13.23760567   -9.24138515   -9.24138515   -9.24138515
   -2.58187125   -0.34982852   -0.34982852   -0.34982852]
E1 = -612.9918095274935  E_coul = 159.9861494211435
Extra cycle  E= -453.00566010635  delta_E= 2.27e-13  |g|=    0  |ddm|= 3.89e-15
    CPU time for scf_cycle      0.12 sec, wall time      0.13 sec
exp = [9.56601252e+01 4.43574482e+00 8.49908917e-01 8.15180927e+00
 3.49061801e-02]
grad_E = [-3.22034959e-06  1.58284592e-03  1.98243233e+00  5.05522631e-04
 -5.51447975e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:05 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6576794996        1
[INPUT] 0    0    [1    /1   ]  4.43951834767        1
[INPUT] 0    0    [1    /1   ]  0.846054627901       1
[INPUT] 1    0    [1    /1   ]  8.1521685207         1
[INPUT] 1    0    [1    /1   ]  0.0347717631409      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.6576794996489, 1.0]], [0, [4.439518347672183, 1.0]], [0, [0.8460546279006615, 1.0]], [1, [8.152168520704736, 1.0]], [1, [0.03477176314089722, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.6576795]
bas 1, expnt(s) = [4.43951835]
bas 2, expnt(s) = [0.84605463]
bas 3, expnt(s) = [8.15216852]
bas 4, expnt(s) = [0.03477176]
CPU time:       169.26
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56576795e+01 7.72778277e+01 4.43951835e+00 7.72710681e+00
 8.46054628e-01 2.22876269e+00 8.15216852e+00 4.01860970e+01
 3.47717631e-02 4.38044048e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.656680539610983
cond(S) = 4.974673964634142
E1 = -563.9011126241519  E_coul = 128.08140092136443
init E= -435.819711702787
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  mo_energy =
[-105.09993413  -15.74986041  -11.7479826   -11.7479826   -11.7479826
   -4.40088558   -1.20717219   -1.20717219   -1.20717219]
E1 = -612.9385503614121  E_coul = 159.9327101558564
cycle= 1 E= -453.005840205556  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.51217e-14
diis-c [-6.31097969e-28  1.00000000e+00]
  mo_energy =
[-101.92131722  -13.23995344   -9.24576773   -9.24576773   -9.24576773
   -2.58999962   -0.34933052   -0.34933052   -0.34933052]
E1 = -612.9385503614122  E_coul = 159.93271015585643
cycle= 2 E= -453.005840205556  delta_E= -1.14e-13  |g|=    0  |ddm|= 5.19e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.9385503614122  E_coul = 159.93271015585643
  mo_energy =
[-101.92131722  -13.23995344   -9.24576773   -9.24576773   -9.24576773
   -2.58999962   -0.34933052   -0.34933052   -0.34933052]
E1 = -612.9385503614122  E_coul = 159.93271015585637
Extra cycle  E= -453.005840205556  delta_E=    0  |g|=    0  |ddm|= 2.57e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [9.56576795e+01 4.43951835e+00 8.46054628e-01 8.15216852e+00
 3.47717631e-02]
E = -453.00584020555584
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:06 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6576794996        1
[INPUT] 0    0    [1    /1   ]  4.43951834767        1
[INPUT] 0    0    [1    /1   ]  0.846054627901       1
[INPUT] 1    0    [1    /1   ]  8.1521685207         1
[INPUT] 1    0    [1    /1   ]  0.0347717631409      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.6576794996489, 1.0]], [0, [4.439518347672183, 1.0]], [0, [0.8460546279006615, 1.0]], [1, [8.152168520704736, 1.0]], [1, [0.03477176314089722, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.6576795]
bas 1, expnt(s) = [4.43951835]
bas 2, expnt(s) = [0.84605463]
bas 3, expnt(s) = [8.15216852]
bas 4, expnt(s) = [0.03477176]
CPU time:       169.91
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56576795e+01 7.72778277e+01 4.43951835e+00 7.72710681e+00
 8.46054628e-01 2.22876269e+00 8.15216852e+00 4.01860970e+01
 3.47717631e-02 4.38044048e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.656680539610983
cond(S) = 4.974673964634142
E1 = -563.9011126241519  E_coul = 128.08140092136443
init E= -435.819711702787
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.09993413  -15.74986041  -11.7479826   -11.7479826   -11.7479826
   -4.40088558   -1.20717219   -1.20717219   -1.20717219]
E1 = -612.9385503614121  E_coul = 159.9327101558564
cycle= 1 E= -453.005840205556  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.51217e-14
diis-c [-6.31097969e-28  1.00000000e+00]
  mo_energy =
[-101.92131722  -13.23995344   -9.24576773   -9.24576773   -9.24576773
   -2.58999962   -0.34933052   -0.34933052   -0.34933052]
E1 = -612.9385503614122  E_coul = 159.93271015585643
cycle= 2 E= -453.005840205556  delta_E= -1.14e-13  |g|=    0  |ddm|= 5.19e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.9385503614122  E_coul = 159.93271015585643
  mo_energy =
[-101.92131722  -13.23995344   -9.24576773   -9.24576773   -9.24576773
   -2.58999962   -0.34933052   -0.34933052   -0.34933052]
E1 = -612.9385503614122  E_coul = 159.93271015585637
Extra cycle  E= -453.005840205556  delta_E=    0  |g|=    0  |ddm|= 2.57e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 4.974673964634142
E1 = -612.9385503614122  E_coul = 159.93271015585637
init E= -453.005840205556
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.92131722  -13.23995344   -9.24576773   -9.24576773   -9.24576773
   -2.58999962   -0.34933052   -0.34933052   -0.34933052]
E1 = -612.9385503614124  E_coul = 159.93271015585648
cycle= 1 E= -453.005840205556  delta_E=    0  |g|=    0  |ddm|= 3.38e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -612.9385503614124  E_coul = 159.93271015585648
  mo_energy =
[-101.92131722  -13.23995344   -9.24576773   -9.24576773   -9.24576773
   -2.58999962   -0.34933052   -0.34933052   -0.34933052]
E1 = -612.938550361412  E_coul = 159.93271015585643
Extra cycle  E= -453.005840205556  delta_E= 2.27e-13  |g|=    0  |ddm|= 2.64e-15
    CPU time for scf_cycle      0.10 sec, wall time      0.11 sec
exp = [9.56576795e+01 4.43951835e+00 8.46054628e-01 8.15216852e+00
 3.47717631e-02]
grad_E = [-3.14778861e-05  3.05100692e-03  1.96676211e+00  7.24059682e-04
 -5.52825994e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:09 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6536110635        1
[INPUT] 0    0    [1    /1   ]  4.44567849287        1
[INPUT] 0    0    [1    /1   ]  0.839738697148       1
[INPUT] 1    0    [1    /1   ]  8.15276465986        1
[INPUT] 1    0    [1    /1   ]  0.0345581285244      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.65361106353879, 1.0]], [0, [4.445678492874291, 1.0]], [0, [0.8397386971482227, 1.0]], [1, [8.152764659858818, 1.0]], [1, [0.03455812852437524, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.65361106]
bas 1, expnt(s) = [4.44567849]
bas 2, expnt(s) = [0.8397387]
bas 3, expnt(s) = [8.15276466]
bas 4, expnt(s) = [0.03455813]
CPU time:       173.15
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56536111e+01 7.72753626e+01 4.44567849e+00 7.73514685e+00
 8.39738697e-01 2.21627246e+00 8.15276466e+00 4.01897704e+01
 3.45581285e-02 4.34682506e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.656628868850252
cond(S) = 4.931196855736081
E1 = -563.9454773256706  E_coul = 128.1008902565642
init E= -435.844587069106
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  mo_energy =
[-105.09780815  -15.74529102  -11.7462196   -11.7462196   -11.7462196
   -4.40782668   -1.20335481   -1.20335481   -1.20335481]
E1 = -612.8525672904705  E_coul = 159.8462484444817
cycle= 1 E= -453.006318845989  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.83273e-14
diis-c [-1.46897991e-27  1.00000000e+00]
  mo_energy =
[-101.92890517  -13.24369162   -9.25287741   -9.25287741   -9.25287741
   -2.60319833   -0.34853595   -0.34853595   -0.34853595]
E1 = -612.8525672904703  E_coul = 159.8462484444817
cycle= 2 E= -453.006318845989  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.85e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.8525672904703  E_coul = 159.8462484444817
  mo_energy =
[-101.92890517  -13.24369162   -9.25287741   -9.25287741   -9.25287741
   -2.60319833   -0.34853595   -0.34853595   -0.34853595]
E1 = -612.8525672904703  E_coul = 159.8462484444817
Extra cycle  E= -453.006318845989  delta_E=    0  |g|=    0  |ddm|= 2.66e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
exp = [9.56536111e+01 4.44567849e+00 8.39738697e-01 8.15276466e+00
 3.45581285e-02]
E = -453.00631884598863
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:10 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6536110635        1
[INPUT] 0    0    [1    /1   ]  4.44567849287        1
[INPUT] 0    0    [1    /1   ]  0.839738697148       1
[INPUT] 1    0    [1    /1   ]  8.15276465986        1
[INPUT] 1    0    [1    /1   ]  0.0345581285244      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.65361106353879, 1.0]], [0, [4.445678492874291, 1.0]], [0, [0.8397386971482227, 1.0]], [1, [8.152764659858818, 1.0]], [1, [0.03455812852437524, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.65361106]
bas 1, expnt(s) = [4.44567849]
bas 2, expnt(s) = [0.8397387]
bas 3, expnt(s) = [8.15276466]
bas 4, expnt(s) = [0.03455813]
CPU time:       173.83
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56536111e+01 7.72753626e+01 4.44567849e+00 7.73514685e+00
 8.39738697e-01 2.21627246e+00 8.15276466e+00 4.01897704e+01
 3.45581285e-02 4.34682506e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.656628868850252
cond(S) = 4.931196855736081
E1 = -563.9454773256706  E_coul = 128.1008902565642
init E= -435.844587069106
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.09780815  -15.74529102  -11.7462196   -11.7462196   -11.7462196
   -4.40782668   -1.20335481   -1.20335481   -1.20335481]
E1 = -612.8525672904705  E_coul = 159.8462484444817
cycle= 1 E= -453.006318845989  delta_E= -17.2  |g|=    0  |ddm|= 3.33
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=3.83273e-14
diis-c [-1.46897991e-27  1.00000000e+00]
  mo_energy =
[-101.92890517  -13.24369162   -9.25287741   -9.25287741   -9.25287741
   -2.60319833   -0.34853595   -0.34853595   -0.34853595]
E1 = -612.8525672904703  E_coul = 159.8462484444817
cycle= 2 E= -453.006318845989  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.85e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.8525672904703  E_coul = 159.8462484444817
  mo_energy =
[-101.92890517  -13.24369162   -9.25287741   -9.25287741   -9.25287741
   -2.60319833   -0.34853595   -0.34853595   -0.34853595]
E1 = -612.8525672904703  E_coul = 159.8462484444817
Extra cycle  E= -453.006318845989  delta_E=    0  |g|=    0  |ddm|= 2.66e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 4.931196855736081
E1 = -612.8525672904703  E_coul = 159.8462484444817
init E= -453.006318845989
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.92890517  -13.24369162   -9.25287741   -9.25287741   -9.25287741
   -2.60319833   -0.34853595   -0.34853595   -0.34853595]
E1 = -612.8525672904705  E_coul = 159.84624844448174
cycle= 1 E= -453.006318845989  delta_E= -1.14e-13  |g|=    0  |ddm|= 4.17e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -612.8525672904705  E_coul = 159.84624844448174
  mo_energy =
[-101.92890517  -13.24369162   -9.25287741   -9.25287741   -9.25287741
   -2.60319833   -0.34853595   -0.34853595   -0.34853595]
E1 = -612.8525672904706  E_coul = 159.84624844448174
Extra cycle  E= -453.006318845989  delta_E= -1.14e-13  |g|=    0  |ddm|= 3.41e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.56536111e+01 4.44567849e+00 8.39738697e-01 8.15276466e+00
 3.45581285e-02]
grad_E = [-7.82933310e-05  5.48245377e-03  1.94054201e+00  1.08580920e-03
 -5.55034018e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:13 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6468899495        1
[INPUT] 0    0    [1    /1   ]  4.45555579265        1
[INPUT] 0    0    [1    /1   ]  0.829548374096       1
[INPUT] 1    0    [1    /1   ]  8.15374639079        1
[INPUT] 1    0    [1    /1   ]  0.0342308438997      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.6468899494518, 1.0]], [0, [4.455555792652234, 1.0]], [0, [0.8295483740963839, 1.0]], [1, [8.153746390794755, 1.0]], [1, [0.03423084389971605, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.64688995]
bas 1, expnt(s) = [4.45555579]
bas 2, expnt(s) = [0.82954837]
bas 3, expnt(s) = [8.15374639]
bas 4, expnt(s) = [0.03423084]
CPU time:       177.35
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56468899e+01 7.72712903e+01 4.45555579e+00 7.74803259e+00
 8.29548374e-01 2.19607067e+00 8.15374639e+00 4.01958199e+01
 3.42308439e-02 4.29542757e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.65707234612949
cond(S) = 4.862059871649979
E1 = -564.0185024642814  E_coul = 128.13315764211725
init E= -435.885344822164
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.09429336  -15.73776078  -11.74331336  -11.74331336  -11.74331336
   -4.41881328   -1.19738788   -1.19738788   -1.19738788]
E1 = -612.7172616743646  E_coul = 159.70968670952476
cycle= 1 E= -453.00757496484  delta_E= -17.1  |g|=    0  |ddm|= 3.32
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.07723e-14
diis-c [-4.3148708e-28  1.0000000e+00]
  mo_energy =
[-101.94093356  -13.24943472   -9.2641576    -9.2641576    -9.2641576
   -2.62416878   -0.34731142   -0.34731142   -0.34731142]
E1 = -612.7172616743646  E_coul = 159.70968670952476
cycle= 2 E= -453.00757496484  delta_E=    0  |g|=    0  |ddm|= 2.7e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.7172616743646  E_coul = 159.70968670952476
  mo_energy =
[-101.94093356  -13.24943472   -9.2641576    -9.2641576    -9.2641576
   -2.62416878   -0.34731142   -0.34731142   -0.34731142]
E1 = -612.7172616743646  E_coul = 159.70968670952473
Extra cycle  E= -453.00757496484  delta_E= -5.68e-14  |g|=    0  |ddm|= 4.04e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.56468899e+01 4.45555579e+00 8.29548374e-01 8.15374639e+00
 3.42308439e-02]
E = -453.00757496483993
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:14 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6468899495        1
[INPUT] 0    0    [1    /1   ]  4.45555579265        1
[INPUT] 0    0    [1    /1   ]  0.829548374096       1
[INPUT] 1    0    [1    /1   ]  8.15374639079        1
[INPUT] 1    0    [1    /1   ]  0.0342308438997      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.6468899494518, 1.0]], [0, [4.455555792652234, 1.0]], [0, [0.8295483740963839, 1.0]], [1, [8.153746390794755, 1.0]], [1, [0.03423084389971605, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.64688995]
bas 1, expnt(s) = [4.45555579]
bas 2, expnt(s) = [0.82954837]
bas 3, expnt(s) = [8.15374639]
bas 4, expnt(s) = [0.03423084]
CPU time:       178.12
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56468899e+01 7.72712903e+01 4.45555579e+00 7.74803259e+00
 8.29548374e-01 2.19607067e+00 8.15374639e+00 4.01958199e+01
 3.42308439e-02 4.29542757e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.65707234612949
cond(S) = 4.862059871649979
E1 = -564.0185024642814  E_coul = 128.13315764211725
init E= -435.885344822164
    CPU time for initialize scf      0.02 sec, wall time      0.03 sec
  mo_energy =
[-105.09429336  -15.73776078  -11.74331336  -11.74331336  -11.74331336
   -4.41881328   -1.19738788   -1.19738788   -1.19738788]
E1 = -612.7172616743646  E_coul = 159.70968670952476
cycle= 1 E= -453.00757496484  delta_E= -17.1  |g|=    0  |ddm|= 3.32
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.07723e-14
diis-c [-4.3148708e-28  1.0000000e+00]
  mo_energy =
[-101.94093356  -13.24943472   -9.2641576    -9.2641576    -9.2641576
   -2.62416878   -0.34731142   -0.34731142   -0.34731142]
E1 = -612.7172616743646  E_coul = 159.70968670952476
cycle= 2 E= -453.00757496484  delta_E=    0  |g|=    0  |ddm|= 2.7e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.7172616743646  E_coul = 159.70968670952476
  mo_energy =
[-101.94093356  -13.24943472   -9.2641576    -9.2641576    -9.2641576
   -2.62416878   -0.34731142   -0.34731142   -0.34731142]
E1 = -612.7172616743646  E_coul = 159.70968670952473
Extra cycle  E= -453.00757496484  delta_E= -5.68e-14  |g|=    0  |ddm|= 4.04e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.08 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 4.862059871649979
E1 = -612.7172616743646  E_coul = 159.70968670952473
init E= -453.00757496484
    CPU time for initialize scf      0.09 sec, wall time      0.14 sec
  mo_energy =
[-101.94093356  -13.24943472   -9.2641576    -9.2641576    -9.2641576
   -2.62416878   -0.34731142   -0.34731142   -0.34731142]
E1 = -612.7172616743646  E_coul = 159.70968670952476
cycle= 1 E= -453.00757496484  delta_E= 5.68e-14  |g|=    0  |ddm|= 1.96e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -612.7172616743646  E_coul = 159.70968670952476
  mo_energy =
[-101.94093356  -13.24943472   -9.2641576    -9.2641576    -9.2641576
   -2.62416878   -0.34731142   -0.34731142   -0.34731142]
E1 = -612.7172616743647  E_coul = 159.70968670952482
Extra cycle  E= -453.00757496484  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.82e-15
    CPU time for scf_cycle      0.18 sec, wall time      0.34 sec
exp = [9.56468899e+01 4.45555579e+00 8.29548374e-01 8.15374639e+00
 3.42308439e-02]
grad_E = [-1.55133080e-04  9.47257098e-03  1.89678954e+00  1.67937936e-03
 -5.58460536e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:20 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6355675311        1
[INPUT] 0    0    [1    /1   ]  4.47142566342        1
[INPUT] 0    0    [1    /1   ]  0.813008707786       1
[INPUT] 1    0    [1    /1   ]  8.15539241493        1
[INPUT] 1    0    [1    /1   ]  0.0337456056574      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.63556753111153, 1.0]], [0, [4.471425663418801, 1.0]], [0, [0.8130087077855327, 1.0]], [1, [8.155392414933512, 1.0]], [1, [0.0337456056573945, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.63556753]
bas 1, expnt(s) = [4.47142566]
bas 2, expnt(s) = [0.81300871]
bas 3, expnt(s) = [8.15539241]
bas 4, expnt(s) = [0.03374561]
CPU time:       182.51
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56355675e+01 7.72644298e+01 4.47142566e+00 7.76872119e+00
 8.13008708e-01 2.16314894e+00 8.15539241e+00 4.02059632e+01
 3.37456057e-02 4.21945079e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.659159206007054
cond(S) = 4.752427007839424
E1 = -564.1404654800106  E_coul = 128.18745350454228
init E= -435.953011975468
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.08839023  -15.72514513  -11.73845667  -11.73845667  -11.73845667
   -4.43607819   -1.18822833   -1.18822833   -1.18822833]
E1 = -612.5068297029878  E_coul = 159.4959281300069
cycle= 1 E= -453.010901572981  delta_E= -17.1  |g|=    0  |ddm|= 3.31
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.85352e-14
diis-c [-2.35566754e-27  1.00000000e+00]
  mo_energy =
[-101.95988233  -13.25798651   -9.28195362   -9.28195362   -9.28195362
   -2.65731654   -0.34548016   -0.34548016   -0.34548016]
E1 = -612.5068297029875  E_coul = 159.4959281300068
cycle= 2 E= -453.010901572981  delta_E= 2.84e-13  |g|=    0  |ddm|= 1.92e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.5068297029875  E_coul = 159.4959281300068
  mo_energy =
[-101.95988233  -13.25798651   -9.28195362   -9.28195362   -9.28195362
   -2.65731654   -0.34548016   -0.34548016   -0.34548016]
E1 = -612.5068297029875  E_coul = 159.4959281300068
Extra cycle  E= -453.010901572981  delta_E=    0  |g|=    0  |ddm|= 3.31e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.56355675e+01 4.47142566e+00 8.13008708e-01 8.15539241e+00
 3.37456057e-02]
E = -453.0109015729807
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:21 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6355675311        1
[INPUT] 0    0    [1    /1   ]  4.47142566342        1
[INPUT] 0    0    [1    /1   ]  0.813008707786       1
[INPUT] 1    0    [1    /1   ]  8.15539241493        1
[INPUT] 1    0    [1    /1   ]  0.0337456056574      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.63556753111153, 1.0]], [0, [4.471425663418801, 1.0]], [0, [0.8130087077855327, 1.0]], [1, [8.155392414933512, 1.0]], [1, [0.0337456056573945, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.63556753]
bas 1, expnt(s) = [4.47142566]
bas 2, expnt(s) = [0.81300871]
bas 3, expnt(s) = [8.15539241]
bas 4, expnt(s) = [0.03374561]
CPU time:       183.19
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56355675e+01 7.72644298e+01 4.47142566e+00 7.76872119e+00
 8.13008708e-01 2.16314894e+00 8.15539241e+00 4.02059632e+01
 3.37456057e-02 4.21945079e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.659159206007054
cond(S) = 4.752427007839424
E1 = -564.1404654800106  E_coul = 128.18745350454228
init E= -435.953011975468
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.08839023  -15.72514513  -11.73845667  -11.73845667  -11.73845667
   -4.43607819   -1.18822833   -1.18822833   -1.18822833]
E1 = -612.5068297029878  E_coul = 159.4959281300069
cycle= 1 E= -453.010901572981  delta_E= -17.1  |g|=    0  |ddm|= 3.31
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.85352e-14
diis-c [-2.35566754e-27  1.00000000e+00]
  mo_energy =
[-101.95988233  -13.25798651   -9.28195362   -9.28195362   -9.28195362
   -2.65731654   -0.34548016   -0.34548016   -0.34548016]
E1 = -612.5068297029875  E_coul = 159.4959281300068
cycle= 2 E= -453.010901572981  delta_E= 2.84e-13  |g|=    0  |ddm|= 1.92e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.5068297029875  E_coul = 159.4959281300068
  mo_energy =
[-101.95988233  -13.25798651   -9.28195362   -9.28195362   -9.28195362
   -2.65731654   -0.34548016   -0.34548016   -0.34548016]
E1 = -612.5068297029875  E_coul = 159.4959281300068
Extra cycle  E= -453.010901572981  delta_E=    0  |g|=    0  |ddm|= 3.31e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 4.752427007839424
E1 = -612.5068297029875  E_coul = 159.4959281300068
init E= -453.010901572981
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.95988233  -13.25798651   -9.28195362   -9.28195362   -9.28195362
   -2.65731654   -0.34548016   -0.34548016   -0.34548016]
E1 = -612.5068297029876  E_coul = 159.4959281300068
cycle= 1 E= -453.010901572981  delta_E= -1.14e-13  |g|=    0  |ddm|= 1.9e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -612.5068297029876  E_coul = 159.4959281300068
  mo_energy =
[-101.95988233  -13.25798651   -9.28195362   -9.28195362   -9.28195362
   -2.65731654   -0.34548016   -0.34548016   -0.34548016]
E1 = -612.5068297029875  E_coul = 159.49592813000683
Extra cycle  E= -453.010901572981  delta_E= 1.71e-13  |g|=    0  |ddm|= 3.02e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.56355675e+01 4.47142566e+00 8.13008708e-01 8.15539241e+00
 3.37456057e-02]
grad_E = [-2.83330010e-04  1.61275524e-02  1.82183941e+00  2.66940243e-03
 -5.63643745e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:24 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6161850019        1
[INPUT] 0    0    [1    /1   ]  4.49664164593        1
[INPUT] 0    0    [1    /1   ]  0.786288459375       1
[INPUT] 1    0    [1    /1   ]  8.1581906417         1
[INPUT] 1    0    [1    /1   ]  0.0330835279499      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.61618500186978, 1.0]], [0, [4.4966416459261715, 1.0]], [0, [0.7862884593745911, 1.0]], [1, [8.158190641702108, 1.0]], [1, [0.03308352794994804, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.616185]
bas 1, expnt(s) = [4.49664165]
bas 2, expnt(s) = [0.78628846]
bas 3, expnt(s) = [8.15819064]
bas 4, expnt(s) = [0.03308353]
CPU time:       186.56
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56161850e+01 7.72526851e+01 4.49664165e+00 7.80155605e+00
 7.86288459e-01 2.10960648e+00 8.15819064e+00 4.02232080e+01
 3.30835279e-02 4.11622553e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.66604718434504
cond(S) = 4.58176594742707
E1 = -564.3450040949684  E_coul = 128.27922689233256
init E= -436.065777202636
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.0784343   -15.70382363  -11.73033883  -11.73033883  -11.73033883
   -4.46243918   -1.17489255   -1.17489255   -1.17489255]
E1 = -612.1917745832641  E_coul = 159.1720465837261
cycle= 1 E= -453.019727999538  delta_E=  -17  |g|=    0  |ddm|=  3.3
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.24541e-14
diis-c [-3.9005175e-27  1.0000000e+00]
  mo_energy =
[-101.9889387   -13.26973143   -9.30930904   -9.30930904   -9.30930904
   -2.70838192   -0.34295384   -0.34295384   -0.34295384]
E1 = -612.1917745832637  E_coul = 159.1720465837261
cycle= 2 E= -453.019727999538  delta_E= 3.41e-13  |g|=    0  |ddm|= 4e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -612.1917745832637  E_coul = 159.1720465837261
  mo_energy =
[-101.9889387   -13.26973143   -9.30930904   -9.30930904   -9.30930904
   -2.70838192   -0.34295384   -0.34295384   -0.34295384]
E1 = -612.1917745832637  E_coul = 159.172046583726
Extra cycle  E= -453.019727999538  delta_E= -1.14e-13  |g|=    0  |ddm|= 3.25e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [9.56161850e+01 4.49664165e+00 7.86288459e-01 8.15819064e+00
 3.30835279e-02]
E = -453.01972799953774
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:25 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.6161850019        1
[INPUT] 0    0    [1    /1   ]  4.49664164593        1
[INPUT] 0    0    [1    /1   ]  0.786288459375       1
[INPUT] 1    0    [1    /1   ]  8.1581906417         1
[INPUT] 1    0    [1    /1   ]  0.0330835279499      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.61618500186978, 1.0]], [0, [4.4966416459261715, 1.0]], [0, [0.7862884593745911, 1.0]], [1, [8.158190641702108, 1.0]], [1, [0.03308352794994804, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.616185]
bas 1, expnt(s) = [4.49664165]
bas 2, expnt(s) = [0.78628846]
bas 3, expnt(s) = [8.15819064]
bas 4, expnt(s) = [0.03308353]
CPU time:       187.25
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.56161850e+01 7.72526851e+01 4.49664165e+00 7.80155605e+00
 7.86288459e-01 2.10960648e+00 8.15819064e+00 4.02232080e+01
 3.30835279e-02 4.11622553e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.66604718434504
cond(S) = 4.58176594742707
E1 = -564.3450040949684  E_coul = 128.27922689233256
init E= -436.065777202636
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.0784343   -15.70382363  -11.73033883  -11.73033883  -11.73033883
   -4.46243918   -1.17489255   -1.17489255   -1.17489255]
E1 = -612.1917745832641  E_coul = 159.1720465837261
cycle= 1 E= -453.019727999538  delta_E=  -17  |g|=    0  |ddm|=  3.3
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.24541e-14
diis-c [-3.9005175e-27  1.0000000e+00]
  mo_energy =
[-101.9889387   -13.26973143   -9.30930904   -9.30930904   -9.30930904
   -2.70838192   -0.34295384   -0.34295384   -0.34295384]
E1 = -612.1917745832637  E_coul = 159.1720465837261
cycle= 2 E= -453.019727999538  delta_E= 3.41e-13  |g|=    0  |ddm|= 4e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.1917745832637  E_coul = 159.1720465837261
  mo_energy =
[-101.9889387   -13.26973143   -9.30930904   -9.30930904   -9.30930904
   -2.70838192   -0.34295384   -0.34295384   -0.34295384]
E1 = -612.1917745832637  E_coul = 159.172046583726
Extra cycle  E= -453.019727999538  delta_E= -1.14e-13  |g|=    0  |ddm|= 3.25e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 4.58176594742707
E1 = -612.1917745832637  E_coul = 159.172046583726
init E= -453.019727999538
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.9889387   -13.26973143   -9.30930904   -9.30930904   -9.30930904
   -2.70838192   -0.34295384   -0.34295384   -0.34295384]
E1 = -612.1917745832637  E_coul = 159.17204658372606
cycle= 1 E= -453.019727999538  delta_E= 5.68e-14  |g|=    0  |ddm|= 2.57e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -612.1917745832637  E_coul = 159.17204658372606
  mo_energy =
[-101.9889387   -13.26973143   -9.30930904   -9.30930904   -9.30930904
   -2.70838192   -0.34295384   -0.34295384   -0.34295384]
E1 = -612.1917745832639  E_coul = 159.1720465837261
Extra cycle  E= -453.019727999538  delta_E= -5.68e-14  |g|=    0  |ddm|= 6.22e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.56161850e+01 4.49664165e+00 7.86288459e-01 8.15819064e+00
 3.30835279e-02]
grad_E = [-4.99808109e-04  2.73552339e-02  1.68987565e+00  4.34083226e-03
 -5.70936204e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:28 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.5822577114        1
[INPUT] 0    0    [1    /1   ]  4.53594560016        1
[INPUT] 0    0    [1    /1   ]  0.743481654981       1
[INPUT] 1    0    [1    /1   ]  8.16304190532        1
[INPUT] 1    0    [1    /1   ]  0.0323482911272      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.58225771136138, 1.0]], [0, [4.53594560015658, 1.0]], [0, [0.7434816549813468, 1.0]], [1, [8.163041905319574, 1.0]], [1, [0.03234829112716869, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.58225771]
bas 1, expnt(s) = [4.5359456]
bas 2, expnt(s) = [0.74348165]
bas 3, expnt(s) = [8.16304191]
bas 4, expnt(s) = [0.03234829]
CPU time:       190.66
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.55822577e+01 7.72321256e+01 4.53594560e+00 7.85264388e+00
 7.43481655e-01 2.02286880e+00 8.16304191e+00 4.02531086e+01
 3.23482911e-02 4.00219801e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.68602726509964
cond(S) = 4.3238489275377
E1 = -564.6861865597774  E_coul = 128.43293804416598
init E= -436.253248515611
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.06179285  -15.6675959   -11.71700208  -11.71700208  -11.71700208
   -4.50045421   -1.15768426   -1.15768426   -1.15768426]
E1 = -611.7558475321852  E_coul = 158.71260537155098
cycle= 1 E= -453.043242160634  delta_E= -16.8  |g|=    0  |ddm|= 3.29
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.77508e-14
diis-c [-2.28013761e-27  1.00000000e+00]
  mo_energy =
[-102.03119454  -13.28292331   -9.34926156   -9.34926156   -9.34926156
   -2.78302815   -0.34012923   -0.34012923   -0.34012923]
E1 = -611.7558475321853  E_coul = 158.71260537155104
cycle= 2 E= -453.043242160634  delta_E= -5.68e-14  |g|=    0  |ddm|= 4.88e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -611.7558475321853  E_coul = 158.71260537155104
  mo_energy =
[-102.03119454  -13.28292331   -9.34926156   -9.34926156   -9.34926156
   -2.78302815   -0.34012923   -0.34012923   -0.34012923]
E1 = -611.7558475321853  E_coul = 158.71260537155104
Extra cycle  E= -453.043242160634  delta_E=    0  |g|=    0  |ddm|= 2.43e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.55822577e+01 4.53594560e+00 7.43481655e-01 8.16304191e+00
 3.23482911e-02]
E = -453.04324216063424
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:29 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.5822577114        1
[INPUT] 0    0    [1    /1   ]  4.53594560016        1
[INPUT] 0    0    [1    /1   ]  0.743481654981       1
[INPUT] 1    0    [1    /1   ]  8.16304190532        1
[INPUT] 1    0    [1    /1   ]  0.0323482911272      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.58225771136138, 1.0]], [0, [4.53594560015658, 1.0]], [0, [0.7434816549813468, 1.0]], [1, [8.163041905319574, 1.0]], [1, [0.03234829112716869, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.58225771]
bas 1, expnt(s) = [4.5359456]
bas 2, expnt(s) = [0.74348165]
bas 3, expnt(s) = [8.16304191]
bas 4, expnt(s) = [0.03234829]
CPU time:       191.47
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.55822577e+01 7.72321256e+01 4.53594560e+00 7.85264388e+00
 7.43481655e-01 2.02286880e+00 8.16304191e+00 4.02531086e+01
 3.23482911e-02 4.00219801e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.68602726509964
cond(S) = 4.3238489275377
E1 = -564.6861865597774  E_coul = 128.43293804416598
init E= -436.253248515611
    CPU time for initialize scf      0.03 sec, wall time      0.03 sec
  mo_energy =
[-105.06179285  -15.6675959   -11.71700208  -11.71700208  -11.71700208
   -4.50045421   -1.15768426   -1.15768426   -1.15768426]
E1 = -611.7558475321852  E_coul = 158.71260537155098
cycle= 1 E= -453.043242160634  delta_E= -16.8  |g|=    0  |ddm|= 3.29
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.77508e-14
diis-c [-2.28013761e-27  1.00000000e+00]
  mo_energy =
[-102.03119454  -13.28292331   -9.34926156   -9.34926156   -9.34926156
   -2.78302815   -0.34012923   -0.34012923   -0.34012923]
E1 = -611.7558475321853  E_coul = 158.71260537155104
cycle= 2 E= -453.043242160634  delta_E= -5.68e-14  |g|=    0  |ddm|= 4.88e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -611.7558475321853  E_coul = 158.71260537155104
  mo_energy =
[-102.03119454  -13.28292331   -9.34926156   -9.34926156   -9.34926156
   -2.78302815   -0.34012923   -0.34012923   -0.34012923]
E1 = -611.7558475321853  E_coul = 158.71260537155104
Extra cycle  E= -453.043242160634  delta_E=    0  |g|=    0  |ddm|= 2.43e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 4.3238489275377
E1 = -611.7558475321853  E_coul = 158.71260537155104
init E= -453.043242160634
    CPU time for initialize scf      0.07 sec, wall time      0.07 sec
  mo_energy =
[-102.03119454  -13.28292331   -9.34926156   -9.34926156   -9.34926156
   -2.78302815   -0.34012923   -0.34012923   -0.34012923]
E1 = -611.755847532185  E_coul = 158.71260537155092
cycle= 1 E= -453.043242160634  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.62e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -611.755847532185  E_coul = 158.71260537155092
  mo_energy =
[-102.03119454  -13.28292331   -9.34926156   -9.34926156   -9.34926156
   -2.78302815   -0.34012923   -0.34012923   -0.34012923]
E1 = -611.755847532185  E_coul = 158.71260537155092
Extra cycle  E= -453.043242160634  delta_E=    0  |g|=    0  |ddm|= 3.3e-15
    CPU time for scf_cycle      0.15 sec, wall time      0.16 sec
exp = [9.55822577e+01 4.53594560e+00 7.43481655e-01 8.16304191e+00
 3.23482911e-02]
grad_E = [-8.72157176e-04  4.66012537e-02  1.44774578e+00  7.21634664e-03
 -5.79430295e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:33 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.5221219061        1
[INPUT] 0    0    [1    /1   ]  4.59418634224        1
[INPUT] 0    0    [1    /1   ]  0.677052178532       1
[INPUT] 1    0    [1    /1   ]  8.17154311756        1
[INPUT] 1    0    [1    /1   ]  0.0320857444375      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.52212190608527, 1.0]], [0, [4.594186342241694, 1.0]], [0, [0.6770521785318717, 1.0]], [1, [8.17154311755968, 1.0]], [1, [0.03208574443753685, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.52212191]
bas 1, expnt(s) = [4.59418634]
bas 2, expnt(s) = [0.67705218]
bas 3, expnt(s) = [8.17154312]
bas 4, expnt(s) = [0.03208574]
CPU time:       195.04
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.55221219e+01 7.71956796e+01 4.59418634e+00 7.92814308e+00
 6.77052179e-01 1.88573920e+00 8.17154312e+00 4.03055163e+01
 3.20857444e-02 3.96163575e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.73949387826953
cond(S) = 3.9575562119208576
E1 = -565.2289062514699  E_coul = 128.67548956964828
init E= -436.553416681822
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.03557844  -15.60757586  -11.6967581   -11.6967581   -11.6967581
   -4.54754605   -1.14286059   -1.14286059   -1.14286059]
E1 = -611.2729903071289  E_coul = 158.16736945543627
cycle= 1 E= -453.105620851693  delta_E= -16.6  |g|=    0  |ddm|= 3.26
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.56101e-14
diis-c [-2.08027778e-27  1.00000000e+00]
  mo_energy =
[-102.08468264  -13.28813986   -9.40026942   -9.40026942   -9.40026942
   -2.8777449    -0.33925001   -0.33925001   -0.33925001]
E1 = -611.2729903071285  E_coul = 158.16736945543613
cycle= 2 E= -453.105620851692  delta_E= 2.84e-13  |g|=    0  |ddm|= 3.23e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -611.2729903071285  E_coul = 158.16736945543613
  mo_energy =
[-102.08468264  -13.28813986   -9.40026942   -9.40026942   -9.40026942
   -2.8777449    -0.33925001   -0.33925001   -0.33925001]
E1 = -611.2729903071285  E_coul = 158.1673694554361
Extra cycle  E= -453.105620851692  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.4e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [9.55221219e+01 4.59418634e+00 6.77052179e-01 8.17154312e+00
 3.20857444e-02]
E = -453.1056208516924
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:34 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.5221219061        1
[INPUT] 0    0    [1    /1   ]  4.59418634224        1
[INPUT] 0    0    [1    /1   ]  0.677052178532       1
[INPUT] 1    0    [1    /1   ]  8.17154311756        1
[INPUT] 1    0    [1    /1   ]  0.0320857444375      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.52212190608527, 1.0]], [0, [4.594186342241694, 1.0]], [0, [0.6770521785318717, 1.0]], [1, [8.17154311755968, 1.0]], [1, [0.03208574443753685, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.52212191]
bas 1, expnt(s) = [4.59418634]
bas 2, expnt(s) = [0.67705218]
bas 3, expnt(s) = [8.17154312]
bas 4, expnt(s) = [0.03208574]
CPU time:       195.74
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.55221219e+01 7.71956796e+01 4.59418634e+00 7.92814308e+00
 6.77052179e-01 1.88573920e+00 8.17154312e+00 4.03055163e+01
 3.20857444e-02 3.96163575e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.73949387826953
cond(S) = 3.9575562119208576
E1 = -565.2289062514699  E_coul = 128.67548956964828
init E= -436.553416681822
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-105.03557844  -15.60757586  -11.6967581   -11.6967581   -11.6967581
   -4.54754605   -1.14286059   -1.14286059   -1.14286059]
E1 = -611.2729903071289  E_coul = 158.16736945543627
cycle= 1 E= -453.105620851693  delta_E= -16.6  |g|=    0  |ddm|= 3.26
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.56101e-14
diis-c [-2.08027778e-27  1.00000000e+00]
  mo_energy =
[-102.08468264  -13.28813986   -9.40026942   -9.40026942   -9.40026942
   -2.8777449    -0.33925001   -0.33925001   -0.33925001]
E1 = -611.2729903071285  E_coul = 158.16736945543613
cycle= 2 E= -453.105620851692  delta_E= 2.84e-13  |g|=    0  |ddm|= 3.23e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -611.2729903071285  E_coul = 158.16736945543613
  mo_energy =
[-102.08468264  -13.28813986   -9.40026942   -9.40026942   -9.40026942
   -2.8777449    -0.33925001   -0.33925001   -0.33925001]
E1 = -611.2729903071285  E_coul = 158.1673694554361
Extra cycle  E= -453.105620851692  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.4e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 3.9575562119208576
E1 = -611.2729903071285  E_coul = 158.1673694554361
init E= -453.105620851692
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-102.08468264  -13.28813986   -9.40026942   -9.40026942   -9.40026942
   -2.8777449    -0.33925001   -0.33925001   -0.33925001]
E1 = -611.2729903071285  E_coul = 158.16736945543613
cycle= 1 E= -453.105620851692  delta_E= 5.68e-14  |g|=    0  |ddm|= 1.97e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -611.2729903071285  E_coul = 158.16736945543613
  mo_energy =
[-102.08468264  -13.28813986   -9.40026942   -9.40026942   -9.40026942
   -2.8777449    -0.33925001   -0.33925001   -0.33925001]
E1 = -611.2729903071283  E_coul = 158.1673694554361
Extra cycle  E= -453.105620851692  delta_E= 5.68e-14  |g|=    0  |ddm|= 2.96e-15
    CPU time for scf_cycle      0.10 sec, wall time      0.10 sec
exp = [9.55221219e+01 4.59418634e+00 6.77052179e-01 8.17154312e+00
 3.20857444e-02]
grad_E = [-1.51999129e-03  7.96161558e-02  9.84754215e-01  1.22285974e-02
 -5.83139955e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:37 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.4186449817        1
[INPUT] 0    0    [1    /1   ]  4.66992642691        1
[INPUT] 0    0    [1    /1   ]  0.583331547268       1
[INPUT] 1    0    [1    /1   ]  8.18605622075        1
[INPUT] 1    0    [1    /1   ]  0.0341287877427      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.41864498174918, 1.0]], [0, [4.669926426912684, 1.0]], [0, [0.5833315472678869, 1.0]], [1, [8.18605622074528, 1.0]], [1, [0.034128787742749966, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.41864498]
bas 1, expnt(s) = [4.66992643]
bas 2, expnt(s) = [0.58333155]
bas 3, expnt(s) = [8.18605622]
bas 4, expnt(s) = [0.03412879]
CPU time:       199.33
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.54186450e+01 7.71329529e+01 4.66992643e+00 8.02597039e+00
 5.83331547e-01 1.68636516e+00 8.18605622e+00 4.03950171e+01
 3.41287877e-02 4.27942550e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.87276947639472
cond(S) = 3.5013308369657863
E1 = -565.9916578093504  E_coul = 129.01105924594063
init E= -436.98059856341
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.99970781  -15.51751679  -11.67127109  -11.67127109  -11.67127109
   -4.58015047   -1.15404097   -1.15404097   -1.15404097]
E1 = -611.1408750026284  E_coul = 157.8733006685962
cycle= 1 E= -453.267574334032  delta_E= -16.3  |g|=    0  |ddm|= 3.21
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.46871e-14
diis-c [-6.09454623e-28  1.00000000e+00]
  mo_energy =
[-102.12573355  -13.25549784   -9.44061299   -9.44061299   -9.44061299
   -2.95087466   -0.34773061   -0.34773061   -0.34773061]
E1 = -611.1408750026284  E_coul = 157.8733006685962
cycle= 2 E= -453.267574334032  delta_E=    0  |g|=    0  |ddm|= 3.07e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.02 sec
E1 = -611.1408750026284  E_coul = 157.8733006685962
  mo_energy =
[-102.12573355  -13.25549784   -9.44061299   -9.44061299   -9.44061299
   -2.95087466   -0.34773061   -0.34773061   -0.34773061]
E1 = -611.1408750026284  E_coul = 157.87330066859613
Extra cycle  E= -453.267574334032  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.79e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [9.54186450e+01 4.66992643e+00 5.83331547e-01 8.18605622e+00
 3.41287877e-02]
E = -453.26757433403225
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:38 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.4186449817        1
[INPUT] 0    0    [1    /1   ]  4.66992642691        1
[INPUT] 0    0    [1    /1   ]  0.583331547268       1
[INPUT] 1    0    [1    /1   ]  8.18605622075        1
[INPUT] 1    0    [1    /1   ]  0.0341287877427      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.41864498174918, 1.0]], [0, [4.669926426912684, 1.0]], [0, [0.5833315472678869, 1.0]], [1, [8.18605622074528, 1.0]], [1, [0.034128787742749966, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.41864498]
bas 1, expnt(s) = [4.66992643]
bas 2, expnt(s) = [0.58333155]
bas 3, expnt(s) = [8.18605622]
bas 4, expnt(s) = [0.03412879]
CPU time:       200.04
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.54186450e+01 7.71329529e+01 4.66992643e+00 8.02597039e+00
 5.83331547e-01 1.68636516e+00 8.18605622e+00 4.03950171e+01
 3.41287877e-02 4.27942550e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 11.87276947639472
cond(S) = 3.5013308369657863
E1 = -565.9916578093504  E_coul = 129.01105924594063
init E= -436.98059856341
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.99970781  -15.51751679  -11.67127109  -11.67127109  -11.67127109
   -4.58015047   -1.15404097   -1.15404097   -1.15404097]
E1 = -611.1408750026284  E_coul = 157.8733006685962
cycle= 1 E= -453.267574334032  delta_E= -16.3  |g|=    0  |ddm|= 3.21
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.46871e-14
diis-c [-6.09454623e-28  1.00000000e+00]
  mo_energy =
[-102.12573355  -13.25549784   -9.44061299   -9.44061299   -9.44061299
   -2.95087466   -0.34773061   -0.34773061   -0.34773061]
E1 = -611.1408750026284  E_coul = 157.8733006685962
cycle= 2 E= -453.267574334032  delta_E=    0  |g|=    0  |ddm|= 3.07e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -611.1408750026284  E_coul = 157.8733006685962
  mo_energy =
[-102.12573355  -13.25549784   -9.44061299   -9.44061299   -9.44061299
   -2.95087466   -0.34773061   -0.34773061   -0.34773061]
E1 = -611.1408750026284  E_coul = 157.87330066859613
Extra cycle  E= -453.267574334032  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.79e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 3.5013308369657863
E1 = -611.1408750026284  E_coul = 157.87330066859613
init E= -453.267574334032
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-102.12573355  -13.25549784   -9.44061299   -9.44061299   -9.44061299
   -2.95087466   -0.34773061   -0.34773061   -0.34773061]
E1 = -611.1408750026283  E_coul = 157.8733006685962
cycle= 1 E= -453.267574334032  delta_E= 1.71e-13  |g|=    0  |ddm|= 3.3e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -611.1408750026283  E_coul = 157.8733006685962
  mo_energy =
[-102.12573355  -13.25549784   -9.44061299   -9.44061299   -9.44061299
   -2.95087466   -0.34773061   -0.34773061   -0.34773061]
E1 = -611.1408750026285  E_coul = 157.87330066859616
Extra cycle  E= -453.267574334032  delta_E= -2.84e-13  |g|=    0  |ddm|= 2.86e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [9.54186450e+01 4.66992643e+00 5.83331547e-01 8.18605622e+00
 3.41287877e-02]
grad_E = [-2.62129378e-03  1.32591426e-01  1.01867544e-01  2.08112117e-02
 -5.62715367e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:41 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.2630432557        1
[INPUT] 0    0    [1    /1   ]  4.7404402899         1
[INPUT] 0    0    [1    /1   ]  0.480257724112       1
[INPUT] 1    0    [1    /1   ]  8.20826485299        1
[INPUT] 1    0    [1    /1   ]  0.0433316874227      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.26304325571758, 1.0]], [0, [4.740440289897532, 1.0]], [0, [0.48025772411175316, 1.0]], [1, [8.208264852991926, 1.0]], [1, [0.04333168742265103, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.26304326]
bas 1, expnt(s) = [4.74044029]
bas 2, expnt(s) = [0.48025772]
bas 3, expnt(s) = [8.20826485]
bas 4, expnt(s) = [0.04333169]
CPU time:       203.43
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.52630433e+01 7.70385966e+01 4.74044029e+00 8.11669141e+00
 4.80257724e-01 1.45754104e+00 8.20826485e+00 4.05320523e+01
 4.33316874e-02 5.76755035e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 12.197588612992364
cond(S) = 3.0684791833558154
E1 = -567.152845979805  E_coul = 129.61725154419497
init E= -437.53559443561
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.94066793  -15.39572426  -11.62909349  -11.62909349  -11.62909349
   -4.52436497   -1.23806835   -1.23806835   -1.23806835]
E1 = -612.5579171335077  E_coul = 158.87861740713285
cycle= 1 E= -453.679299726375  delta_E= -16.1  |g|=    0  |ddm|= 3.06
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.22726e-14
diis-c [-1.78697688e-27  1.00000000e+00]
  mo_energy =
[-102.07241164  -13.11984217   -9.39343036   -9.39343036   -9.39343036
   -2.88410498   -0.38123043   -0.38123043   -0.38123043]
E1 = -612.5579171335077  E_coul = 158.87861740713288
cycle= 2 E= -453.679299726375  delta_E=    0  |g|=    0  |ddm|= 5.11e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.5579171335077  E_coul = 158.87861740713288
  mo_energy =
[-102.07241164  -13.11984217   -9.39343036   -9.39343036   -9.39343036
   -2.88410498   -0.38123043   -0.38123043   -0.38123043]
E1 = -612.5579171335077  E_coul = 158.8786174071329
Extra cycle  E= -453.679299726375  delta_E=    0  |g|=    0  |ddm|= 4.44e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [9.52630433e+01 4.74044029e+00 4.80257724e-01 8.20826485e+00
 4.33316874e-02]
E = -453.6792997263748
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:42 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.2630432557        1
[INPUT] 0    0    [1    /1   ]  4.7404402899         1
[INPUT] 0    0    [1    /1   ]  0.480257724112       1
[INPUT] 1    0    [1    /1   ]  8.20826485299        1
[INPUT] 1    0    [1    /1   ]  0.0433316874227      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.26304325571758, 1.0]], [0, [4.740440289897532, 1.0]], [0, [0.48025772411175316, 1.0]], [1, [8.208264852991926, 1.0]], [1, [0.04333168742265103, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.26304326]
bas 1, expnt(s) = [4.74044029]
bas 2, expnt(s) = [0.48025772]
bas 3, expnt(s) = [8.20826485]
bas 4, expnt(s) = [0.04333169]
CPU time:       204.16
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.52630433e+01 7.70385966e+01 4.74044029e+00 8.11669141e+00
 4.80257724e-01 1.45754104e+00 8.20826485e+00 4.05320523e+01
 4.33316874e-02 5.76755035e-02]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 12.197588612992364
cond(S) = 3.0684791833558154
E1 = -567.152845979805  E_coul = 129.61725154419497
init E= -437.53559443561
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.94066793  -15.39572426  -11.62909349  -11.62909349  -11.62909349
   -4.52436497   -1.23806835   -1.23806835   -1.23806835]
E1 = -612.5579171335077  E_coul = 158.87861740713285
cycle= 1 E= -453.679299726375  delta_E= -16.1  |g|=    0  |ddm|= 3.06
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.22726e-14
diis-c [-1.78697688e-27  1.00000000e+00]
  mo_energy =
[-102.07241164  -13.11984217   -9.39343036   -9.39343036   -9.39343036
   -2.88410498   -0.38123043   -0.38123043   -0.38123043]
E1 = -612.5579171335077  E_coul = 158.87861740713288
cycle= 2 E= -453.679299726375  delta_E=    0  |g|=    0  |ddm|= 5.11e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -612.5579171335077  E_coul = 158.87861740713288
  mo_energy =
[-102.07241164  -13.11984217   -9.39343036   -9.39343036   -9.39343036
   -2.88410498   -0.38123043   -0.38123043   -0.38123043]
E1 = -612.5579171335077  E_coul = 158.8786174071329
Extra cycle  E= -453.679299726375  delta_E=    0  |g|=    0  |ddm|= 4.44e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 3.0684791833558154
E1 = -612.5579171335077  E_coul = 158.8786174071329
init E= -453.679299726375
    CPU time for initialize scf      0.06 sec, wall time      0.06 sec
  mo_energy =
[-102.07241164  -13.11984217   -9.39343036   -9.39343036   -9.39343036
   -2.88410498   -0.38123043   -0.38123043   -0.38123043]
E1 = -612.5579171335074  E_coul = 158.87861740713282
cycle= 1 E= -453.679299726375  delta_E= 1.71e-13  |g|=    0  |ddm|= 4.27e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -612.5579171335074  E_coul = 158.87861740713282
  mo_energy =
[-102.07241164  -13.11984217   -9.39343036   -9.39343036   -9.39343036
   -2.88410498   -0.38123043   -0.38123043   -0.38123043]
E1 = -612.5579171335074  E_coul = 158.87861740713285
Extra cycle  E= -453.679299726375  delta_E= 5.68e-14  |g|=    0  |ddm|= 3.25e-15
    CPU time for scf_cycle      0.12 sec, wall time      0.12 sec
exp = [9.52630433e+01 4.74044029e+00 4.80257724e-01 8.20826485e+00
 4.33316874e-02]
grad_E = [-4.28416678e-03  1.96886927e-01 -1.29092250e+00  3.40663762e-02
 -4.87807953e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:45 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0913344925        1
[INPUT] 0    0    [1    /1   ]  4.75587546487        1
[INPUT] 0    0    [1    /1   ]  0.421165813741       1
[INPUT] 1    0    [1    /1   ]  8.23602832544        1
[INPUT] 1    0    [1    /1   ]  0.0722486415446      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.09133449245506, 1.0]], [0, [4.755875464873141, 1.0]], [0, [0.4211658137414916, 1.0]], [1, [8.23602832543693, 1.0]], [1, [0.07224864154456243, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.09133449]
bas 1, expnt(s) = [4.75587546]
bas 2, expnt(s) = [0.42116581]
bas 3, expnt(s) = [8.23602833]
bas 4, expnt(s) = [0.07224864]
CPU time:       207.48
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.50913345e+01 7.69344283e+01 4.75587546e+00 8.13650470e+00
 4.21165814e-01 1.32085413e+00 8.23602833e+00 4.07034932e+01
 7.22486415e-02 1.09275172e-01]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 13.097551319080084
cond(S) = 2.851055375875926
E1 = -571.8012384316482  E_coul = 132.8222895059324
init E= -438.978948925716
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.65819128  -15.10346928  -11.3755403   -11.3755403   -11.3755403
   -4.21826567   -1.3985236    -1.3985236    -1.3985236 ]
E1 = -618.2198036530502  E_coul = 163.45551207880092
cycle= 1 E= -454.764291574249  delta_E= -15.8  |g|=    0  |ddm|= 2.56
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.81154e-14
diis-c [-3.28166137e-28  1.00000000e+00]
  mo_energy =
[-101.73579048  -12.76247963   -9.07872059   -9.07872059   -9.07872059
   -2.54619638   -0.4579205    -0.4579205    -0.4579205 ]
E1 = -618.21980365305  E_coul = 163.4555120788009
cycle= 2 E= -454.764291574249  delta_E= 2.27e-13  |g|=    0  |ddm|= 2.3e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -618.21980365305  E_coul = 163.4555120788009
  mo_energy =
[-101.73579048  -12.76247963   -9.07872059   -9.07872059   -9.07872059
   -2.54619638   -0.4579205    -0.4579205    -0.4579205 ]
E1 = -618.2198036530501  E_coul = 163.45551207880098
Extra cycle  E= -454.764291574249  delta_E=    0  |g|=    0  |ddm|= 2.69e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.06 sec
exp = [9.50913345e+01 4.75587546e+00 4.21165814e-01 8.23602833e+00
 7.22486415e-02]
E = -454.7642915742491
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:46 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0913344925        1
[INPUT] 0    0    [1    /1   ]  4.75587546487        1
[INPUT] 0    0    [1    /1   ]  0.421165813741       1
[INPUT] 1    0    [1    /1   ]  8.23602832544        1
[INPUT] 1    0    [1    /1   ]  0.0722486415446      1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.09133449245506, 1.0]], [0, [4.755875464873141, 1.0]], [0, [0.4211658137414916, 1.0]], [1, [8.23602832543693, 1.0]], [1, [0.07224864154456243, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.09133449]
bas 1, expnt(s) = [4.75587546]
bas 2, expnt(s) = [0.42116581]
bas 3, expnt(s) = [8.23602833]
bas 4, expnt(s) = [0.07224864]
CPU time:       208.26
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00
 9.50913345e+01 7.69344283e+01 4.75587546e+00 8.13650470e+00
 4.21165814e-01 1.32085413e+00 8.23602833e+00 4.07034932e+01
 7.22486415e-02 1.09275172e-01]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 13.097551319080084
cond(S) = 2.851055375875926
E1 = -571.8012384316482  E_coul = 132.8222895059324
init E= -438.978948925716
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-104.65819128  -15.10346928  -11.3755403   -11.3755403   -11.3755403
   -4.21826567   -1.3985236    -1.3985236    -1.3985236 ]
E1 = -618.2198036530502  E_coul = 163.45551207880092
cycle= 1 E= -454.764291574249  delta_E= -15.8  |g|=    0  |ddm|= 2.56
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.81154e-14
diis-c [-3.28166137e-28  1.00000000e+00]
  mo_energy =
[-101.73579048  -12.76247963   -9.07872059   -9.07872059   -9.07872059
   -2.54619638   -0.4579205    -0.4579205    -0.4579205 ]
E1 = -618.21980365305  E_coul = 163.4555120788009
cycle= 2 E= -454.764291574249  delta_E= 2.27e-13  |g|=    0  |ddm|= 2.3e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -618.21980365305  E_coul = 163.4555120788009
  mo_energy =
[-101.73579048  -12.76247963   -9.07872059   -9.07872059   -9.07872059
   -2.54619638   -0.4579205    -0.4579205    -0.4579205 ]
E1 = -618.2198036530501  E_coul = 163.45551207880098
Extra cycle  E= -454.764291574249  delta_E=    0  |g|=    0  |ddm|= 2.69e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.851055375875926
E1 = -618.2198036530501  E_coul = 163.45551207880098
init E= -454.764291574249
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-101.73579048  -12.76247963   -9.07872059   -9.07872059   -9.07872059
   -2.54619638   -0.4579205    -0.4579205    -0.4579205 ]
E1 = -618.2198036530506  E_coul = 163.45551207880112
cycle= 1 E= -454.764291574249  delta_E= -3.41e-13  |g|=    0  |ddm|= 4.65e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -618.2198036530506  E_coul = 163.45551207880112
  mo_energy =
[-101.73579048  -12.76247963   -9.07872059   -9.07872059   -9.07872059
   -2.54619638   -0.4579205    -0.4579205    -0.4579205 ]
E1 = -618.2198036530505  E_coul = 163.45551207880104
Extra cycle  E= -454.764291574249  delta_E=    0  |g|=    0  |ddm|= 3.76e-15
    CPU time for scf_cycle      0.10 sec, wall time      0.11 sec
exp = [9.50913345e+01 4.75587546e+00 4.21165814e-01 8.23602833e+00
 7.22486415e-02]
grad_E = [-6.07881599e-03  2.19744710e-01 -2.20029707e+00  4.88877275e-02
 -3.55457888e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:49 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.1506111337        1
[INPUT] 0    0    [1    /1   ]  4.64173083824        1
[INPUT] 0    0    [1    /1   ]  0.47802690907        1
[INPUT] 1    0    [1    /1   ]  8.23967183333        1
[INPUT] 1    0    [1    /1   ]  0.143758452828       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.15061113370784, 1.0]], [0, [4.641730838239317, 1.0]], [0, [0.47802690906999534, 1.0]], [1, [8.239671833331133, 1.0]], [1, [0.14375845282766725, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.15061113]
bas 1, expnt(s) = [4.64173084]
bas 2, expnt(s) = [0.47802691]
bas 3, expnt(s) = [8.23967183]
bas 4, expnt(s) = [0.14375845]
CPU time:       211.47
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.15061113 76.97039419  4.64173084  7.98959912  0.47802691  1.45246034
  8.23967183 40.72600277  0.14375845  0.25824156]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 14.988259100838325
cond(S) = 3.0844837733098185
E1 = -588.2741950476135  E_coul = 145.31795706193313
init E= -442.95623798568
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-103.62554819  -14.19925792  -10.39027642  -10.39027642  -10.39027642
   -3.3703658    -1.39324545   -1.39324545   -1.39324545]
E1 = -630.3057420891965  E_coul = 173.492549631328
cycle= 1 E= -456.813192457869  delta_E= -13.9  |g|=    0  |ddm|= 1.47
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.77311e-15
diis-c [-4.5875082e-29  1.0000000e+00]
  mo_energy =
[-100.9478892   -12.10725442   -8.33679425   -8.33679425   -8.33679425
   -1.95815689   -0.54554605   -0.54554605   -0.54554605]
E1 = -630.3057420891962  E_coul = 173.49254963132776
cycle= 2 E= -456.813192457868  delta_E= 1.14e-13  |g|=    0  |ddm|= 4.51e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -630.3057420891962  E_coul = 173.49254963132776
  mo_energy =
[-100.9478892   -12.10725442   -8.33679425   -8.33679425   -8.33679425
   -1.95815689   -0.54554605   -0.54554605   -0.54554605]
E1 = -630.3057420891962  E_coul = 173.49254963132785
Extra cycle  E= -456.813192457868  delta_E= 1.14e-13  |g|=    0  |ddm|= 4.6e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [95.15061113  4.64173084  0.47802691  8.23967183  0.14375845]
E = -456.81319245786835
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:51 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.1506111337        1
[INPUT] 0    0    [1    /1   ]  4.64173083824        1
[INPUT] 0    0    [1    /1   ]  0.47802690907        1
[INPUT] 1    0    [1    /1   ]  8.23967183333        1
[INPUT] 1    0    [1    /1   ]  0.143758452828       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.15061113370784, 1.0]], [0, [4.641730838239317, 1.0]], [0, [0.47802690906999534, 1.0]], [1, [8.239671833331133, 1.0]], [1, [0.14375845282766725, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.15061113]
bas 1, expnt(s) = [4.64173084]
bas 2, expnt(s) = [0.47802691]
bas 3, expnt(s) = [8.23967183]
bas 4, expnt(s) = [0.14375845]
CPU time:       212.44
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.15061113 76.97039419  4.64173084  7.98959912  0.47802691  1.45246034
  8.23967183 40.72600277  0.14375845  0.25824156]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 14.988259100838325
cond(S) = 3.0844837733098185
E1 = -588.2741950476135  E_coul = 145.31795706193313
init E= -442.95623798568
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-103.62554819  -14.19925792  -10.39027642  -10.39027642  -10.39027642
   -3.3703658    -1.39324545   -1.39324545   -1.39324545]
E1 = -630.3057420891965  E_coul = 173.492549631328
cycle= 1 E= -456.813192457869  delta_E= -13.9  |g|=    0  |ddm|= 1.47
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.77311e-15
diis-c [-4.5875082e-29  1.0000000e+00]
  mo_energy =
[-100.9478892   -12.10725442   -8.33679425   -8.33679425   -8.33679425
   -1.95815689   -0.54554605   -0.54554605   -0.54554605]
E1 = -630.3057420891962  E_coul = 173.49254963132776
cycle= 2 E= -456.813192457868  delta_E= 1.14e-13  |g|=    0  |ddm|= 4.51e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -630.3057420891962  E_coul = 173.49254963132776
  mo_energy =
[-100.9478892   -12.10725442   -8.33679425   -8.33679425   -8.33679425
   -1.95815689   -0.54554605   -0.54554605   -0.54554605]
E1 = -630.3057420891962  E_coul = 173.49254963132785
Extra cycle  E= -456.813192457868  delta_E= 1.14e-13  |g|=    0  |ddm|= 4.6e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 3.0844837733098185
E1 = -630.3057420891962  E_coul = 173.49254963132785
init E= -456.813192457868
    CPU time for initialize scf      0.07 sec, wall time      0.13 sec
  mo_energy =
[-100.9478892   -12.10725442   -8.33679425   -8.33679425   -8.33679425
   -1.95815689   -0.54554605   -0.54554605   -0.54554605]
E1 = -630.3057420891963  E_coul = 173.49254963132773
cycle= 1 E= -456.813192457869  delta_E= -2.27e-13  |g|=    0  |ddm|= 4.39e-15
    CPU time for cycle= 1      0.02 sec, wall time      0.04 sec
E1 = -630.3057420891963  E_coul = 173.49254963132773
  mo_energy =
[-100.9478892   -12.10725442   -8.33679425   -8.33679425   -8.33679425
   -1.95815689   -0.54554605   -0.54554605   -0.54554605]
E1 = -630.3057420891961  E_coul = 173.49254963132776
Extra cycle  E= -456.813192457868  delta_E= 2.27e-13  |g|=    0  |ddm|= 1.78e-15
    CPU time for scf_cycle      0.19 sec, wall time      0.35 sec
exp = [95.15061113  4.64173084  0.47802691  8.23967183  0.14375845]
grad_E = [-3.99372694e-03  1.00208190e-01 -6.38456446e-01  2.72079806e-02
 -2.12064828e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:56 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.3475691972        1
[INPUT] 0    0    [1    /1   ]  4.51940736124        1
[INPUT] 0    0    [1    /1   ]  0.486776211549       1
[INPUT] 1    0    [1    /1   ]  8.24112256277        1
[INPUT] 1    0    [1    /1   ]  0.25085459713        1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.34756919719139, 1.0]], [0, [4.519407361239519, 1.0]], [0, [0.4867762115488576, 1.0]], [1, [8.241122562772244, 1.0]], [1, [0.2508545971303867, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.3475692]
bas 1, expnt(s) = [4.51940736]
bas 2, expnt(s) = [0.48677621]
bas 3, expnt(s) = [8.24112256]
bas 4, expnt(s) = [0.2508546]
CPU time:       216.51
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.3475692  77.08985759  4.51940736  7.83116078  0.48677621  1.4723533
  8.24112256 40.73496607  0.2508546   0.51791915]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 16.583928533042034
cond(S) = 3.1504654750434384
E1 = -608.9464775632589  E_coul = 162.25446219321816
init E= -446.692015370041
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-102.2927219   -12.99378231   -9.14624723   -9.14624723   -9.14624723
   -2.33834839   -1.13264403   -1.13264403   -1.13264403]
E1 = -641.8508405913824  E_coul = 183.33482090321203
cycle= 1 E= -458.51601968817  delta_E= -11.8  |g|=    0  |ddm|= 0.585
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.46139e-14
diis-c [-6.05845175e-28  1.00000000e+00]
  mo_energy =
[-100.15604213  -11.43899753   -7.63311103   -7.63311103   -7.63311103
   -1.44937005   -0.5489522    -0.5489522    -0.5489522 ]
E1 = -641.8508405913823  E_coul = 183.33482090321198
cycle= 2 E= -458.51601968817  delta_E=    0  |g|=    0  |ddm|= 3.91e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -641.8508405913823  E_coul = 183.33482090321198
  mo_energy =
[-100.15604213  -11.43899753   -7.63311103   -7.63311103   -7.63311103
   -1.44937005   -0.5489522    -0.5489522    -0.5489522 ]
E1 = -641.850840591382  E_coul = 183.33482090321186
Extra cycle  E= -458.51601968817  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.96e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.06 sec
exp = [95.3475692   4.51940736  0.48677621  8.24112256  0.2508546 ]
E = -458.5160196881702
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:13:57 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.3475691972        1
[INPUT] 0    0    [1    /1   ]  4.51940736124        1
[INPUT] 0    0    [1    /1   ]  0.486776211549       1
[INPUT] 1    0    [1    /1   ]  8.24112256277        1
[INPUT] 1    0    [1    /1   ]  0.25085459713        1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.34756919719139, 1.0]], [0, [4.519407361239519, 1.0]], [0, [0.4867762115488576, 1.0]], [1, [8.241122562772244, 1.0]], [1, [0.2508545971303867, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.3475692]
bas 1, expnt(s) = [4.51940736]
bas 2, expnt(s) = [0.48677621]
bas 3, expnt(s) = [8.24112256]
bas 4, expnt(s) = [0.2508546]
CPU time:       217.40
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.3475692  77.08985759  4.51940736  7.83116078  0.48677621  1.4723533
  8.24112256 40.73496607  0.2508546   0.51791915]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 16.583928533042034
cond(S) = 3.1504654750434384
E1 = -608.9464775632589  E_coul = 162.25446219321816
init E= -446.692015370041
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-102.2927219   -12.99378231   -9.14624723   -9.14624723   -9.14624723
   -2.33834839   -1.13264403   -1.13264403   -1.13264403]
E1 = -641.8508405913824  E_coul = 183.33482090321203
cycle= 1 E= -458.51601968817  delta_E= -11.8  |g|=    0  |ddm|= 0.585
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=2.46139e-14
diis-c [-6.05845175e-28  1.00000000e+00]
  mo_energy =
[-100.15604213  -11.43899753   -7.63311103   -7.63311103   -7.63311103
   -1.44937005   -0.5489522    -0.5489522    -0.5489522 ]
E1 = -641.8508405913823  E_coul = 183.33482090321198
cycle= 2 E= -458.51601968817  delta_E=    0  |g|=    0  |ddm|= 3.91e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -641.8508405913823  E_coul = 183.33482090321198
  mo_energy =
[-100.15604213  -11.43899753   -7.63311103   -7.63311103   -7.63311103
   -1.44937005   -0.5489522    -0.5489522    -0.5489522 ]
E1 = -641.850840591382  E_coul = 183.33482090321186
Extra cycle  E= -458.51601968817  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.96e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 3.1504654750434384
E1 = -641.850840591382  E_coul = 183.33482090321186
init E= -458.51601968817
    CPU time for initialize scf      0.08 sec, wall time      0.09 sec
  mo_energy =
[-100.15604213  -11.43899753   -7.63311103   -7.63311103   -7.63311103
   -1.44937005   -0.5489522    -0.5489522    -0.5489522 ]
E1 = -641.8508405913823  E_coul = 183.33482090321186
cycle= 1 E= -458.51601968817  delta_E= -2.27e-13  |g|=    0  |ddm|= 1.36e-15
    CPU time for cycle= 1      0.02 sec, wall time      0.02 sec
E1 = -641.8508405913823  E_coul = 183.33482090321186
  mo_energy =
[-100.15604213  -11.43899753   -7.63311103   -7.63311103   -7.63311103
   -1.44937005   -0.5489522    -0.5489522    -0.5489522 ]
E1 = -641.8508405913823  E_coul = 183.33482090321198
Extra cycle  E= -458.51601968817  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.08e-15
    CPU time for scf_cycle      0.18 sec, wall time      0.28 sec
exp = [95.3475692   4.51940736  0.48677621  8.24112256  0.2508546 ]
grad_E = [ 1.58574796e-03 -2.56622129e-02  1.94758117e-01 -4.09803529e-02
 -1.14215698e+01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:02 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.2050037189        1
[INPUT] 0    0    [1    /1   ]  4.47553215055        1
[INPUT] 0    0    [1    /1   ]  0.446179078412       1
[INPUT] 1    0    [1    /1   ]  8.35740156378        1
[INPUT] 1    0    [1    /1   ]  0.379127373319       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.20500371885346, 1.0]], [0, [4.475532150550016, 1.0]], [0, [0.4461790784122043, 1.0]], [1, [8.357401563777179, 1.0]], [1, [0.3791273733185133, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.20500372]
bas 1, expnt(s) = [4.47553215]
bas 2, expnt(s) = [0.44617908]
bas 3, expnt(s) = [8.35740156]
bas 4, expnt(s) = [0.37912737]
CPU time:       221.64
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.20500372 77.00339177  4.47553215  7.77407158  0.44617908  1.37926249
  8.35740156 41.4546717   0.37912737  0.86789227]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.22877917448402
cond(S) = 3.000916854961283
E1 = -624.1158804854647  E_coul = 175.36318217721242
init E= -448.752698308252
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-101.20166662  -12.02402615   -8.23122179   -8.23122179   -8.23122179
   -1.71301022   -0.87745899   -0.87745899   -0.87745899]
E1 = -651.6707332257928  E_coul = 192.15647102555636
cycle= 1 E= -459.514262200236  delta_E= -10.8  |g|=    0  |ddm|= 0.291
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.49716e-14
diis-c [-2.02244052e-27  1.00000000e+00]
  mo_energy =
[-99.37778428 -10.78233631  -7.039554    -7.039554    -7.039554
  -1.12028269  -0.4266101   -0.4266101   -0.4266101 ]
E1 = -651.6707332257931  E_coul = 192.15647102555639
cycle= 2 E= -459.514262200237  delta_E= -3.41e-13  |g|=    0  |ddm|= 4.66e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -651.6707332257931  E_coul = 192.15647102555639
  mo_energy =
[-99.37778428 -10.78233631  -7.039554    -7.039554    -7.039554
  -1.12028269  -0.4266101   -0.4266101   -0.4266101 ]
E1 = -651.6707332257931  E_coul = 192.15647102555636
Extra cycle  E= -459.514262200237  delta_E=    0  |g|=    0  |ddm|= 3.86e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [95.20500372  4.47553215  0.44617908  8.35740156  0.37912737]
E = -459.5142622002368
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:03 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.2050037189        1
[INPUT] 0    0    [1    /1   ]  4.47553215055        1
[INPUT] 0    0    [1    /1   ]  0.446179078412       1
[INPUT] 1    0    [1    /1   ]  8.35740156378        1
[INPUT] 1    0    [1    /1   ]  0.379127373319       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.20500371885346, 1.0]], [0, [4.475532150550016, 1.0]], [0, [0.4461790784122043, 1.0]], [1, [8.357401563777179, 1.0]], [1, [0.3791273733185133, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.20500372]
bas 1, expnt(s) = [4.47553215]
bas 2, expnt(s) = [0.44617908]
bas 3, expnt(s) = [8.35740156]
bas 4, expnt(s) = [0.37912737]
CPU time:       222.49
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.20500372 77.00339177  4.47553215  7.77407158  0.44617908  1.37926249
  8.35740156 41.4546717   0.37912737  0.86789227]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.22877917448402
cond(S) = 3.000916854961283
E1 = -624.1158804854647  E_coul = 175.36318217721242
init E= -448.752698308252
    CPU time for initialize scf      0.02 sec, wall time      0.03 sec
  mo_energy =
[-101.20166662  -12.02402615   -8.23122179   -8.23122179   -8.23122179
   -1.71301022   -0.87745899   -0.87745899   -0.87745899]
E1 = -651.6707332257928  E_coul = 192.15647102555636
cycle= 1 E= -459.514262200236  delta_E= -10.8  |g|=    0  |ddm|= 0.291
    CPU time for cycle= 1      0.01 sec, wall time      0.02 sec
diis-norm(errvec)=4.49716e-14
diis-c [-2.02244052e-27  1.00000000e+00]
  mo_energy =
[-99.37778428 -10.78233631  -7.039554    -7.039554    -7.039554
  -1.12028269  -0.4266101   -0.4266101   -0.4266101 ]
E1 = -651.6707332257931  E_coul = 192.15647102555639
cycle= 2 E= -459.514262200237  delta_E= -3.41e-13  |g|=    0  |ddm|= 4.66e-15
    CPU time for cycle= 2      0.02 sec, wall time      0.04 sec
E1 = -651.6707332257931  E_coul = 192.15647102555639
  mo_energy =
[-99.37778428 -10.78233631  -7.039554    -7.039554    -7.039554
  -1.12028269  -0.4266101   -0.4266101   -0.4266101 ]
E1 = -651.6707332257931  E_coul = 192.15647102555636
Extra cycle  E= -459.514262200237  delta_E=    0  |g|=    0  |ddm|= 3.86e-15
    CPU time for scf_cycle      0.07 sec, wall time      0.11 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 3.000916854961283
E1 = -651.6707332257931  E_coul = 192.15647102555636
init E= -459.514262200237
    CPU time for initialize scf      0.10 sec, wall time      0.18 sec
  mo_energy =
[-99.37778428 -10.78233631  -7.039554    -7.039554    -7.039554
  -1.12028269  -0.4266101   -0.4266101   -0.4266101 ]
E1 = -651.6707332257929  E_coul = 192.15647102555627
cycle= 1 E= -459.514262200237  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.98e-15
    CPU time for cycle= 1      0.02 sec, wall time      0.05 sec
E1 = -651.6707332257929  E_coul = 192.15647102555627
  mo_energy =
[-99.37778428 -10.78233631  -7.039554    -7.039554    -7.039554
  -1.12028269  -0.4266101   -0.4266101   -0.4266101 ]
E1 = -651.670733225793  E_coul = 192.15647102555636
Extra cycle  E= -459.514262200237  delta_E=    0  |g|=    0  |ddm|= 3.82e-15
    CPU time for scf_cycle      0.20 sec, wall time      0.37 sec
exp = [95.20500372  4.47553215  0.44617908  8.35740156  0.37912737]
grad_E = [ 1.36806911e-03 -4.73286651e-02  3.09554631e-01 -5.40998767e-02
 -4.34456032e+00]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:08 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.081948586         1
[INPUT] 0    0    [1    /1   ]  4.48384946886        1
[INPUT] 0    0    [1    /1   ]  0.403931869395       1
[INPUT] 1    0    [1    /1   ]  8.49241232905        1
[INPUT] 1    0    [1    /1   ]  0.46122978422        1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.08194858596822, 1.0]], [0, [4.483849468855069, 1.0]], [0, [0.4039318693948714, 1.0]], [1, [8.492412329048497, 1.0]], [1, [0.4612297842198634, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.08194859]
bas 1, expnt(s) = [4.48384947]
bas 2, expnt(s) = [0.40393187]
bas 3, expnt(s) = [8.49241233]
bas 4, expnt(s) = [0.46122978]
CPU time:       226.91
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.08194859 76.92873293  4.48384947  7.78490455  0.40393187  1.28010653
  8.49241233 42.29346163  0.46122978  1.10887112]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.2693324433034
cond(S) = 2.837258750933358
E1 = -629.349733990033  E_coul = 180.02583918632595
init E= -449.323894803707
    CPU time for initialize scf      0.03 sec, wall time      0.04 sec
  mo_energy =
[-100.74361422  -11.6429539    -7.92611049   -7.92611049   -7.92611049
   -1.55455772   -0.77510391   -0.77510391   -0.77510391]
E1 = -656.6332656958006  E_coul = 196.89106602230393
cycle= 1 E= -459.742199673497  delta_E= -10.4  |g|=    0  |ddm|= 0.286
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.06109e-14
diis-c [-3.67367945e-27  1.00000000e+00]
  mo_energy =
[-98.91528454 -10.40420266  -6.74405648  -6.74405648  -6.74405648
  -0.99125394  -0.29421875  -0.29421875  -0.29421875]
E1 = -656.6332656958003  E_coul = 196.89106602230385
cycle= 2 E= -459.742199673496  delta_E= 1.71e-13  |g|=    0  |ddm|= 3.94e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -656.6332656958003  E_coul = 196.89106602230385
  mo_energy =
[-98.91528454 -10.40420266  -6.74405648  -6.74405648  -6.74405648
  -0.99125394  -0.29421875  -0.29421875  -0.29421875]
E1 = -656.6332656958004  E_coul = 196.89106602230385
Extra cycle  E= -459.742199673497  delta_E= -1.14e-13  |g|=    0  |ddm|= 2.74e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.07 sec
exp = [95.08194859  4.48384947  0.40393187  8.49241233  0.46122978]
E = -459.7421996734966
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:09 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.081948586         1
[INPUT] 0    0    [1    /1   ]  4.48384946886        1
[INPUT] 0    0    [1    /1   ]  0.403931869395       1
[INPUT] 1    0    [1    /1   ]  8.49241232905        1
[INPUT] 1    0    [1    /1   ]  0.46122978422        1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.08194858596822, 1.0]], [0, [4.483849468855069, 1.0]], [0, [0.4039318693948714, 1.0]], [1, [8.492412329048497, 1.0]], [1, [0.4612297842198634, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.08194859]
bas 1, expnt(s) = [4.48384947]
bas 2, expnt(s) = [0.40393187]
bas 3, expnt(s) = [8.49241233]
bas 4, expnt(s) = [0.46122978]
CPU time:       227.68
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.08194859 76.92873293  4.48384947  7.78490455  0.40393187  1.28010653
  8.49241233 42.29346163  0.46122978  1.10887112]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.2693324433034
cond(S) = 2.837258750933358
E1 = -629.349733990033  E_coul = 180.02583918632595
init E= -449.323894803707
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-100.74361422  -11.6429539    -7.92611049   -7.92611049   -7.92611049
   -1.55455772   -0.77510391   -0.77510391   -0.77510391]
E1 = -656.6332656958006  E_coul = 196.89106602230393
cycle= 1 E= -459.742199673497  delta_E= -10.4  |g|=    0  |ddm|= 0.286
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.06109e-14
diis-c [-3.67367945e-27  1.00000000e+00]
  mo_energy =
[-98.91528454 -10.40420266  -6.74405648  -6.74405648  -6.74405648
  -0.99125394  -0.29421875  -0.29421875  -0.29421875]
E1 = -656.6332656958003  E_coul = 196.89106602230385
cycle= 2 E= -459.742199673496  delta_E= 1.71e-13  |g|=    0  |ddm|= 3.94e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -656.6332656958003  E_coul = 196.89106602230385
  mo_energy =
[-98.91528454 -10.40420266  -6.74405648  -6.74405648  -6.74405648
  -0.99125394  -0.29421875  -0.29421875  -0.29421875]
E1 = -656.6332656958004  E_coul = 196.89106602230385
Extra cycle  E= -459.742199673497  delta_E= -1.14e-13  |g|=    0  |ddm|= 2.74e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.837258750933358
E1 = -656.6332656958004  E_coul = 196.89106602230385
init E= -459.742199673497
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-98.91528454 -10.40420266  -6.74405648  -6.74405648  -6.74405648
  -0.99125394  -0.29421875  -0.29421875  -0.29421875]
E1 = -656.6332656958003  E_coul = 196.89106602230385
cycle= 1 E= -459.742199673496  delta_E= 1.14e-13  |g|=    0  |ddm|= 4.06e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -656.6332656958003  E_coul = 196.89106602230385
  mo_energy =
[-98.91528454 -10.40420266  -6.74405648  -6.74405648  -6.74405648
  -0.99125394  -0.29421875  -0.29421875  -0.29421875]
E1 = -656.6332656958006  E_coul = 196.89106602230387
Extra cycle  E= -459.742199673497  delta_E= -1.71e-13  |g|=    0  |ddm|= 5.12e-15
    CPU time for scf_cycle      0.12 sec, wall time      0.13 sec
exp = [95.08194859  4.48384947  0.40393187  8.49241233  0.46122978]
grad_E = [ 4.20781163e-04 -1.44837372e-02  3.68649835e-03 -1.90341500e-02
 -1.01428099e+00]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:14 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0425657761        1
[INPUT] 0    0    [1    /1   ]  4.49005243623        1
[INPUT] 0    0    [1    /1   ]  0.395284330309       1
[INPUT] 1    0    [1    /1   ]  8.54166635672        1
[INPUT] 1    0    [1    /1   ]  0.485720084588       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04256577612908, 1.0]], [0, [4.490052436225298, 1.0]], [0, [0.3952843303089013, 1.0]], [1, [8.541666356717688, 1.0]], [1, [0.4857200845878361, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04256578]
bas 1, expnt(s) = [4.49005244]
bas 2, expnt(s) = [0.39528433]
bas 3, expnt(s) = [8.54166636]
bas 4, expnt(s) = [0.48572008]
CPU time:       231.73
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04256578 76.90483386  4.49005244  7.7929804   0.39528433  1.25949725
  8.54166636 42.60029897  0.48572008  1.18295158]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.24687706559413
cond(S) = 2.8040115225662494
E1 = -630.4760008008236  E_coul = 181.05131818795329
init E= -449.42468261287
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-100.62950061  -11.55303953   -7.8618837    -7.8618837    -7.8618837
   -1.52774847   -0.75022931   -0.75022931   -0.75022931]
E1 = -658.0701196845787  E_coul = 198.3135958402712
cycle= 1 E= -459.756523844307  delta_E= -10.3  |g|=    0  |ddm|=  0.3
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=1.15152e-14
diis-c [-1.32599247e-28  1.00000000e+00]
  mo_energy =
[-98.77213262 -10.28977151  -6.65708353  -6.65708353  -6.65708353
  -0.95352324  -0.24492868  -0.24492868  -0.24492868]
E1 = -658.0701196845788  E_coul = 198.31359584027126
cycle= 2 E= -459.756523844308  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.9e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -658.0701196845788  E_coul = 198.31359584027126
  mo_energy =
[-98.77213262 -10.28977151  -6.65708353  -6.65708353  -6.65708353
  -0.95352324  -0.24492868  -0.24492868  -0.24492868]
E1 = -658.0701196845789  E_coul = 198.31359584027126
Extra cycle  E= -459.756523844308  delta_E= -1.14e-13  |g|=    0  |ddm|= 3.66e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [95.04256578  4.49005244  0.39528433  8.54166636  0.48572008]
E = -459.75652384430765
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:15 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0425657761        1
[INPUT] 0    0    [1    /1   ]  4.49005243623        1
[INPUT] 0    0    [1    /1   ]  0.395284330309       1
[INPUT] 1    0    [1    /1   ]  8.54166635672        1
[INPUT] 1    0    [1    /1   ]  0.485720084588       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04256577612908, 1.0]], [0, [4.490052436225298, 1.0]], [0, [0.3952843303089013, 1.0]], [1, [8.541666356717688, 1.0]], [1, [0.4857200845878361, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04256578]
bas 1, expnt(s) = [4.49005244]
bas 2, expnt(s) = [0.39528433]
bas 3, expnt(s) = [8.54166636]
bas 4, expnt(s) = [0.48572008]
CPU time:       232.64
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04256578 76.90483386  4.49005244  7.7929804   0.39528433  1.25949725
  8.54166636 42.60029897  0.48572008  1.18295158]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.24687706559413
cond(S) = 2.8040115225662494
E1 = -630.4760008008236  E_coul = 181.05131818795329
init E= -449.42468261287
    CPU time for initialize scf      0.04 sec, wall time      0.05 sec
  mo_energy =
[-100.62950061  -11.55303953   -7.8618837    -7.8618837    -7.8618837
   -1.52774847   -0.75022931   -0.75022931   -0.75022931]
E1 = -658.0701196845787  E_coul = 198.3135958402712
cycle= 1 E= -459.756523844307  delta_E= -10.3  |g|=    0  |ddm|=  0.3
    CPU time for cycle= 1      0.02 sec, wall time      0.03 sec
diis-norm(errvec)=1.15152e-14
diis-c [-1.32599247e-28  1.00000000e+00]
  mo_energy =
[-98.77213262 -10.28977151  -6.65708353  -6.65708353  -6.65708353
  -0.95352324  -0.24492868  -0.24492868  -0.24492868]
E1 = -658.0701196845788  E_coul = 198.31359584027126
cycle= 2 E= -459.756523844308  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.9e-15
    CPU time for cycle= 2      0.02 sec, wall time      0.02 sec
E1 = -658.0701196845788  E_coul = 198.31359584027126
  mo_energy =
[-98.77213262 -10.28977151  -6.65708353  -6.65708353  -6.65708353
  -0.95352324  -0.24492868  -0.24492868  -0.24492868]
E1 = -658.0701196845789  E_coul = 198.31359584027126
Extra cycle  E= -459.756523844308  delta_E= -1.14e-13  |g|=    0  |ddm|= 3.66e-15
    CPU time for scf_cycle      0.09 sec, wall time      0.12 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.8040115225662494
E1 = -658.0701196845789  E_coul = 198.31359584027126
init E= -459.756523844308
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-98.77213262 -10.28977151  -6.65708353  -6.65708353  -6.65708353
  -0.95352324  -0.24492868  -0.24492868  -0.24492868]
E1 = -658.0701196845787  E_coul = 198.3135958402712
cycle= 1 E= -459.756523844307  delta_E= 1.71e-13  |g|=    0  |ddm|= 4.38e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -658.0701196845787  E_coul = 198.3135958402712
  mo_energy =
[-98.77213262 -10.28977151  -6.65708353  -6.65708353  -6.65708353
  -0.95352324  -0.24492868  -0.24492868  -0.24492868]
E1 = -658.0701196845787  E_coul = 198.31359584027118
Extra cycle  E= -459.756523844307  delta_E=    0  |g|=    0  |ddm|= 2.93e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [95.04256578  4.49005244  0.39528433  8.54166636  0.48572008]
grad_E = [-5.03234653e-05  1.17729475e-03 -5.25542210e-02 -1.14715547e-03
 -1.36393130e-01]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:19 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0425103577        1
[INPUT] 0    0    [1    /1   ]  4.48930013294        1
[INPUT] 0    0    [1    /1   ]  0.396727680994       1
[INPUT] 1    0    [1    /1   ]  8.5474747825         1
[INPUT] 1    0    [1    /1   ]  0.489048638439       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04251035768506, 1.0]], [0, [4.489300132938959, 1.0]], [0, [0.3967276809937276, 1.0]], [1, [8.547474782501917, 1.0]], [1, [0.48904863843932694, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04251036]
bas 1, expnt(s) = [4.48930013]
bas 2, expnt(s) = [0.39672768]
bas 3, expnt(s) = [8.54747478]
bas 4, expnt(s) = [0.48904864]
CPU time:       236.64
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04251036 76.90480023  4.48930013  7.7920011   0.39672768  1.2629449
  8.54747478 42.63651288  0.48904864  1.19309345]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.24261773282735
cond(S) = 2.8095236488676747
E1 = -630.6510567279922  E_coul = 181.21231595914387
init E= -449.438740768848
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-100.61246203  -11.54059047   -7.85125242   -7.85125242   -7.85125242
   -1.52337474   -0.74581796   -0.74581796   -0.74581796]
E1 = -658.3021228257107  E_coul = 198.54529582678407
cycle= 1 E= -459.756826998927  delta_E= -10.3  |g|=    0  |ddm|= 0.302
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.1782e-14
diis-c [-1.74573731e-27  1.00000000e+00]
  mo_energy =
[-98.7499756  -10.27320065  -6.64237252  -6.64237252  -6.64237252
  -0.94578539  -0.23656213  -0.23656213  -0.23656213]
E1 = -658.3021228257109  E_coul = 198.54529582678416
cycle= 2 E= -459.756826998927  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.23e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -658.3021228257109  E_coul = 198.54529582678416
  mo_energy =
[-98.7499756  -10.27320065  -6.64237252  -6.64237252  -6.64237252
  -0.94578539  -0.23656213  -0.23656213  -0.23656213]
E1 = -658.3021228257109  E_coul = 198.5452958267842
Extra cycle  E= -459.756826998927  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.9e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [95.04251036  4.48930013  0.39672768  8.54747478  0.48904864]
E = -459.7568269989266
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:20 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0425103577        1
[INPUT] 0    0    [1    /1   ]  4.48930013294        1
[INPUT] 0    0    [1    /1   ]  0.396727680994       1
[INPUT] 1    0    [1    /1   ]  8.5474747825         1
[INPUT] 1    0    [1    /1   ]  0.489048638439       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04251035768506, 1.0]], [0, [4.489300132938959, 1.0]], [0, [0.3967276809937276, 1.0]], [1, [8.547474782501917, 1.0]], [1, [0.48904863843932694, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04251036]
bas 1, expnt(s) = [4.48930013]
bas 2, expnt(s) = [0.39672768]
bas 3, expnt(s) = [8.54747478]
bas 4, expnt(s) = [0.48904864]
CPU time:       237.40
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04251036 76.90480023  4.48930013  7.7920011   0.39672768  1.2629449
  8.54747478 42.63651288  0.48904864  1.19309345]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.24261773282735
cond(S) = 2.8095236488676747
E1 = -630.6510567279922  E_coul = 181.21231595914387
init E= -449.438740768848
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-100.61246203  -11.54059047   -7.85125242   -7.85125242   -7.85125242
   -1.52337474   -0.74581796   -0.74581796   -0.74581796]
E1 = -658.3021228257107  E_coul = 198.54529582678407
cycle= 1 E= -459.756826998927  delta_E= -10.3  |g|=    0  |ddm|= 0.302
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.1782e-14
diis-c [-1.74573731e-27  1.00000000e+00]
  mo_energy =
[-98.7499756  -10.27320065  -6.64237252  -6.64237252  -6.64237252
  -0.94578539  -0.23656213  -0.23656213  -0.23656213]
E1 = -658.3021228257109  E_coul = 198.54529582678416
cycle= 2 E= -459.756826998927  delta_E= -5.68e-14  |g|=    0  |ddm|= 3.23e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -658.3021228257109  E_coul = 198.54529582678416
  mo_energy =
[-98.7499756  -10.27320065  -6.64237252  -6.64237252  -6.64237252
  -0.94578539  -0.23656213  -0.23656213  -0.23656213]
E1 = -658.3021228257109  E_coul = 198.5452958267842
Extra cycle  E= -459.756826998927  delta_E= 1.14e-13  |g|=    0  |ddm|= 1.9e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.8095236488676747
E1 = -658.3021228257109  E_coul = 198.5452958267842
init E= -459.756826998927
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-98.7499756  -10.27320065  -6.64237252  -6.64237252  -6.64237252
  -0.94578539  -0.23656213  -0.23656213  -0.23656213]
E1 = -658.3021228257109  E_coul = 198.54529582678418
cycle= 1 E= -459.756826998927  delta_E= -5.68e-14  |g|=    0  |ddm|= 2.74e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -658.3021228257109  E_coul = 198.54529582678418
  mo_energy =
[-98.7499756  -10.27320065  -6.64237252  -6.64237252  -6.64237252
  -0.94578539  -0.23656213  -0.23656213  -0.23656213]
E1 = -658.302122825711  E_coul = 198.54529582678416
Extra cycle  E= -459.756826998927  delta_E= -1.71e-13  |g|=    0  |ddm|= 2.32e-15
    CPU time for scf_cycle      0.10 sec, wall time      0.10 sec
exp = [95.04251036  4.48930013  0.39672768  8.54747478  0.48904864]
grad_E = [-5.15451650e-05  1.40907771e-03 -2.01122148e-02  6.37881879e-04
 -1.29713899e-02]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:24 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0449284057        1
[INPUT] 0    0    [1    /1   ]  4.48840380004        1
[INPUT] 0    0    [1    /1   ]  0.397711410555       1
[INPUT] 1    0    [1    /1   ]  8.54734536654        1
[INPUT] 1    0    [1    /1   ]  0.489357211443       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04492840573143, 1.0]], [0, [4.488403800037752, 1.0]], [0, [0.397711410555485, 1.0]], [1, [8.547345366536792, 1.0]], [1, [0.48935721144276, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04492841]
bas 1, expnt(s) = [4.4884038]
bas 2, expnt(s) = [0.39771141]
bas 3, expnt(s) = [8.54734537]
bas 4, expnt(s) = [0.48935721]
CPU time:       241.20
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04492841 76.90626767  4.4884038   7.79083426  0.39771141  1.26529288
  8.54734537 42.63570594  0.48935721  1.19403452]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.242106076196926
cond(S) = 2.8133416618938334
E1 = -630.6766667907366  E_coul = 181.23611178953757
init E= -449.440555001199
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-100.61035903  -11.53940673   -7.8495083    -7.8495083    -7.8495083
   -1.5225446    -0.74502347   -0.74502347   -0.74502347]
E1 = -658.334324054181  E_coul = 198.57748239596697
cycle= 1 E= -459.756841658214  delta_E= -10.3  |g|=    0  |ddm|= 0.302
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.22693e-14
diis-c [-1.7866965e-27  1.0000000e+00]
  mo_energy =
[-98.74730047 -10.27162552  -6.64017806  -6.64017806  -6.64017806
  -0.94420152  -0.23533932  -0.23533932  -0.23533932]
E1 = -658.334324054181  E_coul = 198.577482395967
cycle= 2 E= -459.756841658214  delta_E=    0  |g|=    0  |ddm|= 2.09e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -658.334324054181  E_coul = 198.577482395967
  mo_energy =
[-98.74730047 -10.27162552  -6.64017806  -6.64017806  -6.64017806
  -0.94420152  -0.23533932  -0.23533932  -0.23533932]
E1 = -658.334324054181  E_coul = 198.5774823959669
Extra cycle  E= -459.756841658214  delta_E= -5.68e-14  |g|=    0  |ddm|= 1.89e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [95.04492841  4.4884038   0.39771141  8.54734537  0.48935721]
E = -459.7568416582141
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:25 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0449284057        1
[INPUT] 0    0    [1    /1   ]  4.48840380004        1
[INPUT] 0    0    [1    /1   ]  0.397711410555       1
[INPUT] 1    0    [1    /1   ]  8.54734536654        1
[INPUT] 1    0    [1    /1   ]  0.489357211443       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04492840573143, 1.0]], [0, [4.488403800037752, 1.0]], [0, [0.397711410555485, 1.0]], [1, [8.547345366536792, 1.0]], [1, [0.48935721144276, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04492841]
bas 1, expnt(s) = [4.4884038]
bas 2, expnt(s) = [0.39771141]
bas 3, expnt(s) = [8.54734537]
bas 4, expnt(s) = [0.48935721]
CPU time:       241.97
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04492841 76.90626767  4.4884038   7.79083426  0.39771141  1.26529288
  8.54734537 42.63570594  0.48935721  1.19403452]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.242106076196926
cond(S) = 2.8133416618938334
E1 = -630.6766667907366  E_coul = 181.23611178953757
init E= -449.440555001199
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-100.61035903  -11.53940673   -7.8495083    -7.8495083    -7.8495083
   -1.5225446    -0.74502347   -0.74502347   -0.74502347]
E1 = -658.334324054181  E_coul = 198.57748239596697
cycle= 1 E= -459.756841658214  delta_E= -10.3  |g|=    0  |ddm|= 0.302
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.22693e-14
diis-c [-1.7866965e-27  1.0000000e+00]
  mo_energy =
[-98.74730047 -10.27162552  -6.64017806  -6.64017806  -6.64017806
  -0.94420152  -0.23533932  -0.23533932  -0.23533932]
E1 = -658.334324054181  E_coul = 198.577482395967
cycle= 2 E= -459.756841658214  delta_E=    0  |g|=    0  |ddm|= 2.09e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -658.334324054181  E_coul = 198.577482395967
  mo_energy =
[-98.74730047 -10.27162552  -6.64017806  -6.64017806  -6.64017806
  -0.94420152  -0.23533932  -0.23533932  -0.23533932]
E1 = -658.334324054181  E_coul = 198.5774823959669
Extra cycle  E= -459.756841658214  delta_E= -5.68e-14  |g|=    0  |ddm|= 1.89e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.8133416618938334
E1 = -658.334324054181  E_coul = 198.5774823959669
init E= -459.756841658214
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-98.74730047 -10.27162552  -6.64017806  -6.64017806  -6.64017806
  -0.94420152  -0.23533932  -0.23533932  -0.23533932]
E1 = -658.3343240541809  E_coul = 198.57748239596685
cycle= 1 E= -459.756841658214  delta_E= 5.68e-14  |g|=    0  |ddm|= 3.12e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -658.3343240541809  E_coul = 198.57748239596685
  mo_energy =
[-98.74730047 -10.27162552  -6.64017806  -6.64017806  -6.64017806
  -0.94420152  -0.23533932  -0.23533932  -0.23533932]
E1 = -658.334324054181  E_coul = 198.57748239596697
Extra cycle  E= -459.756841658214  delta_E=    0  |g|=    0  |ddm|= 3.46e-15
    CPU time for scf_cycle      0.10 sec, wall time      0.10 sec
exp = [95.04492841  4.4884038   0.39771141  8.54734537  0.48935721]
grad_E = [-1.41333601e-05  3.98518420e-04 -4.12236294e-03  2.56763899e-04
  1.31459830e-03]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:29 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0457704778        1
[INPUT] 0    0    [1    /1   ]  4.48812196956        1
[INPUT] 0    0    [1    /1   ]  0.397981838309       1
[INPUT] 1    0    [1    /1   ]  8.54701166682        1
[INPUT] 1    0    [1    /1   ]  0.489308678706       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04577047784488, 1.0]], [0, [4.488121969560887, 1.0]], [0, [0.3979818383086268, 1.0]], [1, [8.547011666815614, 1.0]], [1, [0.4893086787059405, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04577048]
bas 1, expnt(s) = [4.48812197]
bas 2, expnt(s) = [0.39798184]
bas 3, expnt(s) = [8.54701167]
bas 4, expnt(s) = [0.48930868]
CPU time:       245.31
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04577048 76.90677869  4.48812197  7.79046736  0.39798184  1.26593808
  8.54701167 42.63362526  0.48930868  1.1938865 ]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.242132569527406
cond(S) = 2.81439771101948
E1 = -630.6772894546418  E_coul = 181.23676258097407
init E= -449.440526873668
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-100.61043989  -11.53958651   -7.84940593   -7.84940593   -7.84940593
   -1.52246015   -0.7449553    -0.7449553    -0.7449553 ]
E1 = -658.334503644379  E_coul = 198.57766125026967
cycle= 1 E= -459.756842394109  delta_E= -10.3  |g|=    0  |ddm|= 0.302
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.11554e-14
diis-c [-3.7399845e-27  1.0000000e+00]
  mo_energy =
[-98.74742845 -10.27186684  -6.64011541  -6.64011541  -6.64011541
  -0.94401811  -0.23531031  -0.23531031  -0.23531031]
E1 = -658.3345036443786  E_coul = 198.5776612502696
cycle= 2 E= -459.756842394109  delta_E= 2.84e-13  |g|=    0  |ddm|= 2.28e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -658.3345036443786  E_coul = 198.5776612502696
  mo_energy =
[-98.74742845 -10.27186684  -6.64011541  -6.64011541  -6.64011541
  -0.94401811  -0.23531031  -0.23531031  -0.23531031]
E1 = -658.3345036443789  E_coul = 198.5776612502697
Extra cycle  E= -459.756842394109  delta_E= -1.71e-13  |g|=    0  |ddm|= 3e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [95.04577048  4.48812197  0.39798184  8.54701167  0.48930868]
E = -459.7568423941092
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:30 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0457704778        1
[INPUT] 0    0    [1    /1   ]  4.48812196956        1
[INPUT] 0    0    [1    /1   ]  0.397981838309       1
[INPUT] 1    0    [1    /1   ]  8.54701166682        1
[INPUT] 1    0    [1    /1   ]  0.489308678706       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04577047784488, 1.0]], [0, [4.488121969560887, 1.0]], [0, [0.3979818383086268, 1.0]], [1, [8.547011666815614, 1.0]], [1, [0.4893086787059405, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04577048]
bas 1, expnt(s) = [4.48812197]
bas 2, expnt(s) = [0.39798184]
bas 3, expnt(s) = [8.54701167]
bas 4, expnt(s) = [0.48930868]
CPU time:       246.37
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04577048 76.90677869  4.48812197  7.79046736  0.39798184  1.26593808
  8.54701167 42.63362526  0.48930868  1.1938865 ]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.242132569527406
cond(S) = 2.81439771101948
E1 = -630.6772894546418  E_coul = 181.23676258097407
init E= -449.440526873668
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-100.61043989  -11.53958651   -7.84940593   -7.84940593   -7.84940593
   -1.52246015   -0.7449553    -0.7449553    -0.7449553 ]
E1 = -658.334503644379  E_coul = 198.57766125026967
cycle= 1 E= -459.756842394109  delta_E= -10.3  |g|=    0  |ddm|= 0.302
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=6.11554e-14
diis-c [-3.7399845e-27  1.0000000e+00]
  mo_energy =
[-98.74742845 -10.27186684  -6.64011541  -6.64011541  -6.64011541
  -0.94401811  -0.23531031  -0.23531031  -0.23531031]
E1 = -658.3345036443786  E_coul = 198.5776612502696
cycle= 2 E= -459.756842394109  delta_E= 2.84e-13  |g|=    0  |ddm|= 2.28e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -658.3345036443786  E_coul = 198.5776612502696
  mo_energy =
[-98.74742845 -10.27186684  -6.64011541  -6.64011541  -6.64011541
  -0.94401811  -0.23531031  -0.23531031  -0.23531031]
E1 = -658.3345036443789  E_coul = 198.5776612502697
Extra cycle  E= -459.756842394109  delta_E= -1.71e-13  |g|=    0  |ddm|= 3e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.81439771101948
E1 = -658.3345036443789  E_coul = 198.5776612502697
init E= -459.756842394109
    CPU time for initialize scf      0.05 sec, wall time      0.05 sec
  mo_energy =
[-98.74742845 -10.27186684  -6.64011541  -6.64011541  -6.64011541
  -0.94401811  -0.23531031  -0.23531031  -0.23531031]
E1 = -658.3345036443786  E_coul = 198.57766125026956
cycle= 1 E= -459.756842394109  delta_E= 1.14e-13  |g|=    0  |ddm|= 3.75e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -658.3345036443786  E_coul = 198.57766125026956
  mo_energy =
[-98.74742845 -10.27186684  -6.64011541  -6.64011541  -6.64011541
  -0.94401811  -0.23531031  -0.23531031  -0.23531031]
E1 = -658.3345036443789  E_coul = 198.57766125026959
Extra cycle  E= -459.756842394109  delta_E= -2.27e-13  |g|=    0  |ddm|= 3.02e-15
    CPU time for scf_cycle      0.11 sec, wall time      0.11 sec
exp = [95.04577048  4.48812197  0.39798184  8.54701167  0.48930868]
grad_E = [-9.26675716e-07  2.82489672e-05 -1.48964813e-04  2.57093917e-05
  5.34080370e-04]
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:35 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0458279559        1
[INPUT] 0    0    [1    /1   ]  4.4881042475         1
[INPUT] 0    0    [1    /1   ]  0.397995280047       1
[INPUT] 1    0    [1    /1   ]  8.54696500387        1
[INPUT] 1    0    [1    /1   ]  0.489293287036       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04582795588792, 1.0]], [0, [4.488104247504839, 1.0]], [0, [0.3979952800469263, 1.0]], [1, [8.546965003871826, 1.0]], [1, [0.4892932870355041, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04582796]
bas 1, expnt(s) = [4.48810425]
bas 2, expnt(s) = [0.39799528]
bas 3, expnt(s) = [8.546965]
bas 4, expnt(s) = [0.48929329]
CPU time:       250.55
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04582796 76.90681357  4.48810425  7.79044429  0.39799528  1.26597015
  8.546965   42.63333431  0.48929329  1.19383956]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.24215027536196
cond(S) = 2.814450803837183
E1 = -630.6766925504213  E_coul = 181.23621810463047
init E= -449.440474445791
    CPU time for initialize scf      0.04 sec, wall time      0.05 sec
  mo_energy =
[-100.61050888  -11.53964507   -7.84943777   -7.84943777   -7.84943777
   -1.52247007   -0.74496645   -0.74496645   -0.74496645]
E1 = -658.333663022319  E_coul = 198.57682062195644
cycle= 1 E= -459.756842400363  delta_E= -10.3  |g|=    0  |ddm|= 0.302
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.12979e-14
diis-c [-1.70551728e-27  1.00000000e+00]
  mo_energy =
[-98.74751989 -10.27194507  -6.64016532  -6.64016532  -6.64016532
  -0.9440337   -0.23533876  -0.23533876  -0.23533876]
E1 = -658.333663022319  E_coul = 198.57682062195624
cycle= 2 E= -459.756842400363  delta_E= -2.27e-13  |g|=    0  |ddm|= 3.44e-15
    CPU time for cycle= 2      0.02 sec, wall time      0.03 sec
E1 = -658.333663022319  E_coul = 198.57682062195624
  mo_energy =
[-98.74751989 -10.27194507  -6.64016532  -6.64016532  -6.64016532
  -0.9440337   -0.23533876  -0.23533876  -0.23533876]
E1 = -658.3336630223191  E_coul = 198.57682062195636
Extra cycle  E= -459.756842400363  delta_E=    0  |g|=    0  |ddm|= 2.77e-15
    CPU time for scf_cycle      0.09 sec, wall time      0.12 sec
exp = [95.04582796  4.48810425  0.39799528  8.546965    0.48929329]
E = -459.75684240036276
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:36 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0458279559        1
[INPUT] 0    0    [1    /1   ]  4.4881042475         1
[INPUT] 0    0    [1    /1   ]  0.397995280047       1
[INPUT] 1    0    [1    /1   ]  8.54696500387        1
[INPUT] 1    0    [1    /1   ]  0.489293287036       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04582795588792, 1.0]], [0, [4.488104247504839, 1.0]], [0, [0.3979952800469263, 1.0]], [1, [8.546965003871826, 1.0]], [1, [0.4892932870355041, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04582796]
bas 1, expnt(s) = [4.48810425]
bas 2, expnt(s) = [0.39799528]
bas 3, expnt(s) = [8.546965]
bas 4, expnt(s) = [0.48929329]
CPU time:       251.60
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04582796 76.90681357  4.48810425  7.79044429  0.39799528  1.26597015
  8.546965   42.63333431  0.48929329  1.19383956]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.24215027536196
cond(S) = 2.814450803837183
E1 = -630.6766925504213  E_coul = 181.23621810463047
init E= -449.440474445791
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-100.61050888  -11.53964507   -7.84943777   -7.84943777   -7.84943777
   -1.52247007   -0.74496645   -0.74496645   -0.74496645]
E1 = -658.333663022319  E_coul = 198.57682062195644
cycle= 1 E= -459.756842400363  delta_E= -10.3  |g|=    0  |ddm|= 0.302
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.12979e-14
diis-c [-1.70551728e-27  1.00000000e+00]
  mo_energy =
[-98.74751989 -10.27194507  -6.64016532  -6.64016532  -6.64016532
  -0.9440337   -0.23533876  -0.23533876  -0.23533876]
E1 = -658.333663022319  E_coul = 198.57682062195624
cycle= 2 E= -459.756842400363  delta_E= -2.27e-13  |g|=    0  |ddm|= 3.44e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -658.333663022319  E_coul = 198.57682062195624
  mo_energy =
[-98.74751989 -10.27194507  -6.64016532  -6.64016532  -6.64016532
  -0.9440337   -0.23533876  -0.23533876  -0.23533876]
E1 = -658.3336630223191  E_coul = 198.57682062195636
Extra cycle  E= -459.756842400363  delta_E=    0  |g|=    0  |ddm|= 2.77e-15
    CPU time for scf_cycle      0.06 sec, wall time      0.08 sec
Set gradient conv threshold to 3.16228e-05
cond(S) = 2.814450803837183
E1 = -658.3336630223191  E_coul = 198.57682062195636
init E= -459.756842400363
    CPU time for initialize scf      0.10 sec, wall time      0.19 sec
  mo_energy =
[-98.74751989 -10.27194507  -6.64016532  -6.64016532  -6.64016532
  -0.9440337   -0.23533876  -0.23533876  -0.23533876]
E1 = -658.3336630223191  E_coul = 198.57682062195633
cycle= 1 E= -459.756842400363  delta_E=    0  |g|=    0  |ddm|= 2.89e-15
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
E1 = -658.3336630223191  E_coul = 198.57682062195633
  mo_energy =
[-98.74751989 -10.27194507  -6.64016532  -6.64016532  -6.64016532
  -0.9440337   -0.23533876  -0.23533876  -0.23533876]
E1 = -658.333663022319  E_coul = 198.57682062195633
Extra cycle  E= -459.756842400363  delta_E= 1.14e-13  |g|=    0  |ddm|= 2.74e-15
    CPU time for scf_cycle      0.17 sec, wall time      0.27 sec
exp = [95.04582796  4.48810425  0.39799528  8.546965    0.48929329]
grad_E = [-9.01947983e-09  4.40703525e-07  8.47915463e-06  1.00618092e-06
  3.82980702e-05]
 message: Optimization terminated successfully
 success: True
  status: 0
     fun: -459.75684240036276
       x: [ 9.505e+01  4.488e+00  3.980e-01  8.547e+00  4.893e-01]
     nit: 62
     jac: [-9.019e-09  4.407e-07  8.479e-06  1.006e-06  3.830e-05]
    nfev: 84
    njev: 62
#INFO: **** input file is /Users/vtan/basis-set-optimization/018_Ar/input.py ****
#!/usr/bin/env python

import pyscf
from pyscfad import gto, scf
import numpy as np
import re

from scipy import optimize

VERBOSITY = 9

def parse_basis_str(slug):
    numbers_and_letters = re.findall(r'[A-Za-z]+|\d+', slug)
    numbers_with_letters = [
        [int(numbers_and_letters[i]), numbers_and_letters[i+1].capitalize()]
        for i in range(0, len(numbers_and_letters), 2)
    ]
    return numbers_with_letters

def decaying_nums(n):
    return np.array([0.5 * (n - i) for i in range(n)])

def get_basis_substring(exponent, orbital):
    substring = f'''
    Ar  {orbital}
        {exponent}              1.0'''
    return substring

def get_basis_string(basis_str, exponents, exp_array=None):
    basis_set = parse_basis_str(basis_str)
    basis_nums = [num for [num, _] in basis_set]
    basis_cum_nums = np.cumsum(basis_nums)

    if exp_array is None:
        exp_array = np.zeros((exponents.size, 2))

    exp_array[np.where(exp_array[:, 1] == 0), 0] = exponents[np.where(exp_array[:, 1] == 0)]

    basis_string = ''.join([''.join([
        get_basis_substring(exp_array[i, 0], orbital) if j == 0 else
        get_basis_substring(exp_array[i + basis_cum_nums[j-1], 0], orbital)
        for i in range(num)
    ]) for j, [num, orbital] in enumerate(basis_set)])

    return basis_string

def atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}

    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    e = mf.kernel()

    print(f"exp = {exponents}")
    print(f"E = {e}")

    return e

def grad_atomic_energy(exponents, basis_str, exp_array=None):
    mol = gto.Mole()
    mol.atom = 'Ar 0 0 0'  # in Angstrom

    basis_string = get_basis_string(basis_str, exponents, exp_array)
    mol.basis = {'Ar': pyscf.gto.basis.parse(basis_string)}
    
    mol.verbose = VERBOSITY
    mol.build()

    mf = scf.RHF(mol)
    mf.kernel()
    jac = mf.energy_grad()

    print(f"exp = {exponents}")
    print(f"grad_E = {jac.exp}")

    grad_E = np.array(jac.exp)

    return grad_E

def minimize_energy(basis_str, exp_array=None):
    x0 = exp_array[:, 0]
    bnds = ((1e-9, None) for _ in range(exp_array.shape[0]))

    res = optimize.minimize(
        atomic_energy,
        x0,
        args=(basis_str, exp_array),
        method="SLSQP",
        jac=grad_atomic_energy,
        hess=None,
        hessp=None,
        bounds=bnds,
        tol=1e-9,
        callback=None,
        options={"maxfev": 10000, "ftol": 1e-9},
    )
    
    print(res)
    print(f"E = {atomic_energy(res.x, basis_str)}")
    print(f"exp = [{','.join(['{:.16e}'.format(x) for x in res.x])}]")
    
exps = np.zeros((5, 2))
exps[:, 0] = decaying_nums(5)
# exps[1:, 0] = exp_Ar_5s[:]
# exps[0, 0] = np.max(exp_Ar_5s) * 10.0

basis = "3s2p"

minimize_energy(basis, exps)
#INFO: ******************** input file end ********************


System: uname_result(system='Darwin', node='Vinnas-Air', release='19.6.0', version='Darwin Kernel Version 19.6.0: Tue Jun 21 21:18:39 PDT 2022; root:xnu-6153.141.66~1/RELEASE_X86_64', machine='x86_64', processor='i386')  Threads 1
Python 3.8.8 (default, Apr 13 2021, 12:59:45) 
[Clang 10.0.0 ]
numpy 1.24.2  scipy 1.10.1
Date: Sat Mar 11 23:14:41 2023
PySCF version 2.1.1
PySCF path  /Users/vtan/ve_pyscfad/lib/python3.8/site-packages/pyscf

[CONFIG] DEBUG = False
[CONFIG] MAX_MEMORY = 4000
[CONFIG] TMPDIR = /var/folders/c6/fyjd84g92vqcf03tnvqp486c0000gn/T/
[CONFIG] UNIT = angstrom
[CONFIG] VERBOSE = 3
[CONFIG] conf_file = /Users/vtan/.pyscf_conf.py
[CONFIG] pyscf_numpy_backend = jax
[CONFIG] pyscf_scipy_backend = jax
[CONFIG] pyscf_scipy_linalg_backend = pyscfad
[CONFIG] pyscfad = True
[CONFIG] pyscfad_ccsd_implicit_diff = True
[CONFIG] pyscfad_scf_implicit_diff = True
[INPUT] verbose = 9
[INPUT] max_memory = 4000 
[INPUT] num. atoms = 1
[INPUT] num. electrons = 18
[INPUT] charge = 0
[INPUT] spin (= nelec alpha-beta = 2S) = 0
[INPUT] symmetry False subgroup None
[INPUT] Mole.unit = angstrom
[INPUT] Symbol           X                Y                Z      unit          X                Y                Z       unit  Magmom
[INPUT]  1 Ar     0.000000000000   0.000000000000   0.000000000000 AA    0.000000000000   0.000000000000   0.000000000000 Bohr   0.0
[INPUT] ---------------- BASIS SET ---------------- 
[INPUT] l, kappa, [nprim/nctr], expnt,             c_1 c_2 ...
[INPUT] Ar
[INPUT] 0    0    [1    /1   ]  95.0458279559        1
[INPUT] 0    0    [1    /1   ]  4.4881042475         1
[INPUT] 0    0    [1    /1   ]  0.397995280047       1
[INPUT] 1    0    [1    /1   ]  8.54696500387        1
[INPUT] 1    0    [1    /1   ]  0.489293287036       1

nuclear repulsion = 0
number of shells = 5
number of NR pGTOs = 9
number of NR cGTOs = 9
basis = {'Ar': [[0, [95.04582795588792, 1.0]], [0, [4.488104247504839, 1.0]], [0, [0.3979952800469263, 1.0]], [1, [8.546965003871826, 1.0]], [1, [0.4892932870355041, 1.0]]]}
ecp = {}
bas 0, expnt(s) = [95.04582796]
bas 1, expnt(s) = [4.48810425]
bas 2, expnt(s) = [0.39799528]
bas 3, expnt(s) = [8.546965]
bas 4, expnt(s) = [0.48929329]
CPU time:       255.49
arg.atm = [[18 20  1 23  0  0]]
arg.bas = [[ 0  0  1  1  0 24 25  0]
 [ 0  0  1  1  0 26 27  0]
 [ 0  0  1  1  0 28 29  0]
 [ 0  1  1  1  0 30 31  0]
 [ 0  1  1  1  0 32 33  0]]
arg.env = [ 0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
  0.          0.          0.          0.          0.          0.
 95.04582796 76.90681357  4.48810425  7.79044429  0.39799528  1.26597015
  8.546965   42.63333431  0.48929329  1.19383956]
ecpbas  = []
Set gradient conv threshold to 3.16228e-05
Nelec from initial guess = 17.24215027536196
cond(S) = 2.814450803837183
E1 = -630.6766925504213  E_coul = 181.23621810463047
init E= -449.440474445791
    CPU time for initialize scf      0.02 sec, wall time      0.02 sec
  mo_energy =
[-100.61050888  -11.53964507   -7.84943777   -7.84943777   -7.84943777
   -1.52247007   -0.74496645   -0.74496645   -0.74496645]
E1 = -658.333663022319  E_coul = 198.57682062195644
cycle= 1 E= -459.756842400363  delta_E= -10.3  |g|=    0  |ddm|= 0.302
    CPU time for cycle= 1      0.01 sec, wall time      0.01 sec
diis-norm(errvec)=4.12979e-14
diis-c [-1.70551728e-27  1.00000000e+00]
  mo_energy =
[-98.74751989 -10.27194507  -6.64016532  -6.64016532  -6.64016532
  -0.9440337   -0.23533876  -0.23533876  -0.23533876]
E1 = -658.333663022319  E_coul = 198.57682062195624
cycle= 2 E= -459.756842400363  delta_E= -2.27e-13  |g|=    0  |ddm|= 3.44e-15
    CPU time for cycle= 2      0.01 sec, wall time      0.01 sec
E1 = -658.333663022319  E_coul = 198.57682062195624
  mo_energy =
[-98.74751989 -10.27194507  -6.64016532  -6.64016532  -6.64016532
  -0.9440337   -0.23533876  -0.23533876  -0.23533876]
E1 = -658.3336630223191  E_coul = 198.57682062195636
Extra cycle  E= -459.756842400363  delta_E=    0  |g|=    0  |ddm|= 2.77e-15
    CPU time for scf_cycle      0.05 sec, wall time      0.05 sec
exp = [95.04582796  4.48810425  0.39799528  8.546965    0.48929329]
E = -459.75684240036276
E = -459.75684240036276
exp = [9.5045827955887916e+01,4.4881042475048387e+00,3.9799528004692630e-01,8.5469650038718257e+00,4.8929328703550412e-01]
